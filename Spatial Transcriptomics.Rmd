---
title: "Spatial Transcriptomics"
author: "David Carro Vazquez"
date: "2025-04-02"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    self_contained: false
  pdf_document:
    toc: true
    toc_depth: '3'
---




```{r load_libraries, echo=TRUE, results='asis', message=FALSE, warning=FALSE, include=FALSE}


# Load necessary library
if (!requireNamespace("htmltools", quietly = TRUE)) {
  install.packages("htmltools")
}
library(htmltools)
library(knitr)

# Load Bootstrap's JavaScript and CSS for collapsible panels
cat('<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>')
cat('<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js"></script>')
cat('<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css">')

# Custom CSS for the collapsibles
cat('<style>
  details > summary {
    font-size: 1.5em; /* Make the text bigger */
    color: #007bff;   /* Blue color */
    font-weight: bold;
  }
  details > summary:hover {
    color: #0056b3;  /* Darker blue when hovering */
  }
</style>')



library(Seurat)
library(SeuratObject)

# Load necessary libraries
packages <- c("readxl", "Matrix", "data.table", "ggplot2", "htmltools", "knitr")

for (pkg in packages) {
  if (!requireNamespace(pkg, quietly = TRUE)) {
    install.packages(pkg, dependencies = TRUE)
  }
}

# Load the libraries after installation
lapply(packages, library, character.only = TRUE)


# Setup safer future settings for Seurat SCT or parallel steps
library(future)
plan(sequential)  # Use multisession later if needed
options(future.globals.maxSize = 4 * 1024^3)  # Allow up to 4 GB for globals

getOption("future.globals.maxSize") / 1024^3

# ---- Install & load MAST if missing ----
if (!requireNamespace("MAST", quietly = TRUE)) {
  if (!requireNamespace("BiocManager", quietly = TRUE)) install.packages("BiocManager")
  BiocManager::install("MAST")
}

library(MAST)







# ---- One-time setup (put near top of Rmd) ----

# Install missing packages only once
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

if (!requireNamespace("fgsea", quietly = TRUE))
    BiocManager::install("fgsea")

if (!requireNamespace("msigdbr", quietly = TRUE))
    install.packages("msigdbr")

# Load libraries
suppressPackageStartupMessages({
  library(fgsea)
  library(data.table)
  library(msigdbr)
  library(dplyr)
})

set.seed(123)  # reproducibility for fgseaMultilevel's internal steps

wanted_categories <- c("H", "C2", "C5")

msig_mouse <- msigdbr(species = "Mus musculus")

# Pick correct column name based on your version
if ("gs_cat" %in% colnames(msig_mouse)) {
  msig_mouse <- msig_mouse %>% filter(gs_cat %in% wanted_categories)
} else if ("gs_collection" %in% colnames(msig_mouse)) {
  msig_mouse <- msig_mouse %>% filter(gs_collection %in% wanted_categories)
}

pathways_mouse <- split(msig_mouse$gene_symbol, msig_mouse$gs_name)


# Optional: quick check
message("Number of pathways loaded: ", length(pathways_mouse))

# ---- GSEA tuning knobs ----
gsea_min_size <- 15
gsea_max_size <- 500
gsea_q_cutoff <- 0.25  # standard GSEA FDR cutoff

# ---- Container for results ----
gsea_results_main_model <- list()






library(ggvenn)


```



# Define elements for the analysis

```{r load_file, echo=TRUE, results='asis', message=FALSE, warning=FALSE}


####################### TO DO ############################

# Define the root data path
root_path <- "C:/Users/dvazquez1/Desktop/spatial_transcriptomics/To_Analyze/data"


# Define the mouse IDs
#mouse_ids <- c("Young1", "AgedOA3", "Young3", "Aged5", "Aged4R", "Young4R", "Young10R", "Aged10R")



mouse_ids <- c("Young1", "AgedOA3", "Young3", "Aged5", "Aged4R", "Young4R", "Young10R", "Aged10R", "Aged2R", "Young18R", "Young33R", "Young45R", "Young46R", "Young47R", "Young6R", "Aged3R")


# Define the knee subregions

#subregions <- c("Cartilage_Femur", "Cartilage_Tibia", "Subchondral_Femur", "Subchondral_Tibia")

subregions <- c("Cartilage_Femur", "Cartilage_Tibia", "Subchondral_Femur", "Subchondral_Tibia", "Synovial", "FatPad", "Menisco", "GrPlate_Femur", "GrPlate_Tibia", "BM_Femur", "BM_Tibia")




```


# 1. Barcode QC

## 1.1 Visualization of barcodes and genes at Barcode QC


```{r barcodeQC, echo=TRUE, results='asis', message=FALSE, warning=FALSE}

# HTML start
cat(HTML('<div class="container">'))
library(patchwork)  # for combining violins
library(ggplot2)    # for bar plots


filtered_list <- list()
raw_seurat_list <- list()


for (mouse_id in mouse_ids) {
  cat(HTML(sprintf('<details><summary><strong>Sample ID: %s</strong></summary>', mouse_id)))
  cat(HTML(sprintf('<p>Processing mouse ID: %s</p>', mouse_id)))

  # Load data
  h5_filename <- paste0(mouse_id, "_filtered_feature_bc_matrix.h5")
  h5_path     <- file.path(root_path, h5_filename)
  if (!file.exists(h5_path)) {
    cat(HTML(sprintf('<p style="color:red;">HDF5 file not found for: %s</p>', mouse_id)))
    next
  }
  expression_data <- Read10X_h5(h5_path)

  # Assign mouse ID as project name to set orig.ident
  seurat_obj <- CreateSeuratObject(counts = expression_data, project = mouse_id)
  seurat_obj[["percent.mt"]] <- PercentageFeatureSet(seurat_obj, pattern="^mt-")
  # 🔧 Fix colnames in RNA@layers immediately after object creation
  if ("layers" %in% slotNames(seurat_obj[["RNA"]])) {
    for (lname in names(seurat_obj[["RNA"]]@layers)) {
      layer_mat <- seurat_obj[["RNA"]]@layers[[lname]]
      if (is.null(colnames(layer_mat))) {
        colnames(layer_mat) <- colnames(seurat_obj)
        seurat_obj[["RNA"]]@layers[[lname]] <- layer_mat
        message(sprintf("✅ Fixed colnames in RNA@layers[['%s']] for %s", lname, mouse_id))
      }
    }
  }

  cat(HTML(sprintf('<p>Seurat object created for: %s</p>', mouse_id)))

  for (subregion in subregions) {
    cat(HTML(sprintf('<details><summary>%s</summary>', subregion)))
      raw_key <- paste0(mouse_id, "_", subregion)
      raw_seurat_list[[raw_key]] <- seurat_obj

    excel_filename <- paste0(mouse_id, "_", subregion, ".xlsx")
    excel_path     <- file.path(root_path, excel_filename)
    if (!file.exists(excel_path)) {
      cat(HTML(sprintf(
        '<p style="color:red;">Barcode Excel file not found for: %s of %s</p>',
        subregion, mouse_id)))
      cat(HTML('</details>'))
      next
    }
    meta_df <- read_excel(excel_path)
    colnames(meta_df)[1] <- "barcode"
    keep_cells    <- intersect(colnames(seurat_obj), meta_df$barcode)

    raw_key <- paste0(mouse_id, "_", subregion)
    raw_seurat_list[[raw_key]] <- seurat_obj

    subset_seurat <- subset(seurat_obj, cells = keep_cells)
    cat(HTML(sprintf('<p>%d barcodes in subset</p>', length(keep_cells))))

    for (col in setdiff(colnames(meta_df), "barcode")) {
      vals <- meta_df[[col]][match(keep_cells, meta_df$barcode)]
      subset_seurat@meta.data[keep_cells, col] <- vals
    }

    n_cells_orig <- length(keep_cells)
    cat(HTML(sprintf('<p>%d barcodes in subset</p>', n_cells_orig)))

    if (n_cells_orig > 0) {
      subset_seurat[["gene_counts_per_barcode"]] <- colSums(GetAssayData(subset_seurat, slot="counts") > 0)
      subset_seurat[["total_counts_per_barcode"]] <- colSums(GetAssayData(subset_seurat, slot="counts"))
      subset_seurat[["mito_fraction"]] <- subset_seurat[["percent.mt"]] / 100
      subset_seurat[["complexity_score"]] <- subset_seurat[["gene_counts_per_barcode"]] /
                                              subset_seurat[["total_counts_per_barcode"]]
      counts_mat <- GetAssayData(subset_seurat, slot="counts")
      subset_seurat[["top50_frac"]] <- apply(counts_mat, 2, function(col) {
        s <- sort(col, decreasing = TRUE)
        sum(s[1:50]) / sum(s) * 100
      })

      qc_pre_df <- as.data.frame(summary(subset_seurat@meta.data[, c(
        "percent.mt", "gene_counts_per_barcode", "total_counts_per_barcode",
        "mito_fraction", "complexity_score", "top50_frac"
      )]))
      colnames(qc_pre_df) <- paste0("Pre_", colnames(qc_pre_df))

      low_gene_cutoff <- quantile(subset_seurat$nFeature_RNA, 0.05)
      low_umi_cutoff  <- quantile(subset_seurat$nCount_RNA,   0.05)
      final_gene_cut  <- max(2, low_gene_cutoff)
      final_umi_cut   <- max(2, low_umi_cutoff)

      subset_filtered <- subset(
        subset_seurat,
        subset = nFeature_RNA >= final_gene_cut &
                 nCount_RNA   >= final_umi_cut  &
                 percent.mt   <= 20
      )

      DefaultAssay(subset_filtered) <- "RNA"
      raw_mat <- GetAssayData(subset_filtered, assay = "RNA", slot = "counts")
      colnames(raw_mat) <- colnames(subset_filtered)
      subset_filtered[["RawCounts"]] <- CreateAssayObject(counts = raw_mat)
      DefaultAssay(subset_filtered) <- "RawCounts"

      key <- paste0(subregion, "_", mouse_id)

      rna_counts <- GetAssayData(subset_filtered[["RNA"]], slot = "counts")
      if (is.null(colnames(rna_counts))) {
        colnames(rna_counts) <- colnames(subset_filtered)
        subset_filtered[["RNA"]] <- SetAssayData(
          subset_filtered[["RNA"]],
          slot = "counts",
          new.data = rna_counts
        )
        message(sprintf("✅ Fixed missing colnames in 'RNA' assay of %s", key))
      }

            # --- FIX colnames in RNA@layers if present ---
      
      assay <- subset_filtered[["RNA"]]
      if ("layers" %in% slotNames(assay)) {
        for (lname in names(assay@layers)) {
         layer_mat <- assay@layers[[lname]]
          if (is.null(colnames(layer_mat))) {
           barcodes <- colnames(subset_filtered)
           if (length(barcodes) == ncol(layer_mat)) {
              colnames(layer_mat) <- barcodes
              assay@layers[[lname]] <- layer_mat
             message(sprintf("✅ Fixed colnames in RNA@layers[['%s']] of %s", lname, key))
           } else {
             warning(sprintf("❌ Could not fix RNA@layers[['%s']] in %s: mismatched column count", lname, key))
            }
          }
       }
       subset_filtered[["RNA"]] <- assay
      }

      key <- paste0(subregion, "_", mouse_id)
      filtered_list[[key]] <- subset_filtered

      qc_post_df <- as.data.frame(summary(subset_filtered@meta.data[, c(
        "percent.mt", "gene_counts_per_barcode", "total_counts_per_barcode",
        "mito_fraction", "complexity_score", "top50_frac"
      )]))
      colnames(qc_post_df) <- paste0("Post_", colnames(qc_post_df))

      pre_rows <- rownames(qc_pre_df)
      post_rows <- rownames(qc_post_df)
      missing_in_post <- setdiff(pre_rows, post_rows)
      missing_in_pre  <- setdiff(post_rows, pre_rows)

      if (length(missing_in_post) > 0 | length(missing_in_pre) > 0) {
        mismatch_tbl <- data.frame(
          Metric = union(pre_rows, post_rows),
          In_Pre  = union(pre_rows, post_rows) %in% pre_rows,
          In_Post = union(pre_rows, post_rows) %in% post_rows
        )
        cat(HTML('<p><strong>⚠️ QC Metric Row Mismatch Detected</strong></p>'))
        cat(kable(mismatch_tbl, format = "html", table.attr = "class='table table-bordered table-striped'"))
      }

      # ✅✅✅ START: RESTORED REPORTING BLOCKS ✅✅✅

      common_metrics <- intersect(rownames(qc_pre_df), rownames(qc_post_df))
      qc_pre_df  <- qc_pre_df[common_metrics, , drop = FALSE]
      qc_post_df <- qc_post_df[common_metrics, , drop = FALSE]

      qc_combined <- cbind(
        Metric = rownames(qc_pre_df),
        qc_pre_df,
        qc_post_df
      )
      rownames(qc_combined) <- NULL
      cat(HTML('<p><strong>QC Statistics: Pre vs Post Filtering</strong></p>'))
      cat(kable(qc_combined, format = "html", digits = 1,
                table.attr= "class='table table-bordered'"))

      expr_pre   <- GetAssayData(subset_seurat, slot="counts")
      means_pre  <- Matrix::rowMeans(expr_pre)
      cov_pre    <- Matrix::rowSums(expr_pre > 0) / ncol(expr_pre) * 100
      top50_pre  <- data.frame(
        Gene         = names(means_pre),
        Mean_Pre     = round(as.numeric(means_pre), 3),
        Coverage_Pre = round(as.numeric(cov_pre), 3),
        stringsAsFactors = FALSE
      )[order(means_pre, decreasing=TRUE)[1:50], ]

      expr_post  <- GetAssayData(subset_filtered, slot="counts")
      means_post <- Matrix::rowMeans(expr_post)
      cov_post   <- Matrix::rowSums(expr_post > 0) / ncol(expr_post) * 100
      top50_post <- data.frame(
        Gene          = names(means_post),
        Mean_Post     = round(as.numeric(means_post), 3),
        Coverage_Post = round(as.numeric(cov_post), 3),
        stringsAsFactors = FALSE
      )[order(means_post, decreasing=TRUE)[1:50], ]

      combined_top50 <- cbind(
        top50_pre,
        top50_post[, c("Mean_Post","Coverage_Post")]
      )
      cat(HTML('<p><strong>Top 50 Genes by Raw Mean Expression & Coverage (Pre vs Post)</strong></p>'))
      cat(kable(combined_top50, format = "html", digits = 3,
                col.names = c("Gene","Mean_Pre","Coverage_Pre","Mean_Post","Coverage_Post"),
                table.attr = "class='table table-striped table-bordered'"))

      # Failure Rates (fixed and data-driven)
      gene_thresholds <- c(20,10,5,2)
      umi_thresholds  <- c(50,20,10,5,2)
      mt_thresholds   <- c(10,20)
      checks <- c(
        lapply(gene_thresholds, function(g) list(label=paste0("Genes ≥ ",g), pass=subset_seurat$nFeature_RNA>=g)),
        lapply(umi_thresholds,  function(u) list(label=paste0("UMIs ≥ ",u), pass=subset_seurat$nCount_RNA>=u)),
        lapply(mt_thresholds,   function(m) list(label=paste0("Percent Mito ≤ ",m,"%"), pass=subset_seurat$percent.mt<=m))
      )
      df_fixed <- do.call(rbind, lapply(checks, function(chk){
        data.frame(Threshold=chk$label,
                   Fail_Count=sum(!chk$pass),
                   Total_Cells=n_cells_orig,
                   stringsAsFactors=FALSE)
      }))
      all_pass <- Reduce(`&`, lapply(checks, `[[`,"pass"))
      df_fixed <- rbind(df_fixed,
                        data.frame(Threshold="All Combined",
                                   Fail_Count=sum(!all_pass),
                                   Total_Cells=n_cells_orig,
                                   stringsAsFactors=FALSE))
      df_fixed$Fail_Pct <- round(df_fixed$Fail_Count/df_fixed$Total_Cells*100,1)
      cat(HTML('<p>Fixed‑Threshold Failure Rates:</p>'))
      cat(kable(df_fixed, format="html", digits=1,
                col.names=c("Threshold","Barcodes Failing","Total Barcodes","Failure %"),
                table.attr="class='table table-striped table-bordered'"))

      df_data <- data.frame(
        Threshold   = c(sprintf("Genes ≥ %.0f (5th %%)", low_gene_cutoff),
                        sprintf("UMIs ≥ %.0f (5th %%)",  low_umi_cutoff),
                        "Percent Mito ≤ 20%",
                        "All Combined"),
        Fail_Count  = c(sum(subset_seurat$nFeature_RNA < low_gene_cutoff),
                        sum(subset_seurat$nCount_RNA   < low_umi_cutoff),
                        sum(subset_seurat$percent.mt   > 20),
                        NA),
        Total_Cells = n_cells_orig,
        stringsAsFactors = FALSE
      )
      pass_data <- (subset_seurat$nFeature_RNA >= low_gene_cutoff) &
                   (subset_seurat$nCount_RNA   >= low_umi_cutoff) &
                   (subset_seurat$percent.mt   <= 20)
      df_data$Fail_Count[4] <- sum(!pass_data)
      df_data$Fail_Pct <- round(df_data$Fail_Count / df_data$Total_Cells * 100, 1)
      cat(HTML('<p>Data‑Driven Failure Rates:</p>'))
      cat(kable(df_data, format="html", digits=1,
                col.names=c("Threshold","Barcodes Failing","Total Barcodes","Failure %"),
                table.attr="class='table table-striped table-bordered'"))

      # Histogram overlays
      df_both <- rbind(
        data.frame(Value=subset_seurat$nFeature_RNA, Metric="Genes per Barcode", Filter="Pre"),
        data.frame(Value=subset_seurat$nCount_RNA,   Metric="Total UMIs",     Filter="Pre"),
        data.frame(Value=subset_seurat$percent.mt,   Metric="% Mito",         Filter="Pre"),
        data.frame(Value=subset_filtered$nFeature_RNA,Metric="Genes per Barcode",Filter="Post"),
        data.frame(Value=subset_filtered$nCount_RNA,  Metric="Total UMIs",    Filter="Post"),
        data.frame(Value=subset_filtered$percent.mt,  Metric="% Mito",        Filter="Post")
      )
      cat(HTML('<p><strong>QC Metric Distributions: Pre vs Post Filtering</strong></p>'))
      print(
        ggplot(df_both, aes(x=Value, fill=Filter)) +
          geom_histogram(position="identity", alpha=0.4, bins=30) +
          facet_wrap(~Metric, scales="free") +
          xlab(NULL) + ylab("Cell Count") +
          theme_minimal() +
          theme(strip.text = element_text(size=10, face="bold"),
                legend.position = "top")
      )

      # Violin plots + FeatureScatter

      
      # Pretty labels

      pretty_names <- c(
        "percent.mt" = "% mt",
        "gene_counts_per_barcode" = "Genes / Barcode",
        "total_counts_per_barcode" = "UMIs / Barcode",
        "mito_fraction" = "Mito Fraction",
        "complexity_score" = "Complexity",
        "top50_frac" = "Top 50 Gene Fraction"
      )

      features <- names(pretty_names)

      # Generate violin plots individually with updated titles
      vln_list <- lapply(features, function(feat) {
        VlnPlot(subset_filtered, features = feat, pt.size = 0.1) +
        ggtitle(pretty_names[[feat]]) +
          theme_minimal() +
          theme(
            strip.text = element_text(size = 8),
            axis.text.x = element_text(size = 6, angle = 45, hjust = 1),
            axis.title = element_text(size = 9)
          )
      })

      # Combine with patchwork
      vln <- wrap_plots(vln_list, ncol = 3) + plot_layout(guides = "collect")
      print(vln)




      print(FeatureScatter(subset_filtered, "total_counts_per_barcode", "gene_counts_per_barcode") +
            ggtitle("UMIs vs Genes") + xlab("Total UMIs") + ylab("Genes per Barcode") + theme_minimal())

      print(FeatureScatter(subset_filtered, "total_counts_per_barcode", "mito_fraction") +
            ggtitle("Mito Fraction vs UMIs") + xlab("Total UMIs") + ylab("Mito Fraction") + theme_minimal())

      # ✅✅✅ END: RESTORED REPORTING BLOCKS ✅✅✅
    }

    cat(HTML('</details>'))
  }
  cat(HTML('</details>'))
}



```


```{r barcodeQC1, echo=TRUE, results='asis', message=FALSE, warning=FALSE, fig.width=12, fig.height=10}

library(ggplot2)
library(patchwork)
library(dplyr)
library(tidyr)
library(htmltools)

# Define QC metrics and pretty labels
qc_vars <- c("percent.mt", "gene_counts_per_barcode", "total_counts_per_barcode",
             "mito_fraction", "complexity_score", "top50_frac")

pretty_labels <- c(
  "percent.mt" = "% mt",
  "gene_counts_per_barcode" = "Genes / Barcode",
  "total_counts_per_barcode" = "UMIs / Barcode",
  "mito_fraction" = "Mito Fraction",
  "complexity_score" = "Complexity",
  "top50_frac" = "Top 50 Gene Fraction"
)

# Merge metadata from filtered_list
meta_combined <- do.call(rbind, lapply(names(filtered_list), function(key) {
  seurat_obj <- filtered_list[[key]]
  split_parts <- strsplit(key, "_")[[1]]
  raw_subregion <- paste0(split_parts[1], "_", split_parts[2])

  subregion <- if (split_parts[1] %in% c("Synovial", "FatPad", "Menisco")) {
    split_parts[1]
  } else {
    raw_subregion
  }

  sample_id <- if (length(split_parts) >= 3) split_parts[3] else split_parts[2]
  meta <- seurat_obj@meta.data
  meta$Subregion <- subregion
  meta$SampleID <- sample_id
  meta$Barcode <- rownames(meta)
  meta[, c("Subregion", "SampleID", "Barcode", qc_vars), drop = FALSE]
}))

# Pivot to long format for violin plots
qc_long <- meta_combined %>%
  pivot_longer(cols = all_of(qc_vars), names_to = "Metric", values_to = "Value")

qc_long$Metric <- factor(qc_long$Metric, levels = names(pretty_labels),
                         labels = pretty_labels[names(pretty_labels)])

# Select subregions to display
subregions_to_plot <- c("Cartilage_Femur", "Cartilage_Tibia",
                        "Subchondral_Femur", "Subchondral_Tibia",
                        "BM_Femur", "BM_Tibia",
                        "GrPlate_Femur", "GrPlate_Tibia",
                        "Synovial", "FatPad", "Menisco")

# Loop per tissue subregion
for (subregion in subregions_to_plot) {
  sub_df <- subset(qc_long, Subregion == subregion)
  if (nrow(sub_df) == 0) next

  cat(sprintf("<details><summary><strong>%s</strong></summary>\n\n", subregion))

  # --- Violin plots (legend hidden) ---
  p_violin <- ggplot(sub_df, aes(x = SampleID, y = Value, fill = SampleID)) +
    geom_violin(scale = "width", trim = TRUE, color = "gray30", alpha = 0.6) +
    geom_jitter(aes(color = SampleID), width = 0.25, alpha = 0.3, size = 0.5) +
    facet_wrap(~Metric, scales = "free_y", ncol = 2) +
    theme_minimal(base_size = 12) +
    theme(
      strip.text = element_text(size = 11, face = "bold"),
      axis.text.x = element_text(angle = 45, hjust = 1, size = 8),
      axis.title = element_text(size = 11),
      plot.title = element_text(size = 13, face = "bold"),
      legend.position = "none"
    ) +
    xlab("Sample ID") +
    ylab("Metric Value") +
    ggtitle(paste("QC Violin Plots —", subregion))
  print(p_violin)

  # --- Pre vs Post Filtering Histograms by Sample ---
  sample_keys <- grep(paste0("^", subregion, "_"), names(filtered_list), value = TRUE)
  for (key in sample_keys) {
    seurat_filtered <- filtered_list[[key]]
    seurat_raw <- raw_seurat_list[[key]]
    if (is.null(seurat_filtered) || is.null(seurat_raw)) next
    sample_id <- gsub(".*_", "", key)

    df_both <- rbind(
      data.frame(Value = seurat_raw$nFeature_RNA, Metric = "Genes per Barcode", Filter = "Pre", SampleID = sample_id),
      data.frame(Value = seurat_raw$nCount_RNA, Metric = "Total UMIs", Filter = "Pre", SampleID = sample_id),
      data.frame(Value = seurat_raw$percent.mt, Metric = "% Mito", Filter = "Pre", SampleID = sample_id),
      data.frame(Value = seurat_filtered$nFeature_RNA, Metric = "Genes per Barcode", Filter = "Post", SampleID = sample_id),
      data.frame(Value = seurat_filtered$nCount_RNA, Metric = "Total UMIs", Filter = "Post", SampleID = sample_id),
      data.frame(Value = seurat_filtered$percent.mt, Metric = "% Mito", Filter = "Post", SampleID = sample_id)
    )

    p_hist <- ggplot(df_both, aes(x = Value, fill = Filter)) +
      geom_histogram(position = "identity", alpha = 0.4, bins = 30) +
      facet_wrap(~Metric, scales = "free", nrow = 1) +
      xlab(NULL) + ylab("Cell Count") +
      ggtitle(paste("Sample:", sample_id)) +
      theme_minimal(base_size = 11) +
      theme(strip.text = element_text(size = 9, face = "bold"),
            legend.position = "top",
            plot.title = element_text(size = 12),
            axis.text.x = element_text(size = 7, angle = 45, hjust = 1))
    cat(sprintf("<details><summary><em>Sample %s — Pre vs Post Filtering</em></summary>\n\n", sample_id))
    print(p_hist)
    cat("</details>\n\n")
  }

  # --- Scatter: UMIs vs Genes ---
  scatter1_df <- subset(meta_combined, Subregion == subregion)
  p_scatter1 <- ggplot(scatter1_df, aes(x = total_counts_per_barcode,
                                        y = gene_counts_per_barcode,
                                        color = SampleID)) +
    geom_point(alpha = 0.6, size = 1.8) +
    theme_minimal() +
    xlab("Total UMIs") + ylab("Genes per Barcode") +
    ggtitle(paste("UMIs vs Genes —", subregion)) +
    theme(
      legend.position = "right",
      axis.text = element_text(size = 7)
    ) +
    guides(color = guide_legend(override.aes = list(size = 3)))
  print(p_scatter1)

  # --- Scatter: Mito Fraction vs UMIs ---
  p_scatter2 <- ggplot(scatter1_df, aes(x = total_counts_per_barcode,
                                        y = mito_fraction,
                                        color = SampleID)) +
    geom_point(alpha = 0.6, size = 1.8) +
    theme_minimal() +
    xlab("Total UMIs") + ylab("Mito Fraction") +
    ggtitle(paste("Mito Fraction vs UMIs —", subregion)) +
    theme(
      legend.position = "right",
      axis.text = element_text(size = 7)
    ) +
    guides(color = guide_legend(override.aes = list(size = 3)))
  print(p_scatter2)

  cat("</details>\n\n")
}







```



### 1.1.1 Checking Seurat object after barcode QC to allow future SCTransform Normalization



```{r barcodeQCCheck, echo=TRUE, results='asis', message=FALSE, warning=FALSE}



inspect_seurat_object_full_html <- function(seurat_list, list_name = "raw_list") {
  library(htmltools)

  # Group entries by sample ID prefix (e.g., "Young1")
  grouped <- split(names(seurat_list), sapply(strsplit(names(seurat_list), "_"), `[`, 1))

  for (sample_id in names(grouped)) {
    cat(HTML(sprintf('<details><summary><strong>%s</strong></summary>', sample_id)))

    for (name in grouped[[sample_id]]) {
      obj <- seurat_list[[name]]
      cat(HTML(sprintf("<pre><code>🔍 Inspecting: %s (%s)\n", name, list_name)))

      meta_barcodes <- rownames(obj@meta.data)
      cat(sprintf("🔹 Metadata barcodes: %d\n", length(meta_barcodes)))

      if (!"RNA" %in% names(obj@assays)) {
        cat("❌ RNA assay not found\n</code></pre>")
        next
      }

      assay <- obj[["RNA"]]

      tryCatch({
        counts <- GetAssayData(assay, slot = "counts")
        cat(sprintf("✅ RNA@counts: %d genes × %d barcodes | Has colnames: %s\n",
                    nrow(counts), ncol(counts), !is.null(colnames(counts))))
      }, error = function(e) {
        cat("❌ RNA@counts slot not accessible\n")
      })

      if ("layers" %in% slotNames(assay)) {
        if (length(assay@layers) == 0) {
          cat("⚠️ RNA@layers slot exists but is empty\n")
        } else {
          cat(sprintf("🔸 RNA@layers: %d layer(s)\n", length(assay@layers)))
          for (lname in names(assay@layers)) {
            lmat <- assay@layers[[lname]]
            cat(sprintf("   • %s: %d × %d | Has colnames: %s\n",
                        lname, nrow(lmat), ncol(lmat), !is.null(colnames(lmat))))
          }
        }
      } else {
        cat("ℹ️ RNA@layers slot not found\n")
      }

      if ("RawCounts" %in% names(obj@assays)) {
        rc <- GetAssayData(obj[["RawCounts"]], slot = "counts")
        cat(sprintf("✅ RawCounts: %d genes × %d barcodes | Has colnames: %s\n",
                    nrow(rc), ncol(rc), !is.null(colnames(rc))))
      } else {
        cat("ℹ️ No RawCounts assay found\n")
      }

      ref_barcodes <- colnames(obj)
      tryCatch({
        default_counts <- GetAssayData(obj, assay = DefaultAssay(obj), slot = "counts")
        default_match <- identical(colnames(default_counts), ref_barcodes)
        cat(sprintf("🔍 DefaultAssay barcodes match: %s\n", default_match))
      }, error = function(e) {
        cat("⚠️ Could not check DefaultAssay colnames\n")
      })

      if ("RNA" %in% names(obj@assays) && "layers" %in% slotNames(assay)) {
        for (lname in names(assay@layers)) {
          lmat <- assay@layers[[lname]]
          match_status <- identical(colnames(lmat), ref_barcodes)
          cat(sprintf("   🔁 Layer '%s' barcodes match metadata: %s\n", lname, match_status))
        }
      }

      cat("</code></pre>")
    }

    cat(HTML("</details>"))
  }
}



inspect_seurat_object_full_html(raw_seurat_list, list_name = "raw_seurat_list")




if (exists("raw_seurat_list")) {
  rm(raw_seurat_list)
  gc()
}



# Check for presence of layers in the saved filtered object

library(htmltools)

# Function to extract ID (after last underscore)
get_id <- function(x) sub(".*_(\\w+)$", "\\1", x)

# Group keys by ID
grouped_keys <- split(names(filtered_list), sapply(names(filtered_list), get_id))

# Loop and print collapsibles by ID
for (sample_id in names(grouped_keys)) {
  cat(HTML(sprintf('<details><summary><strong>%s</strong></summary><pre><code>', sample_id)))

  for (key in grouped_keys[[sample_id]]) {
    obj <- filtered_list[[key]]
    assay <- obj[["RNA"]]
    if ("layers" %in% slotNames(assay)) {
      cat(sprintf("✅ %s: RNA assay has %d layer(s).\n", key, length(assay@layers)))
    } else {
      cat(sprintf("❌ %s: RNA assay has no layers slot!\n", key))
    }
  }

  cat(HTML('</code></pre></details>\n'))
}





# Check colnames across RawCounts & RNA@layers
check_layer_colnames_html_grouped <- function(seurat_list, assay_name = "RNA") {
  library(knitr)
  library(htmltools)

  # Group keys by sample ID (last part after the last "_")
  get_sample_id <- function(x) sub(".*_(.*?)$", "\\1", x)
  sample_groups <- split(names(seurat_list), sapply(names(seurat_list), get_sample_id))

  all_results <- data.frame(
    Object = character(),
    Assay_Layer = character(),
    n_cols = integer(),
    has_colnames = logical(),
    stringsAsFactors = FALSE
  )

  for (sample_id in names(sample_groups)) {
    cat(HTML(sprintf("<details><summary><strong>%s</strong></summary>", sample_id)))

    for (obj_name in sample_groups[[sample_id]]) {
      obj <- seurat_list[[obj_name]]
      obj_results <- data.frame(
        Object = character(),
        Assay_Layer = character(),
        n_cols = integer(),
        has_colnames = logical(),
        stringsAsFactors = FALSE
      )

      # RawCounts
      if ("RawCounts" %in% names(obj@assays)) {
        raw_mat <- GetAssayData(obj[["RawCounts"]], slot = "counts")
        obj_results <- rbind(obj_results, data.frame(
          Object = obj_name,
          Assay_Layer = "RawCounts",
          n_cols = ncol(raw_mat),
          has_colnames = !is.null(colnames(raw_mat))
        ))
      }

      # RNA + layers
      if (assay_name %in% names(obj@assays)) {
        rna_mat <- GetAssayData(obj[[assay_name]], slot = "counts")
        obj_results <- rbind(obj_results, data.frame(
          Object = obj_name,
          Assay_Layer = "counts",
          n_cols = ncol(rna_mat),
          has_colnames = !is.null(colnames(rna_mat))
        ))

        assay <- obj[[assay_name]]
        if ("layers" %in% slotNames(assay)) {
          for (lname in names(assay@layers)) {
            mat <- assay@layers[[lname]]
            obj_results <- rbind(obj_results, data.frame(
              Object = obj_name,
              Assay_Layer = paste0("layer_", lname),
              n_cols = ncol(mat),
              has_colnames = !is.null(colnames(mat))
            ))
          }
        }
      }

      if (nrow(obj_results) > 0) {
        all_results <- rbind(all_results, obj_results)
        cat(HTML(sprintf("<p><strong>%s</strong></p>", obj_name)))
        cat(kable(obj_results[, -1], format = "html", table.attr = "class='table table-bordered table-sm'"))
      } else {
        cat(HTML(sprintf("<p><strong>%s</strong>: No assay/layer data found</strong></p>", obj_name)))
      }
    }

    cat(HTML("</details>\n"))
  }

  return(all_results)
}

# Run the function
layer_colname_status <- check_layer_colnames_html_grouped(filtered_list)




# Checking barcodes matching


# Check for barcode mismatches across all Seurat objects in a list (e.g., filtered_list or gene_filtered_list)
check_barcode_consistency_by_id <- function(seurat_list, list_name = "seurat_list") {
  results <- data.frame(
    Object = character(),
    n_metadata = integer(),
    n_counts = integer(),
    Match = logical(),
    stringsAsFactors = FALSE
  )
  
  # Helper to extract sample ID (last part after final "_")
  get_sample_id <- function(x) sub(".*_(.*?)$", "\\1", x)
  sample_groups <- split(names(seurat_list), sapply(names(seurat_list), get_sample_id))

  for (sample_id in names(sample_groups)) {
    cat(HTML(sprintf("<details><summary><strong>%s</strong></summary>", sample_id)))

    for (obj_name in sample_groups[[sample_id]]) {
      obj <- seurat_list[[obj_name]]
      meta_barcodes <- rownames(obj@meta.data)
      assay_barcodes <- colnames(GetAssayData(obj, slot = "counts"))

      match_status <- identical(meta_barcodes, assay_barcodes)

      results <- rbind(results, data.frame(
        Object = obj_name,
        n_metadata = length(meta_barcodes),
        n_counts = length(assay_barcodes),
        Match = match_status,
        stringsAsFactors = FALSE
      ))

      cat(HTML(sprintf(
        "<details><summary><strong>%s</strong>: %s</summary>",
        obj_name,
        if (match_status) "✅ Matching barcodes" else "❌ Mismatch detected"
      )))
      
      cat(HTML(sprintf("<p><b>Metadata barcodes:</b> %d<br><b>Assay barcodes:</b> %d</p>",
                       length(meta_barcodes), length(assay_barcodes))))
      
      if (!match_status) {
        first_diff <- which(meta_barcodes != assay_barcodes)[1]
        if (!is.na(first_diff)) {
          cat(HTML(sprintf(
            "<p style='color:red;'>First mismatch at position %d:<br>
            meta = <code>%s</code><br>
            counts = <code>%s</code></p>",
            first_diff,
            meta_barcodes[first_diff],
            assay_barcodes[first_diff]
          )))
        }
      }

      cat(HTML("</details>\n"))
    }

    cat(HTML("</details>\n"))
  }

  return(results)
}

# Usage
consistency_summary_filtered <- check_barcode_consistency_by_id(filtered_list)



# Function to check barcode (colname) integrity
cat(HTML("<details><summary><strong>🔍 Check Barcode Colname Integrity</strong></summary>"))
cat(HTML("<pre><code>"))

# -- START: Print the code block itself --
cat('
# Function to check barcode (colname) integrity
check_colname_integrity <- function(seurat_list) {
  results <- list()

  for (name in names(seurat_list)) {
    obj <- seurat_list[[name]]
    ref_barcodes <- colnames(obj)
    meta_barcodes <- rownames(obj@meta.data)

    mismatch_info <- list()

    # Check default counts
    assay_counts <- GetAssayData(obj, assay = DefaultAssay(obj), slot = "counts")
    if (!identical(colnames(assay_counts), ref_barcodes)) {
      mismatch_info[["DefaultAssay"]] <- setdiff(ref_barcodes, colnames(assay_counts))
    }

    # Check RawCounts (if exists)
    if ("RawCounts" %in% names(obj@assays)) {
      rc <- GetAssayData(obj[["RawCounts"]], slot = "counts")
      if (!identical(colnames(rc), ref_barcodes)) {
        mismatch_info[["RawCounts"]] <- setdiff(ref_barcodes, colnames(rc))
      }
    }

    # Check RNA@layers colnames
    if ("RNA" %in% names(obj@assays) && "layers" %in% slotNames(obj[["RNA"]])) {
      layers <- obj[["RNA"]]@layers
      for (lname in names(layers)) {
        lmat <- layers[[lname]]
        if (!identical(colnames(lmat), ref_barcodes)) {
          mismatch_info[[paste0("Layer:", lname)]] <- setdiff(ref_barcodes, colnames(lmat))
        }
      }
    }

    # Compare to metadata barcodes
    if (!identical(ref_barcodes, meta_barcodes)) {
      mismatch_info[["MetaMismatch"]] <- setdiff(ref_barcodes, meta_barcodes)
    }

    # Store mismatch info if any
    if (length(mismatch_info) > 0) {
      results[[name]] <- mismatch_info
    }
  }

  return(results)
}

colname_issues <- check_colname_integrity(filtered_list)

if (length(colname_issues) == 0) {
  cat("✅ All barcode names match correctly across metadata and assays.\\n")
} else {
  cat("❌ Mismatches detected:\\n")
  print(colname_issues)
}
')
# -- END: Print the code block --
cat(HTML("</code></pre><hr>"))


# Define and execute
check_colname_integrity <- function(seurat_list) {
  results <- list()
  for (name in names(seurat_list)) {
    obj <- seurat_list[[name]]
    ref_barcodes <- colnames(obj)
    meta_barcodes <- rownames(obj@meta.data)
    mismatch_info <- list()

    assay_counts <- GetAssayData(obj, assay = DefaultAssay(obj), slot = "counts")
    if (!identical(colnames(assay_counts), ref_barcodes)) {
      mismatch_info[["DefaultAssay"]] <- setdiff(ref_barcodes, colnames(assay_counts))
    }

    if ("RawCounts" %in% names(obj@assays)) {
      rc <- GetAssayData(obj[["RawCounts"]], slot = "counts")
      if (!identical(colnames(rc), ref_barcodes)) {
        mismatch_info[["RawCounts"]] <- setdiff(ref_barcodes, colnames(rc))
      }
    }

    if ("RNA" %in% names(obj@assays) && "layers" %in% slotNames(obj[["RNA"]])) {
      layers <- obj[["RNA"]]@layers
      for (lname in names(layers)) {
        lmat <- layers[[lname]]
        if (!identical(colnames(lmat), ref_barcodes)) {
          mismatch_info[[paste0("Layer:", lname)]] <- setdiff(ref_barcodes, colnames(lmat))
        }
      }
    }

    if (!identical(ref_barcodes, meta_barcodes)) {
      mismatch_info[["MetaMismatch"]] <- setdiff(ref_barcodes, meta_barcodes)
    }

    if (length(mismatch_info) > 0) {
      results[[name]] <- mismatch_info
    }
  }
  return(results)
}




# Execute and print output now:
colname_issues <- check_colname_integrity(filtered_list)

if (length(colname_issues) == 0) {
  cat(HTML("<p style='color:green;'><strong>✅ All barcode names match correctly across metadata and assays.</strong></p>"))
} else {
  cat(HTML("<p style='color:red;'><strong>❌ Mismatches detected:</strong></p>"))
  for (name in names(colname_issues)) {
    cat(HTML(sprintf("<details><summary><b>%s</b></summary><ul>", name)))
    for (section in names(colname_issues[[name]])) {
      mismatch <- colname_issues[[name]][[section]]
      cat(HTML(sprintf("<li><b>%s</b>: %d mismatches</li>", section, length(mismatch))))
    }
    cat(HTML("</ul></details>"))
  }
}

cat(HTML("</details>"))






```

## 1.2 Metadata visualization post-barcode QC

```{r metadata, echo=TRUE, results='asis', message=FALSE, warning=FALSE}


#––– Quick check of metadata fields in each post‑QC object –––#


# Table of first 5 rows of metadata for each object
#    We'll stack them with an 'Object' column so you can see them at once.
cat('<details><summary><strong>Preview: First 2 rows of metadata for each object</strong></summary>\n\n')

preview_list <- lapply(names(filtered_list), function(key) {
  md <- filtered_list[[key]]@meta.data
  df <- head(md, 2)
  df$Object <- key
  df[, c("Object", setdiff(colnames(df), "Object"))]
})
preview_df <- do.call(rbind, preview_list)

cat(knitr::kable(
  preview_df,
  format = "html",
  table.attr = "class=\'table table-striped table-bordered\'"
), "\n")

cat('</details>\n')



```

## 1.3 Summary of Barcode QC


```{r inspect_filtered_list, echo=TRUE, results='asis', message=FALSE, warning=FALSE}


library(readxl)
library(knitr)


# 1) Cells retained after barcode QC - Before vs After barcode QC (corrected filenames)
cat("\n**Before vs After Barcode QC:**\n\n")

before_after <- do.call(rbind, lapply(names(filtered_list), function(key) {
  parts     <- strsplit(key, "_", fixed = TRUE)[[1]]
  # reassemble subregion from all but the last element
  mouse_id  <- parts[length(parts)]
  subregion <- paste(parts[-length(parts)], collapse = "_")
  
  excel_path <- file.path(root_path, paste0(mouse_id, "_", subregion, ".xlsx"))
  if (!file.exists(excel_path)) return(NULL)
  
  barcodes <- read_excel(excel_path, col_names = FALSE)[[1]]
  before   <- length(barcodes)
  after    <- ncol(filtered_list[[key]])
  pct      <- round(after / before * 100, 1)
  
  data.frame(
    Object           = key,
    Barcodes_Before  = before,
    Barcodes_After      = after,
    Percent_Retained = pct,
    stringsAsFactors = FALSE
  )
}))

cat(
  kable(
    before_after,
    caption   = "Before vs After Barcode QC",
    col.names = c("Object", "Barcodes Before", "Barcodes After", "% Retained"),
    format    = "html"
  )
)

```


# 2 Merging samples by tissue post-barcode QC


```{r merge, echo=TRUE, results='asis', message=FALSE, warning=FALSE}



# Step 1: Merge by tissue, cache RNA@layers
library(Seurat)
library(Matrix)
library(ggplot2)
library(knitr)
library(kableExtra)
library(htmltools)

merged_by_tissue <- list()
rna_layer_cache  <- list()

cat("🧪 Starting merging process...\n")
cat(sprintf("🔢 Number of objects in filtered_list: %d\n\n", length(filtered_list)))

# Helper to extract sample ID
get_sample_id <- function(x) sub(".*_(\\w+)$", "\\1", x)
grouped_keys <- split(names(filtered_list), sapply(names(filtered_list), get_sample_id))

# Step 1: Merge objects grouped by tissue
for (sample_id in names(grouped_keys)) {
  cat(HTML(sprintf("<details><summary><strong>%s</strong></summary><pre><code>", sample_id)))

  for (key in grouped_keys[[sample_id]]) {
    cat("───────────────\n")
    cat(sprintf("🔍 Key: %s\n", key))

    seurat_obj <- filtered_list[[key]]

    if (is.null(seurat_obj@meta.data$Tissue)) {
      cat("❌ Tissue column missing in metadata. Skipping...\n")
      next
    }

    tissue <- unique(seurat_obj@meta.data$Tissue)
    cat(sprintf("🧬 Tissue extracted: %s\n", paste(tissue, collapse = ", ")))

    if (length(tissue) != 1 || is.na(tissue)) {
      cat("❌ Invalid or multiple tissue values found! Skipping...\n")
      next
    }

    # Cache RNA@layers
    if ("RNA" %in% names(seurat_obj@assays)) {
      assay <- seurat_obj[["RNA"]]
      if ("layers" %in% slotNames(assay)) {
        cat("📦 Caching RNA@layers...\n")
        rna_layer_cache[[key]] <- assay@layers
      } else {
        cat("ℹ️ RNA assay has no layers slot.\n")
      }
    } else {
      cat("❌ RNA assay not found. Skipping...\n")
      next
    }

    # Switch to RawCounts to avoid layer issues
    DefaultAssay(seurat_obj) <- "RawCounts"
    cat("🔧 DefaultAssay set to 'RawCounts'\n")

    # Merge
    if (!tissue %in% names(merged_by_tissue)) {
      cat(sprintf("🆕 Creating new entry for tissue: %s\n", tissue))
      merged_by_tissue[[tissue]] <- seurat_obj
    } else {
      cat(sprintf("➕ Merging into existing tissue object: %s\n", tissue))
      merged_by_tissue[[tissue]] <- merge(
        x = merged_by_tissue[[tissue]],
        y = seurat_obj,
        project = tissue,
        merge.data = FALSE
      )
    }
  }

  cat(HTML("</code></pre></details>\n"))
}

# Step 2: Restore RNA assay and layers
for (tissue in names(merged_by_tissue)) {
  obj <- merged_by_tissue[[tissue]]

  # Restore RNA from RawCounts
  raw_counts <- GetAssayData(obj[["RawCounts"]], slot = "counts")
  rna_assay  <- CreateAssayObject(counts = raw_counts)

  # Merge matching layers
  merged_layers <- list()
  for (key in names(rna_layer_cache)) {
    if (grepl(tissue, key)) {
      for (lname in names(rna_layer_cache[[key]])) {
        layer_mat <- rna_layer_cache[[key]][[lname]]
        if (lname %in% names(merged_layers)) {
          merged_layers[[lname]] <- cbind(merged_layers[[lname]], layer_mat)
        } else {
          merged_layers[[lname]] <- layer_mat
        }
      }
    }
  }

  # Attach and validate layers
  if (length(merged_layers) > 0) {
    rna_assay@layers <- merged_layers

    # ✅ Check colname alignment
    for (lname in names(merged_layers)) {
      if (!identical(colnames(merged_layers[[lname]]), colnames(obj))) {
        warning(sprintf("⚠️ Layer '%s' colnames do not match merged object for tissue %s", lname, tissue))
      }
    }

    message(sprintf("✅ Restored %d RNA layer(s) for tissue: %s", length(merged_layers), tissue))
  } else {
    message(sprintf("⚠️ No RNA layers to restore for tissue: %s", tissue))
  }

  obj[["RNA"]] <- rna_assay
  DefaultAssay(obj) <- "RNA"
  merged_by_tissue[[tissue]] <- obj
}

# Step 3: Summary
merged_summary <- data.frame(
  Tissue = names(merged_by_tissue),
  Barcodes_Total = sapply(merged_by_tissue, ncol),
  stringsAsFactors = FALSE
)

cat("\n**Merged‐by‐Tissue Barcode Counts**\n\n")
cat(kable(
  merged_summary,
  col.names = c("Tissue", "Barcodes Total"),
  format = "html",
  caption = "Number of barcodes in each merged tissue dataset"
))

# Step 4: QC & Metadata summary
for (tissue in names(merged_by_tissue)) {
  obj <- merged_by_tissue[[tissue]]
  md  <- obj@meta.data

  cat(sprintf('<details><summary><strong>%s: QC & Metadata Overview</strong></summary>\n', tissue))

  cat(sprintf('<p><strong>Samples merged:</strong> %s</p>', paste(unique(md$ID), collapse = ", ")))
  cat(sprintf('<p><strong>Total barcodes:</strong> %d</p>', nrow(md)))

  medians <- round(sapply(md[, c("percent.mt", "gene_counts_per_barcode",
                                 "total_counts_per_barcode", "top50_frac")],
                          median, na.rm = TRUE), 1)
  cat('<p><strong>Median QC metrics:</strong></p>')
  cat(kable(
    data.frame(Metric = names(medians), Median = medians),
    format = "html",
    table.attr = "class='table table-bordered'"
  ))

  # Histograms
  p1 <- ggplot(md, aes(x = percent.mt)) +
    geom_histogram(bins = 50) +
    ggtitle(paste0(tissue, ": % Mito")) + theme_minimal()
  p2 <- ggplot(md, aes(x = gene_counts_per_barcode)) +
    geom_histogram(bins = 50) +
    ggtitle(paste0(tissue, ": Genes per barcode")) + theme_minimal()
  p3 <- ggplot(md, aes(x = total_counts_per_barcode)) +
    geom_histogram(bins = 50) +
    ggtitle(paste0(tissue, ": UMIs per barcode")) + theme_minimal()

  print(p1); print(p2); print(p3)

  # Top 10 genes
  DefaultAssay(obj) <- "RawCounts"
  mat <- GetAssayData(obj, slot = "counts")
  top10 <- sort(rowMeans(mat), decreasing = TRUE)[1:10]
  cat('<p><strong>Top 10 genes by mean raw count:</strong></p>')
  cat(kable(
    data.frame(Gene = names(top10), Mean = round(as.numeric(top10), 2)),
    format = "html",
    table.attr = "class='table table-striped table-bordered'"
  ))

  # Metadata preview
  annot_cols <- c("Batch", "Injury", "Age", "Sex")
  preview <- md[, intersect(annot_cols, colnames(md)), drop = FALSE]
  if (ncol(preview) > 0) {
    preview <- rbind(head(preview, 2), tail(preview, 2))
    cat('<p><strong>Sample annotations (first 2 & last 2 barcodes):</strong></p>')
    cat(kable(
      preview,
      format = "html",
      table.attr = "class='table table-bordered'"
    ))
  } else {
    cat("*No Batch/Injury/Age/Sex columns found in metadata.*")
  }

  cat("</details>\n\n")
}

```



## 2.1 Checking post-barcode QC Seurat object after merging samples by tissue to allow future SCTransform Normalization 


```{r mergeCheck, echo=TRUE, results='asis', message=FALSE, warning=FALSE}


inspect_seurat_object_full_html(merged_by_tissue, list_name = "merged_by_tissue")




for (obj_name in names(merged_by_tissue)) {
  obj <- merged_by_tissue[[obj_name]]
  
  cat(sprintf("\n🔍 Inspecting object: %s\n", obj_name))
  
  if (!("RNA" %in% names(obj@assays))) {
    cat("❌ RNA assay not found\n")
    next
  }

  assay <- obj[["RNA"]]

  # Inspect top-level counts slot
  cat("🔎 Checking counts slot...\n")
  tryCatch({
    counts_mat <- GetAssayData(assay, slot = "counts", layer = NULL)
    cat(sprintf("✅ counts slot: %d genes × %d barcodes\n", nrow(counts_mat), ncol(counts_mat)))
  }, error = function(e) {
    cat("❌ Error accessing counts slot:\n")
    message(e$message)
  })

  # Inspect each layer
  if ("layers" %in% slotNames(assay)) {
    cat("🔎 Checking layers...\n")
    for (lname in names(assay@layers)) {
      cat(sprintf("  - Layer: %s ... ", lname))
      tryCatch({
        layer_mat <- assay@layers[[lname]]
        dims <- dim(layer_mat)
        colnames_check <- !is.null(colnames(layer_mat))
        cat(sprintf("✅ OK (%d × %d) | Has colnames: %s\n", dims[1], dims[2], colnames_check))
      }, error = function(e) {
        cat("❌ Error:\n")
        message(e$message)
      })
    }
  } else {
    cat("ℹ️ No layers slot found in assay.\n")
  }
}




### 1.2.1 Checking merged Seurat objects to confirm SCTransform readiness


# Define function to inspect assays and layers in merged Seurat objects
check_layer_colnames_html <- function(seurat_list, assay_name = "RNA") {
  all_results <- data.frame(
    Object = character(),
    Assay_Layer = character(),
    n_cols = integer(),
    has_colnames = logical(),
    stringsAsFactors = FALSE
  )
  
  for (obj_name in names(seurat_list)) {
    obj <- seurat_list[[obj_name]]
    obj_results <- data.frame()

    # RawCounts
    if ("RawCounts" %in% names(obj@assays)) {
      rc_mat <- GetAssayData(obj[["RawCounts"]], slot = "counts")
      obj_results <- rbind(obj_results, data.frame(
        Object = obj_name,
        Assay_Layer = "RawCounts",
        n_cols = ncol(rc_mat),
        has_colnames = !is.null(colnames(rc_mat))
      ))
    }

    if (assay_name %in% names(obj@assays)) {
      assay <- obj[[assay_name]]
      
      # Try top-level counts
      rna_mat <- tryCatch(GetAssayData(assay, slot = "counts", layer = NULL), error = function(e) NULL)
      if (!is.null(rna_mat)) {
        obj_results <- rbind(obj_results, data.frame(
          Object = obj_name,
          Assay_Layer = "counts",
          n_cols = ncol(rna_mat),
          has_colnames = !is.null(colnames(rna_mat))
        ))
      } else {
        obj_results <- rbind(obj_results, data.frame(
          Object = obj_name,
          Assay_Layer = "counts",
          n_cols = NA,
          has_colnames = FALSE
        ))
      }

      # Check all layers
      if ("layers" %in% slotNames(assay)) {
        for (lname in names(assay@layers)) {
          layer_mat <- assay@layers[[lname]]
          if (!is.null(layer_mat)) {
            obj_results <- rbind(obj_results, data.frame(
              Object = obj_name,
              Assay_Layer = paste0("layer_", lname),
              n_cols = ncol(layer_mat),
              has_colnames = !is.null(colnames(layer_mat))
            ))
          }
        }
      }
    }

    all_results <- rbind(all_results, obj_results)
    
    # HTML output
    cat(HTML(sprintf("<details><summary><strong>%s</strong></summary>", obj_name)))
    cat(kable(obj_results[, -1], format = "html", table.attr = "class='table table-bordered table-sm'"))
    cat(HTML("</details>\n"))
  }

  return(all_results)
}


# ✅ Call the function on your merged object list
layer_colname_status <- check_layer_colnames_html(merged_by_tissue)






# Manual inspection of RNA assay and its layers for each merged object
for (obj_name in names(merged_by_tissue)) {
  obj <- merged_by_tissue[[obj_name]]
  
  cat(sprintf("\n🔍 Inspecting object: %s\n", obj_name))
  
  if (!("RNA" %in% names(obj@assays))) {
    cat("❌ RNA assay not found\n")
    next
  }

  assay <- obj[["RNA"]]

  # Inspect top-level counts slot
  cat("🔎 Checking counts slot...\n")
  tryCatch({
    counts_mat <- GetAssayData(assay, slot = "counts", layer = NULL)
    cat(sprintf("✅ counts slot: %d genes × %d cells\n", nrow(counts_mat), ncol(counts_mat)))
    cat(sprintf("   - Has colnames: %s\n", !is.null(colnames(counts_mat))))
  }, error = function(e) {
    cat("❌ Error accessing counts slot:\n")
    message(e$message)
  })

  # Inspect each layer
  if ("layers" %in% slotNames(assay)) {
    cat("🔎 Checking layers...\n")
    for (lname in names(assay@layers)) {
      cat(sprintf("  - Layer: %s ... ", lname))
      tryCatch({
        layer_mat <- assay@layers[[lname]]
        dims <- dim(layer_mat)
        colnames_check <- !is.null(colnames(layer_mat))
        cat(sprintf("✅ OK (%d × %d) | Has colnames: %s\n", dims[1], dims[2], colnames_check))
      }, error = function(e) {
        cat("❌ Error:\n")
        message(e$message)
      })
    }
  } else {
    cat("ℹ️ No layers slot found in assay.\n")
  }
}


```


✅ Here's what you've preserved and validated:

Component	                  Preserved?	Validated?	Notes
Raw UMI counts	                  ✅ Yes	✅ Yes	    In "RawCounts" assay; untouched from original filtered object
RNA assay counts slot           	✅ Yes	✅ Yes	    Re-populated after merging; used for SCTransform
Layers (RNA@layers)	              ❌ No	✅ Checked	Not preserved in merge (expected), but not required for SCTransform
Colnames (barcodes)             	✅ Yes	✅ Yes   	Verified colname consistency across metadata, RawCounts, RNA
Metadata columns                	✅ Yes	✅ Yes	    All Tissue, Run, Age, Injury, etc. preserved and printed
Barcode QC filter ing           	✅ Yes	✅ Yes	    You filtered before merge, and barcode retention was summarized
Gene-level filtering          	🔜 Optional	–	      Can be done before SCTransform, if desired
Sample identities               	✅ Yes	✅ Yes	    You preserved ID, Tissue, and other annotations in metadata

We do not keep layers after merging as we do not match the file names with the tissue (grepl function using _) so the code removes the layers, which is great since they add too much complexity and the statistics work using just the assay = RawCounts used by default when layers are removed:

Why did  original code "say" SubchondralFemur had 0 layers?
Because the string "SubchondralFemur" does not match "Subchondral_Femur_Young1" in a grepl() search — the underscore _ breaks the match -> Layers Weren’t Restored because:

The rna_layer_cache matching failed (e.g. "Subchondral_Femur" ≠ "SubchondralFemur")

So this conditional:

if (length(merged_layers) > 0) {
  rna_assay@layers <- merged_layers
}

was never triggered

And the created rna_assay is just an Assay, not an Assay5 — so it has no @layers slot at all







# 3 Gene QC

## 3.1 Gene analysis of barcode-filtered tissue-merged samples

```{r geneQC, echo=TRUE, results='asis', message=FALSE, warning=FALSE}

#––– Gene‐Level QC: Mean vs Detection % per tissue –––#
# Pre‐condition: you have `merged_by_tissue`, each with a "RawCounts" assay.

gene_qc_summary <- list()

for (tissue in names(merged_by_tissue)) {
  obj <- merged_by_tissue[[tissue]]
  
  # 1) Switch to truly raw counts
  DefaultAssay(obj) <- "RawCounts"
  counts_mat <- GetAssayData(obj, slot = "counts")
  
  # 2) Compute per‐gene metrics
  gene_means      <- rowMeans(counts_mat)
  gene_detect_pct <- rowSums(counts_mat > 0) / ncol(counts_mat) * 100
  
  # 3) Decide cutoffs (100th percentile & 1% detection, for example)
  mean_cutoff   <- quantile(gene_means, 0.001)
  detect_cutoff <- 0.1
  
  df <- data.frame(Mean = gene_means, DetectPct = gene_detect_pct)
  
  # 4) Plot histograms + scatter
  p1 <- ggplot(df, aes(x = Mean)) +
    geom_histogram(bins = 50) +
    geom_vline(xintercept = mean_cutoff, linetype = "dashed") +
    ggtitle(paste0(tissue, ": Mean UMI per Gene")) +
    xlab("Mean raw UMI count") + ylab("Number of Genes") +
    theme_minimal()
  
  p2 <- ggplot(df, aes(x = DetectPct)) +
    geom_histogram(bins = 50) +
    geom_vline(xintercept = detect_cutoff, linetype = "dashed") +
    ggtitle(paste0(tissue, ": Detection % per Gene")) +
    xlab("% detected barcodes") + ylab("Number of Genes") +
    theme_minimal()
  
  p3 <- ggplot(df, aes(x = Mean, y = DetectPct)) +
    geom_point(alpha = 0.2, size = 0.5) +
    geom_vline(xintercept = mean_cutoff, linetype = "dashed") +
    geom_hline(yintercept = detect_cutoff, linetype = "dashed") +
    ggtitle(paste0(tissue, ": Mean vs Detection %")) +
    xlab("Mean raw UMI count") + ylab("Percent of barcodes detected") +
    theme_minimal()
  
  # 5) Record summary of kept vs dropped
  keep <- (gene_means >= mean_cutoff) & (gene_detect_pct >= detect_cutoff)
  gene_qc_summary[[tissue]] <- data.frame(
    Tissue        = tissue,
    Total_Genes   = length(gene_means),
    Mean_Cutoff   = round(mean_cutoff,   4),
    Detect_Cutoff = detect_cutoff,
    Genes_Kept    = sum(keep),
    Genes_Dropped = sum(!keep),
    stringsAsFactors = FALSE
  )
}

# 6) Prepare summary table
gene_qc_df <- do.call(rbind, gene_qc_summary)



# Wrap *all* outputs in one collapsible:
cat('<details><summary><strong>Gene‐Level QC: Distributions & Summary by Tissue</strong></summary>\n\n')

for (tissue in names(merged_by_tissue)) {
  obj <- merged_by_tissue[[tissue]]
  DefaultAssay(obj) <- "RawCounts"
  mat <- GetAssayData(obj, slot = "counts")
  
  gene_means      <- rowMeans(mat)
  gene_detect_pct <- rowSums(mat > 0) / ncol(mat) * 100
  
  mean_cutoff   <- quantile(gene_means, 0.001)
  detect_cutoff <- 0.1
  keep          <- (gene_means >= mean_cutoff) & (gene_detect_pct >= detect_cutoff)
  
  df <- data.frame(Mean = gene_means, DetectPct = gene_detect_pct)
  
  # Open per‐tissue collapsible
  cat(sprintf('<details><summary><strong>%s</strong></summary>\n\n', tissue))
  
  # Plots
  p1 <- ggplot(df, aes(Mean)) +
    geom_histogram(bins=50) +
    geom_vline(xintercept=mean_cutoff, linetype="dashed") +
    ggtitle("Mean UMI per Gene") + theme_minimal()
  p2 <- ggplot(df, aes(DetectPct)) +
    geom_histogram(bins=50) +
    geom_vline(xintercept=detect_cutoff, linetype="dashed") +
    ggtitle("Detection % per Gene") + theme_minimal()
  p3 <- ggplot(df, aes(Mean, DetectPct)) +
    geom_point(alpha=0.2, size=0.5) +
    geom_vline(xintercept=mean_cutoff, linetype="dashed") +
    geom_hline(yintercept=detect_cutoff, linetype="dashed") +
    ggtitle("Mean vs Detection %") + theme_minimal()
  print(p1); print(p2); print(p3)
  
  # Summary table
  summary_df <- data.frame(
    Tissue        = tissue,
    Total_Genes   = length(gene_means),
    Mean_Cutoff   = formatC(mean_cutoff, format = "f", digits = 4),
    Detect_Cutoff = formatC(detect_cutoff, format = "f", digits = 4),
    Genes_Kept    = sum(keep),
    Genes_Dropped = sum(!keep),
    stringsAsFactors = FALSE
  )
  cat(kable(
    summary_df,
    format     = "html",
    table.attr = "class='table table-bordered'",
    caption    = "Gene‐QC summary"
  ), "\n")
  
  # Top 20 genes
  kept_means     <- sort(gene_means[keep], decreasing = TRUE)
  top20_genes    <- head(names(kept_means), 20)
  top20_means    <- kept_means[top20_genes]
  top20_coverage <- gene_detect_pct[top20_genes]

  cat('<p><strong>Top 20 genes by mean raw count (with coverage):</strong></p>\n')
  cat(kable(
    data.frame(
      Gene     = top20_genes,
      Mean     = round(as.numeric(top20_means),   3),
      Coverage = round(as.numeric(top20_coverage), 1)
    ),
    format     = "html",
    table.attr = "class='table table-striped table-bordered'",
    caption    = "Top 20 kept genes: Mean & Coverage (%)"
  ), "\n")
  
  cat('</details>\n\n')
}

cat('</details>\n')


```


### 3.1.1 Post-Gene QC Layer Check (before SCTransform)

```{r postGeneQC_check, results='asis', echo=TRUE, message=FALSE, warning=FALSE}



# Check for NULL layers and broken layer_counts before cleanup

any_issues_found <- FALSE

for (tissue in names(merged_by_tissue)) {
  obj <- merged_by_tissue[[tissue]]
  
  if (!("RNA" %in% names(obj@assays))) next
  assay_obj <- obj[["RNA"]]
  
  if ("layers" %in% slotNames(assay_obj)) {
    null_layers <- names(assay_obj@layers)[sapply(assay_obj@layers, is.null)]
    
    if (length(null_layers) > 0) {
      any_issues_found <- TRUE
      cat(sprintf("⚠️ %s: Found NULL layers → %s\n", tissue, paste(null_layers, collapse = ", ")))
    }
    
    if ("layer_counts" %in% names(assay_obj@layers)) {
      mat <- assay_obj@layers[["layer_counts"]]
      if (is.null(colnames(mat))) {
        any_issues_found <- TRUE
        cat(sprintf("❌ %s: 'layer_counts' exists but has no colnames\n", tissue))
      } else {
        cat(sprintf("✅ %s: 'layer_counts' has valid colnames\n", tissue))
      }
    }
  } else {
    cat(sprintf("ℹ️ %s: RNA assay has no layers slot\n", tissue))
  }
}

if (!any_issues_found) {
  cat("✅ All assays are clean: No NULL layers and all 'layer_counts' have colnames.\n")
}




# Prune NULL layers once
for (tissue in names(merged_by_tissue)) {
  obj <- merged_by_tissue[[tissue]]
  if ("RNA" %in% names(obj@assays)) {
    assay_obj <- obj[["RNA"]]
    if ("layers" %in% slotNames(assay_obj)) {
      assay_obj@layers <- Filter(Negate(is.null), assay_obj@layers)
      obj[["RNA"]] <- assay_obj
      merged_by_tissue[[tissue]] <- obj
      message(sprintf("✅ Pruned NULL layers from RNA assay in %s", tissue))
    }
  }
}

# Final manual cleanup of any invalid 'layer_counts' (just to be 100% sure)
for (tissue in names(merged_by_tissue)) {
  obj <- merged_by_tissue[[tissue]]
  if ("RNA" %in% names(obj@assays)) {
    assay_obj <- obj[["RNA"]]
    if ("layers" %in% slotNames(assay_obj)) {
      if ("layer_counts" %in% names(assay_obj@layers)) {
        mat <- assay_obj@layers[["layer_counts"]]
        if (is.null(colnames(mat))) {
          assay_obj@layers[["layer_counts"]] <- NULL
          obj[["RNA"]] <- assay_obj
          merged_by_tissue[[tissue]] <- obj
          message(sprintf("🧹 Final cleanup: removed colnameless 'layer_counts' in %s", tissue))
        }
      }
    }
  }
}


# ✅ Single final definition of check_layer_colnames_html function
check_layer_summary_html <- function(seurat_list, assay_name = "RNA") {
  all_results <- data.frame(
    Object = character(),
    Assay_Layer = character(),
    n_cols = integer(),
    has_colnames = logical(),
    stringsAsFactors = FALSE
  )
  
  layer_counts_summary <- data.frame(
    Object = character(),
    Valid_Layers = integer(),
    stringsAsFactors = FALSE
  )

  for (obj_name in names(seurat_list)) {
    obj <- seurat_list[[obj_name]]
    obj_results <- data.frame(
      Object = character(),
      Assay_Layer = character(),
      n_cols = integer(),
      has_colnames = logical(),
      stringsAsFactors = FALSE
    )

    valid_layer_count <- 0

    # RawCounts
    if ("RawCounts" %in% names(obj@assays)) {
      raw_mat <- GetAssayData(obj[["RawCounts"]], slot = "counts", layer = NULL)
      obj_results <- rbind(obj_results, data.frame(
        Object = obj_name,
        Assay_Layer = "RawCounts",
        n_cols = ncol(raw_mat),
        has_colnames = !is.null(colnames(raw_mat))
      ))
    }

    # RNA assay
    if (assay_name %in% names(obj@assays)) {
      assay <- obj[[assay_name]]
      rna_mat <- GetAssayData(assay, slot = "counts", layer = NULL)
      obj_results <- rbind(obj_results, data.frame(
        Object = obj_name,
        Assay_Layer = "counts",
        n_cols = ncol(rna_mat),
        has_colnames = !is.null(colnames(rna_mat))
      ))

      # Check layers
      if ("layers" %in% slotNames(assay)) {
        for (lname in names(assay@layers)) {
          layer_mat <- assay@layers[[lname]]
          if (!is.null(layer_mat) && !is.null(colnames(layer_mat))) {
            valid_layer_count <- valid_layer_count + 1
            obj_results <- rbind(obj_results, data.frame(
              Object = obj_name,
              Assay_Layer = paste0("layer_", lname),
              n_cols = ncol(layer_mat),
              has_colnames = TRUE
            ))
          }
        }
      }
    }

    layer_counts_summary <- rbind(layer_counts_summary, data.frame(
      Object = obj_name,
      Valid_Layers = valid_layer_count
    ))

    all_results <- rbind(all_results, obj_results)

    # HTML output
    cat(HTML(sprintf("<details><summary><strong>%s</strong></summary>", obj_name)))
    cat(kable(obj_results[, -1], format = "html", table.attr = "class='table table-bordered table-sm'"))
    cat(HTML("</details>\n"))
  }

  return(list(
    assay_layer_table = all_results,
    layer_count_table = layer_counts_summary
  ))
}

# Run the final check once
merged_layer_colname_status <- check_layer_colnames_html(merged_by_tissue)





# UMI counts in the merged data ready for SCTransform

for (tissue in names(merged_by_tissue)) {
  obj <- merged_by_tissue[[tissue]]
  
  raw_counts <- GetAssayData(obj[["RawCounts"]], slot = "counts")
  rna_counts <- GetAssayData(obj[["RNA"]], slot = "counts")
  
  identical_result <- identical(raw_counts, rna_counts)
  cat(sprintf("🔍 %s: RNA@counts matches RawCounts@counts → %s\n", tissue, identical_result))
}



```

## 3.2 Gene QC Filtering

As discussed previously for in the Merging section, layers are gone due to the mismatch in file name vs. tissue name, which is good to ease calculations, the rest is still kept as it should thanks to all the checks that are made within this pipeline:

Check/Step	                              Observation	Correct                    Behavior?
After merge: SubchondralFemur	            No @layers slot	                      ✅ Expected
Pre-merge: individual samples had layers	Yes (layer_counts etc.)	              ✅ Expected
RNA@counts matches RawCounts	            Yes (confirmed via identical())	      ✅ Expected
Layer QC (e.g., NULL layer checks)	      Skipped because @layers didn't exist	✅ Expected


```{r geneFiltering, echo=TRUE, results='asis', message=FALSE, warning=FALSE}


# Define candidate thresholds
mean_thresholds  <- c(0.0001, 0.001, 0.01)     # mean UMI cutoffs
detect_thresholds <- c(0.01, 0.05, 0.5, 1)          # detection % cutoffs

for (tissue in names(merged_by_tissue)) {
  obj <- merged_by_tissue[[tissue]]
  DefaultAssay(obj) <- "RawCounts"
  mat <- GetAssayData(obj, slot = "counts")
  
  gene_means      <- rowMeans(mat)
  gene_detect_pct <- rowSums(mat > 0) / ncol(mat) * 100
  total_genes     <- length(gene_means)
  
  # Build a data.frame of failure counts
  df_mean <- data.frame(
    Threshold = paste0("Mean ≥ ", mean_thresholds),
    Fail_Count = sapply(mean_thresholds, function(th) sum(gene_means < th)),
    stringsAsFactors = FALSE
  )
  df_mean$Fail_Pct <- round(df_mean$Fail_Count / total_genes * 100, 1)
  
  df_detect <- data.frame(
    Threshold = paste0("Detect% ≥ ", detect_thresholds, "%"),
    Fail_Count = sapply(detect_thresholds, function(th) sum(gene_detect_pct < th)),
    stringsAsFactors = FALSE
  )
  df_detect$Fail_Pct <- round(df_detect$Fail_Count / total_genes * 100, 1)
  
  df_both <- rbind(
    data.frame(Method="Mean cutoff", df_mean, stringsAsFactors=FALSE),
    data.frame(Method="Detection% cutoff", df_detect, stringsAsFactors=FALSE)
  )
  
cat(sprintf("
<details>
  <summary><strong>%s: Gene Failure Rates at Candidate Thresholds</strong></summary>

", tissue))

cat(kable(
  df_both,
  col.names = c("Method","Threshold","Genes Failing","% Failing"),
  format    = "html",
  table.attr= "class='table table-striped table-bordered'"
))

cat("</details>\n\n")

}





# 7) Create truly gene‑filtered objects

gene_filtered_list <- list()

for (tissue in names(merged_by_tissue)) {
  obj <- merged_by_tissue[[tissue]]
  DefaultAssay(obj) <- "RawCounts"
  raw_counts <- GetAssayData(obj, slot = "counts")

  # Compute filtering mask
  gene_means      <- rowMeans(raw_counts)
  gene_detect_pct <- rowSums(raw_counts > 0) / ncol(raw_counts) * 100
  mean_cutoff     <- quantile(gene_means, 0.001)
  detect_cutoff   <- 0.1
  keep            <- (gene_means >= mean_cutoff) & (gene_detect_pct >= detect_cutoff)
  genes_to_keep   <- names(which(keep))

  # Subset the Seurat object — this removes genes from all assays
  filtered_obj <- subset(obj, features = genes_to_keep)

  # [Important] Reconstruct RNA assay if needed
  if ("RNA" %in% names(filtered_obj@assays)) {
    # Optional: if RNA is broken or lost, recreate it from RawCounts
    DefaultAssay(filtered_obj) <- "RawCounts"
    raw_mat <- GetAssayData(filtered_obj, slot = "counts")
    filtered_obj[["RNA"]] <- CreateAssayObject(counts = raw_mat)
  }

  gene_filtered_list[[tissue]] <- filtered_obj
}




# 8) Inspect metadata on gene‑filtered objects
cat('<details><summary><strong>Inspect Gene‐Filtered Metadata per Tissue</strong></summary>\n\n')
for (tissue in names(gene_filtered_list)) {
  gf <- gene_filtered_list[[tissue]]
  md <- gf@meta.data
  cat(sprintf('**%s** (%d barcodes × %d genes):\n\n',
              tissue, ncol(gf), nrow(md)))
  
  annot_cols <- intersect(c("Batch","Injury","Age","Sex"), colnames(md))
  if (length(annot_cols)==0) {
    cat("*No Batch/Injury/Age/Sex columns found.*\n\n")
  } else {
    preview <- rbind(
      head(md[, annot_cols, drop=FALSE], 2),
      tail(md[, annot_cols, drop=FALSE], 2)
    )
    cat(kable(
      preview,
      format     = "html",
      table.attr = "class='table table-bordered'",
      caption    = paste0(tissue, ": Batch/Injury/Age/Sex (first/last 2 barcodes)")
    ), "\n\n")
  }
}
cat('</details>\n')

# 9) (Optional) Export gene‑filtered counts & metadata
out_dir <- file.path(root_path, "filtered_datasets")
if (!dir.exists(out_dir)) dir.create(out_dir, recursive = TRUE)
for (tissue in names(gene_filtered_list)) {
  gf <- gene_filtered_list[[tissue]]
  DefaultAssay(gf) <- "RawCounts"
  mat <- GetAssayData(gf, slot = "counts")
  write.csv(as.data.frame(as.matrix(mat)),
            file.path(out_dir, paste0(tissue, "_counts.csv")),
            row.names = TRUE)
  write.csv(gf@meta.data,
            file.path(out_dir, paste0(tissue, "_metadata.csv")),
            row.names = TRUE)
}




```


### 3.2.1 Gene Filtering Seurat Object Check for SCTransform use


```{r geneFilteringCheck, echo=TRUE, results='asis', message=FALSE, warning=FALSE}


### 1 Post-Gene Filtering: Assay/Layer Structure Check

# Ensure no NULL or broken layers remain in gene_filtered_list
for (tissue in names(gene_filtered_list)) {
  obj <- gene_filtered_list[[tissue]]
  if ("RNA" %in% names(obj@assays)) {
    assay_obj <- obj[["RNA"]]
    
    if ("layers" %in% slotNames(assay_obj)) {
      # Prune NULL or colnameless layers
      new_layers <- Filter(function(x) !is.null(x) && !is.null(colnames(x)), assay_obj@layers)
      assay_obj@layers <- new_layers
      
      # Set @default slot safely (must be integer)
      if (length(new_layers) == 0) {
        assay_obj@default <- as.integer(0)
      } else {
        assay_obj@default <- as.integer(1)
      }
      
      obj[["RNA"]] <- assay_obj
      gene_filtered_list[[tissue]] <- obj
      
      message(sprintf("✅ Cleaned layers and fixed @default in RNA assay of %s", tissue))
    }
  }
}


# Layer + colname check
cat("\n<details><summary><strong>Post-Gene Filtering: Assay/Layer Summary</strong></summary>\n\n")

check_layer_summary_html(gene_filtered_list)


cat("\n</details>\n")



# Barcode match integrity check (optional)
cat("\n<details><summary><strong>Barcode Consistency Check (Post-Gene Filtering)</strong></summary>\n\n")
for (tissue in names(gene_filtered_list)) {
  obj <- gene_filtered_list[[tissue]]
  meta_barcodes <- rownames(obj@meta.data)
  counts_barcodes <- colnames(GetAssayData(obj, slot = "counts"))
  match <- identical(meta_barcodes, counts_barcodes)
  cat(sprintf("- %s: %s\n", tissue, if (match) "✅ Barcodes match" else "❌ Mismatch!"))
}
cat("\n</details>\n")

```


## 3.3 Summary of Gene QC

```{r SummarygeneQC, echo=TRUE, results='asis', message=FALSE, warning=FALSE}


# 1) Dimensions table
dim_df <- do.call(rbind, lapply(names(gene_filtered_list), function(t) {
  obj <- gene_filtered_list[[t]]
  data.frame(
    Tissue        = t,
    Genes_Filtered= nrow(GetAssayData(obj, slot="counts")),
    Cells_Filtered= ncol(obj),
    stringsAsFactors = FALSE
  )
}))
cat("**Gene‑Filtered Object Dimensions**\n\n")
cat(kable(
  dim_df,
  col.names = c("Tissue","# Genes","# Barcodes"),
  format    = "html",
  table.attr= "class='table table-striped table-bordered'"
), "\n\n")


# 2) Metadata columns table
meta_cols_df <- do.call(rbind, lapply(names(gene_filtered_list), function(t) {
  cols <- colnames(gene_filtered_list[[t]]@meta.data)
  data.frame(
    Tissue = t,
    Metadata_Columns = paste(cols, collapse = ", "),
    stringsAsFactors = FALSE
  )
}))
cat("**Gene‑Filtered Metadata Columns**\n\n")
cat(kable(
  meta_cols_df,
  col.names = c("Tissue","Metadata Columns"),
  format    = "html",
  table.attr= "class='table table-striped table-bordered'"
), "\n")

```




# 4. Downstream Analyses with Pseudobulking


```{r PseudobulkPreprocessing, echo=TRUE, results='asis', message=FALSE, warning=FALSE}



# Define lookup names for group encodings
group_names <- c(
  "0_0_0" = "Male_Young_Naive",
  "0_0_2" = "Male_Young_Sham",
  "0_0_3" = "Male_Young_DMM",
  "0_1_0" = "Male_Aged_Naive",
  "0_1_2" = "Male_Aged_Sham",
  "0_1_3" = "Male_Aged_DMM",
  "1_0_0" = "Female_Young_Naive",
  "1_0_3" = "Female_Young_DMM"
)

# Initialize empty list to collect per-tissue data
group_counts_table <- list()



pseudobulk_counts_raw_list <- list()  # ← New list to store raw counts

pseudobulk_counts_list <- list()
pseudobulk_meta_list <- list()
gene_filter_log <- list()  # ← new list to store log info



# Loop through tissues to collect counts
for (tissue in names(gene_filtered_list)) {
  meta <- gene_filtered_list[[tissue]]@meta.data
  meta$Group <- paste(meta$Sex, meta$Age, meta$Injury, sep = "_")
  
  # Explicitly set factor levels for metadata (can disable if needed)
  meta$Sex <- factor(meta$Sex, levels = c(0, 1))  # 0 = Male, 1 = Female
  meta$Age <- factor(meta$Age, levels = c(0, 1))  # 0 = Young, 1 = Aged
  meta$Injury <- factor(meta$Injury, levels = c(0, 2, 3))  # 0 = Naive, 2 = Sham, 3 = DMM
  
  # Count cells per group
  counts <- table(meta$Group)
  
  # Add group name (e.g., Male_Young_Naive) + encoded (e.g., (0_0_0))
  named_groups <- sapply(names(counts), function(g) {
    label <- group_names[[g]]
    if (is.null(label)) {
      paste0("Unknown (", g, ")")
    } else {
      paste0(label, " (", g, ")")
    }
  })
  
  df <- data.frame(
    Group = named_groups,
    Barcode_Count = as.vector(counts),
    stringsAsFactors = FALSE
  )
  
  group_counts_table[[tissue]] <- df
}

for (tissue in names(group_counts_table)) {
  cat(sprintf("<details><summary><strong>%s</strong></summary>\n\n", tissue))
  print(kable(group_counts_table[[tissue]], format = "html", table.attr = "class='table table-condensed'"))
  cat("</details>\n\n")
}






# Loop over tissues to get Group vs SampleID tables
for (tissue in names(gene_filtered_list)) {
  meta <- gene_filtered_list[[tissue]]@meta.data
  meta$Group <- paste(meta$Sex, meta$Age, meta$Injury, sep = "_")
  
  # Create lookup for Sample ID → Group name (readable)
  sample_group_map <- unique(meta[, c("ID", "Group")])
  sample_group_map$PrettyGroup <- sapply(sample_group_map$Group, function(g) {
    label <- group_names[[g]]
    if (is.null(label)) paste0("Unknown (", g, ")") else paste0(label, " (", g, ")")
  })
  sample_label_lookup <- setNames(paste0(sample_group_map$ID, " [", sample_group_map$PrettyGroup, "]"),
                                  sample_group_map$ID)

  # Build table
  tab <- table(meta$Group, meta$ID)
  df <- as.data.frame.matrix(tab)
  df$Group <- rownames(df)

  # Update row names to include readable group label
  df$Group <- sapply(df$Group, function(g) {
    label <- group_names[[g]]
    if (is.null(label)) paste0("Unknown (", g, ")") else paste0(label, " (", g, ")")
  })

  # Rename columns using SampleID + readable group
  colnames(df) <- ifelse(colnames(df) %in% names(sample_label_lookup),
                         sample_label_lookup[colnames(df)],
                         colnames(df))

  df <- df[, c("Group", setdiff(names(df), "Group"))]

  # Display as collapsible
  cat(sprintf("<details><summary><strong>%s: Barcode Count per Sample ID</strong></summary>\n\n", tissue))
  print(knitr::kable(df, format = "html", table.attr = "class='table table-condensed table-bordered'"))
  cat("</details>\n\n")
}







cat("<hr><h2>Number of Expressed Genes per Pseudobulk Sample (Unfiltered Counts)</h2>\n")

for (tissue in names(gene_filtered_list)) {
  meta <- gene_filtered_list[[tissue]]@meta.data
  meta$Group <- paste(meta$Sex, meta$Age, meta$Injury, sep = "_")

  # Build lookup for ID → group
  sample_group_map <- unique(meta[, c("ID", "Group")])
  sample_group_map$PrettyGroup <- sapply(sample_group_map$Group, function(g) {
    label <- group_names[[g]]
    if (is.null(label)) paste0("Unknown (", g, ")") else paste0(label, " (", g, ")")
  })
  sample_label_lookup <- setNames(paste0(sample_group_map$ID, " [", sample_group_map$PrettyGroup, "]"),
                                  sample_group_map$ID)

  # Use raw (unfiltered) pseudobulk counts
  pb <- pseudobulk_counts_raw_list[[tissue]]
  if (is.null(pb)) next

  # Count nonzero genes per sample
  gene_counts <- apply(pb, 2, function(x) sum(x > 0))
  df <- data.frame(SampleID = names(gene_counts), NonzeroGenes = gene_counts)
  df$Group <- sample_group_map$Group[match(df$SampleID, sample_group_map$ID)]
  df$PrettyGroup <- sapply(df$Group, function(g) {
    label <- group_names[[g]]
    if (is.null(label)) paste0("Unknown (", g, ")") else paste0(label, " (", g, ")")
  })

  df$SampleLabel <- paste0(df$SampleID, " [", df$PrettyGroup, "]")
  df <- df[, c("SampleLabel", "NonzeroGenes")]

  # Transpose to wide table (optional)
  wide_df <- t(df$NonzeroGenes)
  colnames(wide_df) <- df$SampleLabel
  wide_df <- as.data.frame(wide_df)
  wide_df$Group <- unique(df$PrettyGroup)

  cat(sprintf("<details><summary><strong>%s: Nonzero Gene Count per Sample</strong></summary>\n\n", tissue))
  print(knitr::kable(wide_df, format = "html", table.attr = "class='table table-condensed table-bordered'"))
  cat("</details>\n\n")
}







# Loop and format table for each tissue
for (tissue in names(gene_filtered_list)) {
  meta <- gene_filtered_list[[tissue]]@meta.data
  meta$Group <- paste(meta$Sex, meta$Age, meta$Injury, sep = "_")
  
  # Count distinct sample IDs per group
  group_id_counts <- table(meta$Group, meta$ID)
  group_counts <- rowSums(group_id_counts > 0)
  
  # Format as data frame
  df <- data.frame(
    Group = names(group_counts),
    Sample_Count = as.vector(group_counts),
    stringsAsFactors = FALSE
  )
  
  # Add readable group names
  df$Group <- sapply(df$Group, function(g) {
    label <- group_names[[g]]
    if (is.null(label)) paste0("Unknown (", g, ")") else paste0(label, " (", g, ")")
  })
  
  # Output in collapsible table
  cat(sprintf("<details><summary><strong>%s: Sample Count per Group</strong></summary>\n\n", tissue))
  print(knitr::kable(df, format = "html", table.attr = "class='table table-bordered table-condensed'"))
  cat("</details>\n\n")
}


#hist(res_df$pvalue, breaks = 50, main = paste("P-value dist:", tissue, pair_name))


# Check for barcode mismatches across all Seurat objects in a list (e.g., filtered_list or gene_filtered_list)
check_barcode_consistency <- function(seurat_list, list_name = "seurat_list") {
  results <- data.frame(
    Object = character(),
    n_metadata = integer(),
    n_counts = integer(),
    Match = logical(),
    stringsAsFactors = FALSE
  )

  for (obj_name in names(seurat_list)) {
    obj <- seurat_list[[obj_name]]
    meta_barcodes <- rownames(obj@meta.data)
    assay_barcodes <- colnames(GetAssayData(obj, slot = "counts"))

    match_status <- identical(meta_barcodes, assay_barcodes)

    results <- rbind(results, data.frame(
      Object = obj_name,
      n_metadata = length(meta_barcodes),
      n_counts = length(assay_barcodes),
      Match = match_status,
      stringsAsFactors = FALSE
    ))

    if (!match_status) {
      cat(sprintf("❌ MISMATCH in %s: %d meta vs %d counts\n",
                  obj_name, length(meta_barcodes), length(assay_barcodes)))

      first_diff <- which(meta_barcodes != assay_barcodes)[1]
      if (!is.na(first_diff)) {
        cat(sprintf("   → First mismatch at position %d: meta = %s, counts = %s\n",
                    first_diff, meta_barcodes[first_diff], assay_barcodes[first_diff]))
      }
    } else {
      cat(sprintf("✅ %s is consistent (%d barcodes)\n", obj_name, length(meta_barcodes)))
    }
  }

  return(results)
}

consistency_summary_filtered <- check_barcode_consistency(gene_filtered_list, "filtered_list")




# Preprocess: Pseudobulk aggregation + basic gene filtering


for (tissue in names(gene_filtered_list)) {
  obj <- gene_filtered_list[[tissue]]
  DefaultAssay(obj) <- "RawCounts"
  counts <- GetAssayData(obj, slot = "counts")
  meta <- obj@meta.data
  
  sample_ids <- unique(meta$ID)
  pb_counts <- do.call(cbind, lapply(sample_ids, function(sid) {
    cells <- rownames(meta)[meta$ID == sid]
    Matrix::rowSums(counts[, cells, drop = FALSE])
  }))
  colnames(pb_counts) <- sample_ids

  # ✅ Save unfiltered counts before filtering
  pseudobulk_counts_raw_list[[tissue]] <- pb_counts

  # Match sample-level metadata
  sample_meta <- unique(meta[, c("ID", "Sex", "Age", "Injury", "Batch", "Batch")])
  rownames(sample_meta) <- sample_meta$ID
  sample_meta$ID <- NULL

  # Set factor levels
  sample_meta$Sex <- factor(sample_meta$Sex, levels = c(0, 1))
  sample_meta$Age <- factor(sample_meta$Age, levels = c(0, 1))
  sample_meta$Injury <- factor(sample_meta$Injury, levels = c(0, 2, 3))

  # Log initial gene count
  initial_gene_count <- nrow(pb_counts)

  # ✅ Adaptive gene filtering: remove bottom 25% expressed genes
  gene_sums <- rowSums(pb_counts)
  
  # OPTIONAL: Plot gene expression distribution before filtering
  hist(log10(gene_sums + 1),
      breaks = 50,
      main = paste("Gene sum distribution:", tissue),
      xlab = "log10(Total Counts + 1)",
      col = "gray")
  abline(v = log10(quantile(gene_sums, 0.25) + 1), col = "red", lwd = 2)

  quantile_cutoff <- quantile(gene_sums, 0.25)
  keep_genes <- gene_sums > quantile_cutoff
  filtered_counts <- pb_counts[keep_genes, ]

  cat(sprintf("Tissue: %s — Genes kept: %d of %d (cutoff: %.2f)\n",
              tissue, sum(keep_genes), length(gene_sums), quantile_cutoff))

  
  # ✅ Add this block right here to assess per-group expression after filtering
  sample_meta$Group <- paste(sample_meta$Sex, sample_meta$Age, sample_meta$Injury, sep = "_")
  group_levels <- unique(sample_meta$Group)
  group_gene_info <- list()

  for (g in group_levels) {
    group_samples <- rownames(sample_meta)[sample_meta$Group == g]
    if (length(group_samples) == 0) next
    if (!all(group_samples %in% colnames(filtered_counts))) next
    expr_counts <- rowSums(filtered_counts[, group_samples, drop = FALSE] > 0)
    genes_expressed <- sum(expr_counts > 0)

    group_gene_info[[g]] <- data.frame(
      Tissue = tissue,
      Group = g,
      n_Samples = length(group_samples),
      Genes_Expressed = genes_expressed,
      stringsAsFactors = FALSE
    )
  }

  # Store group representation info
  if (!exists("gene_group_representation_log")) gene_group_representation_log <- list()
  gene_group_representation_log[[tissue]] <- do.call(rbind, group_gene_info)

  # Log retained count
  retained_gene_count <- nrow(filtered_counts)
  gene_filter_log[[tissue]] <- data.frame(
    Tissue = tissue,
    Initial_Genes = initial_gene_count,
    Genes_After_Filtering = retained_gene_count
  )

  # Save filtered counts and metadata
  pseudobulk_counts_list[[tissue]] <- filtered_counts
  pseudobulk_meta_list[[tissue]] <- sample_meta
}


# Combine and show filtering log
filter_log_df <- do.call(rbind, gene_filter_log)

cat("<details><summary><strong>Gene Filtering Summary</strong></summary>\n\n")
print(knitr::kable(filter_log_df, format = "html", table.attr = "class='table table-condensed table-bordered'"))
cat("</details>\n\n")


group_rep_df <- do.call(rbind, gene_group_representation_log)

cat("<details><summary><strong>Gene Expression per Group After Filtering</strong></summary>\n\n")
print(knitr::kable(group_rep_df, format = "html", table.attr = "class='table table-bordered table-condensed'"))
cat("</details>\n\n")







# Barplot for gene and read counts per sample

library(ggplot2)
library(reshape2)

# Define correct sample order from your table (Run 1 to 8)
desired_sample_order <- c(
  "Young1", "AgedOA3",
  "Young3", "Aged5",
  "Young4R", "Aged4R",
  "Aged10R", "Young10R",
  "Aged2R", "Young18R",
  "Young33R", "Young45R",
  "Young46R", "Young47R",
  "Young6R", "Aged3R"
)

cat("<hr><h2>Barplots: Gene Count and Read Count per Sample</h2>\n")

for (tissue in names(gene_filtered_list)) {
  meta <- gene_filtered_list[[tissue]]@meta.data
  meta$Group <- paste(meta$Sex, meta$Age, meta$Injury, sep = "_")

  # Build lookup: Sample ID → readable label
  sample_group_map <- unique(meta[, c("ID", "Group")])
  sample_group_map$PrettyGroup <- sapply(sample_group_map$Group, function(g) {
    label <- group_names[[g]]
    if (is.null(label)) paste0("Unknown (", g, ")") else paste0(label, " (", g, ")")
  })
  sample_group_map$SampleLabel <- paste0(sample_group_map$ID, " — ", gsub(" \\(.*\\)$", "", sample_group_map$PrettyGroup))
  sample_label_lookup <- setNames(sample_group_map$SampleLabel, sample_group_map$ID)

  pb <- pseudobulk_counts_raw_list[[tissue]]
  if (is.null(pb)) next

  # Get metrics
  gene_counts <- apply(pb, 2, function(x) sum(x > 0))
  read_counts <- colSums(pb)

  df <- data.frame(
    SampleID = colnames(pb),
    GeneCount = gene_counts,
    ReadCount = read_counts,
    stringsAsFactors = FALSE
  )
  df$SampleLabel <- sample_label_lookup[df$SampleID]

  # Reorder SampleLabel factor according to desired_sample_order
  df$SampleLabel <- factor(df$SampleLabel,
    levels = sample_label_lookup[desired_sample_order],
    ordered = TRUE
  )

  df_melt <- melt(df, id.vars = "SampleLabel", measure.vars = c("GeneCount", "ReadCount"))

  cat(sprintf("<details><summary><strong>%s: Gene vs Read Count per Sample</strong></summary>\n\n", tissue))

  print(
    ggplot(df_melt, aes(x = SampleLabel, y = value, fill = variable)) +
      geom_bar(stat = "identity", position = position_dodge(width = 0.7)) +
      scale_y_continuous(
        name = "Gene Count",
        sec.axis = sec_axis(~ ., name = "Read Count")
      ) +
      scale_fill_manual(values = c("GeneCount" = "steelblue", "ReadCount" = "firebrick")) +
      theme_minimal(base_size = 10) +
      theme(
        axis.text.x = element_text(angle = 45, hjust = 1),
        axis.title.y.left = element_text(color = "steelblue"),
        axis.title.y.right = element_text(color = "firebrick")
      ) +
      labs(x = "Sample", fill = "Metric", title = paste("Gene vs Read Count —", tissue))
  )

  cat("</details>\n\n")
}





```



## 4.1 Downstream Analyses with Pseudobulking without adjuting by metadata


```{r PseudobulkDE, echo=TRUE, results='asis', message=FALSE, warning=FALSE}



if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

if (!requireNamespace("apeglm", quietly = TRUE)) {
  BiocManager::install("apeglm")
}


library(DESeq2)
library(Seurat)
library(ggplot2)
library(dplyr)
library(knitr)
library(EnhancedVolcano)

pseudobulk_results <- list()
zero_problem_tables <- list()
summary_signif_genes <- list()
summary_comparisons_diag <- list()

cat("<details><summary><strong>Pseudobulk DE Analysis per Tissue</strong></summary>\n\n")

                
                  ############ TO DO #############

use_filtered_counts <- TRUE  # Set this once at the top of your chunk

for (tissue in names(gene_filtered_list)) {
  # Choose raw or filtered pseudobulk counts
  pb_counts <- if (use_filtered_counts) {
    pseudobulk_counts_list[[tissue]]
  } else {
    pseudobulk_counts_raw_list[[tissue]]
  }

  sample_meta <- pseudobulk_meta_list[[tissue]]

  # Define group column based on metadata
  sample_meta$Group <- paste(sample_meta$Sex, sample_meta$Age, sample_meta$Injury, sep = "_")
  sample_groups <- sample_meta$Group
  names(sample_groups) <- rownames(sample_meta)  # Ensure sample IDs are names

  # Define encoded comparisons
  comparison_plan <- list(
    "Male_Aged" = list(c("0_1_0", "0_1_2"), c("0_1_0", "0_1_3"), c("0_1_2", "0_1_3")),
    "Male_Young" = list(c("0_0_0", "0_0_2"), c("0_0_0", "0_0_3"), c("0_0_2", "0_0_3")),
    "Male_Young_vs_Aged" = list(c("0_0_0", "0_1_0"), c("0_0_2", "0_1_2"), c("0_0_3", "0_1_3")),
    "Sex_Comparison_Young" = list(c("0_0_0", "1_0_0"), c("0_0_3", "1_0_3")),
    "Female_Young" = list(c("1_0_0", "1_0_3"))
  )
  
  
  
  for (plan in names(comparison_plan)) {
    for (pair in comparison_plan[[plan]]) {
      sel_samples <- intersect(colnames(pb_counts), names(sample_groups)[sample_groups %in% pair])
      sel_counts <- pb_counts[, sel_samples, drop = FALSE]
      sel_groups <- factor(sample_groups[sel_samples])

      if (length(unique(sel_groups)) < 2 || any(table(sel_groups) < 2)) {
        next
      }

      nonzero_genes <- rowSums(sel_counts > 0) > 0
      sel_counts <- sel_counts[nonzero_genes, , drop = FALSE]

      if (nrow(sel_counts) == 0) {
        cat(sprintf("<p><em>Skipping %s (%s): all genes are zero after filtering.</em></p>\n",
                    tissue, paste(pair, collapse = "_vs_")))
        next
      }

      group_sizes <- table(sel_groups)
      if (any(group_sizes < 2)) {
        next
      }


      # Create readable labels for the Group column
      group_labels <- sapply(names(group_sizes), function(g) {
        label <- group_names[[g]]
        if (is.null(label)) paste0("Unknown (", g, ")") else paste0(label, " (", g, ")")
      })

      group_count_df <- data.frame(
        Tissue = tissue,
        Plan = plan,
        Comparison = paste0(
          group_names[[pair[1]]], " (", pair[1], ") vs ",
          group_names[[pair[2]]], " (", pair[2], ")"),
        Group = group_labels,
        Sample_Count = as.vector(group_sizes),
        stringsAsFactors = FALSE
      )

      cat("<p><strong>Sample counts for each group:</strong></p>\n")
      cat(kable(group_count_df, format = "html", table.attr = "class='table table-bordered table-condensed'"))

      comparison_name <- paste(tissue, plan, paste(pair, collapse = "_vs_"), sep = "__")

      col_data <- data.frame(condition = factor(sel_groups))
      rownames(col_data) <- colnames(sel_counts)
      col_data$condition <- relevel(col_data$condition, ref = pair[1])
      dds <- DESeqDataSetFromMatrix(countData = as.matrix(sel_counts),
                                    colData = col_data,
                                    design = ~ condition)
  

      dds <- estimateSizeFactors(dds, type = "poscounts")
      dds <- DESeq(dds)
      
      print(resultsNames(dds))  # This shows which comparison (coef) to shrink
      
      #pair_name <- paste(pair, collapse = "_vs_")
      
      res <- lfcShrink(dds, coef = 2, type = "apeglm")
      
      #plotMA(res, ylim = c(-3, 3), alpha = 0.05, main = paste(tissue, plan, pair_name))

      res_df <- as.data.frame(res)
      res_df$gene <- rownames(res_df)
      res_df <- res_df[!is.na(res_df$pvalue), ]

      pseudobulk_results[[tissue]][[comparison_name]] <- res_df

      top_genes_df <- res_df %>%
        arrange(pvalue, desc(abs(log2FoldChange))) %>%
        filter(pvalue < 0.05) %>%
        head(20) %>%
        mutate(
          FC = 2^log2FoldChange
        ) %>%
        select(gene, log2FoldChange, FC, pvalue, padj)
        

      if (nrow(top_genes_df) > 0) {
        summary_signif_genes[[length(summary_signif_genes)+1]] <- data.frame(
          Tissue = tissue,
          Plan = plan,
          Comparison = paste0(
            group_names[[pair[1]]], " (", pair[1], ") vs ",
            group_names[[pair[2]]], " (", pair[2], ")"),
          Gene = top_genes_df$gene,
          log2FC = top_genes_df$log2FoldChange,
          FC = top_genes_df$FC,
          pvalue = top_genes_df$pvalue,
          padj = top_genes_df$padj,
          stringsAsFactors = FALSE
        )
      } else {
        cat(sprintf("<p><em>No DE genes found for %s (%s)</em></p>\n", tissue, paste(pair, collapse = "_vs_")))
      }

      summary_comparisons_diag[[length(summary_comparisons_diag) + 1]] <- data.frame(
        Tissue = tissue,
        Plan = plan,
        Comparison = paste0(
          group_names[[pair[1]]], " (", pair[1], ") vs ",
          group_names[[pair[2]]], " (", pair[2], ")"),
        n_samples = length(sel_samples),
        n_sig_genes_pvalue_0.05 = sum(res_df$pvalue < 0.05, na.rm = TRUE),
        n_sig_genes_pvalue_0.1 = sum(res_df$pvalue < 0.1, na.rm = TRUE),
        n_sig_genes_padj_0.2 = sum(res_df$padj < 0.2, na.rm = TRUE),
        stringsAsFactors = FALSE
      )

      cat(sprintf("<details><summary><strong>%s — DE (%s)</strong></summary>\n\n", tissue, paste(pair, collapse = "_vs_")))
      print(EnhancedVolcano(res_df,
                            lab = res_df$gene,
                            selectLab = top_genes_df$gene,
                            x = "log2FoldChange",
                            y = "pvalue",
                            pCutoff = 0.05,
                            FCcutoff = 1.0,
                            pointSize = 2.0,
                            labSize = 3.5,
                            title = paste(tissue, ":", group_names[[pair[1]]], "vs", group_names[[pair[2]]]),
                            subtitle = paste0(plan, " — ", group_names[[pair[1]]], " vs ", group_names[[pair[2]]]),
                            caption = paste("total =", nrow(res_df), "genes tested")))

      cat(sprintf("<p><strong>Top 20 DE genes (%s):</strong></p>", paste(pair, collapse = "_vs_")))
      cat(kable(top_genes_df, format = "html", table.attr = "class='table table-bordered table-condensed'"))
      cat("</details>\n\n")
    }
  }
}

cat("</details>\n\n")

if (length(summary_signif_genes) > 0) {
  final_summary_table <- do.call(rbind, summary_signif_genes)

  cat("<details><summary><strong>Summary of Significant Genes Across Comparisons (by Tissue)</strong></summary>\n\n")

  # Split by tissue and create collapsible sections
  by_tissue <- split(final_summary_table, final_summary_table$Tissue)

  for (tissue_name in names(by_tissue)) {
    tissue_df <- by_tissue[[tissue_name]]
    cat(sprintf("<details><summary><strong>%s</strong></summary>\n\n", tissue_name))
    cat(kable(tissue_df, format = "html", table.attr = "class='table table-striped table-condensed'"))
    cat("</details>\n\n")
  }

  cat("</details>\n\n")
}



if (length(summary_signif_genes) > 0) {
  final_summary_table <- do.call(rbind, summary_signif_genes)

  # === New FDR < 0.2 summary ===
  filtered_summary <- final_summary_table[!is.na(final_summary_table$padj) & final_summary_table$padj < 0.2, ]

  if (nrow(filtered_summary) > 0) {
    cat("<details><summary><strong>Filtered Summary of Significant Genes (FDR < 0.2, All Tissues)</strong></summary>\n\n")
    cat(kable(filtered_summary, format = "html", table.attr = "class='table table-striped table-condensed'"))
    cat("</details>\n\n")
  } else {
    cat("<p><em>No genes with FDR < 0.2 across all tissues.</em></p>")
  }
}



if (length(summary_comparisons_diag) > 0) {
  diag_table <- do.call(rbind, summary_comparisons_diag)

  cat("<details><summary><strong>Diagnostic Summary of All Comparisons (by Tissue)</strong></summary>\n\n")

  by_tissue <- split(diag_table, diag_table$Tissue)

  for (tissue_name in names(by_tissue)) {
    tissue_df <- by_tissue[[tissue_name]]
    cat(sprintf("<details><summary><strong>%s</strong></summary>\n\n", tissue_name))
    cat(kable(tissue_df, format = "html", table.attr = "class='table table-striped table-condensed'"))
    cat("</details>\n\n")
  }

  cat("</details>\n\n")
}


if (length(summary_comparisons_diag) > 0) {
  diag_table <- do.call(rbind, summary_comparisons_diag)

  filtered_diag <- diag_table[diag_table$n_sig_genes_padj_0.2 > 0, ]

  if (nrow(filtered_diag) > 0) {
    cat("<details><summary><strong>Filtered Diagnostic Summary (FDR < 0.2, All Tissues)</strong></summary>\n\n")
    cat(kable(filtered_diag, format = "html", table.attr = "class='table table-striped table-condensed'"))
    cat("</details>\n\n")
  } else {
    cat("<p><em>No diagnostic entries with FDR < 0.2 across tissues.</em></p>")
  }
}


```


## 4.2 Downstream Analyses with Pseudobulking adjuting by metadata


```{r PseudobulkDE2, echo=TRUE, results='asis', message=FALSE, warning=FALSE}
# ===========================
# Pseudobulk DE: Adjusted Subsets (with filtering and factor levels)
# ===========================

# Initialize result list
summary_signif_genes_adj_model <- list()

cat("<details><summary><strong>Pseudobulk DE Analysis (Adjusted Subsets)</strong></summary>\n\n")

for (tissue in names(gene_filtered_list)) {
  
              ########### TO DO ############
  
  # Choose raw or filtered pseudobulk counts
  use_filtered_counts <- TRUE  # Set this at the top of your Rmd if you want to expose as a parameter
  pb_counts <- if (use_filtered_counts) {
    pseudobulk_counts_list[[tissue]]
  } else {
    pseudobulk_counts_raw_list[[tissue]]
  }

  sample_meta <- pseudobulk_meta_list[[tissue]]

  # Safely match metadata into col_data using sample IDs
  col_data <- sample_meta[rownames(sample_meta) %in% colnames(pb_counts), , drop = FALSE]

  # Apply explicit factor levels again post-subset
  col_data$Sex <- factor(col_data$Sex, levels = c(0, 1))       # 0 = Male, 1 = Female
  col_data$Age <- factor(col_data$Age, levels = c(0, 1))       # 0 = Young, 1 = Aged
  col_data$Injury <- factor(col_data$Injury, levels = c(0, 2, 3))  # 0 = Naive, 2 = Sham, 3 = DMM

  sel_counts <- pb_counts[, rownames(col_data)]

  subset_plans <- list(
    "Old_Male_DMM_vs_Naive" = list(filter = col_data$Sex == 0 & col_data$Age == 1 & col_data$Injury %in% c(0, 3), design = ~ Injury),
    "Old_Male_DMM_vs_Sham" = list(filter = col_data$Sex == 0 & col_data$Age == 1 & col_data$Injury %in% c(2, 3), design = ~ Injury),
    "Old_Male_Sham_vs_Naive" = list(filter = col_data$Sex == 0 & col_data$Age == 1 & col_data$Injury %in% c(0, 2), design = ~ Injury),
    "Young_Male_DMM_vs_Naive" = list(filter = col_data$Sex == 0 & col_data$Age == 0 & col_data$Injury %in% c(0, 3), design = ~ Injury),
    "Young_Male_DMM_vs_Sham" = list(filter = col_data$Sex == 0 & col_data$Age == 0 & col_data$Injury %in% c(2, 3), design = ~ Injury),
    "Young_Male_Sham_vs_Naive" = list(filter = col_data$Sex == 0 & col_data$Age == 0 & col_data$Injury %in% c(0, 2), design = ~ Injury),
    "Male_Young_vs_Aged_Naive" = list(filter = col_data$Sex == 0 & col_data$Injury == 0 & col_data$Age %in% c(0, 1), design = ~ Age),
    "Male_Young_vs_Aged_Sham" = list(filter = col_data$Sex == 0 & col_data$Injury == 2 & col_data$Age %in% c(0, 1), design = ~ Age),
    "Male_Young_vs_Aged_DMM" = list(filter = col_data$Sex == 0 & col_data$Injury == 3 & col_data$Age %in% c(0, 1), design = ~ Age),
    "Young_Male_vs_Female_Naive" = list(filter = col_data$Age == 0 & col_data$Injury == 0 & col_data$Sex %in% c(0, 1), design = ~ Sex),
    "Young_Male_vs_Female_DMM" = list(filter = col_data$Age == 0 & col_data$Injury == 3 & col_data$Sex %in% c(0, 1), design = ~ Sex),
    "Young_Female_DMM_vs_Naive" = list(filter = col_data$Sex == 1 & col_data$Age == 0 & col_data$Injury %in% c(0, 3), design = ~ Injury)
  )

  for (plan_name in names(subset_plans)) {
    plan <- subset_plans[[plan_name]]
    subset_meta <- col_data[plan$filter, ]
    cat(sprintf("\u2192 %s (%s): n = %d samples\n", tissue, plan_name, nrow(subset_meta)))
    if (nrow(subset_meta) < 4) next

    subset_counts <- sel_counts[, rownames(subset_meta)]
    if (length(unique(subset_meta[, all.vars(plan$design)[1]])) < 2) {
      cat(sprintf("<p><em>Skipping %s (%s): only one level present in %s factor.</em></p>\n", tissue, plan_name, all.vars(plan$design)[1]))
      next
    }

    dds1 <- DESeqDataSetFromMatrix(countData = as.matrix(subset_counts),
                                   colData = subset_meta,
                                   design = plan$design)

    dds1 <- estimateSizeFactors(dds1, type = "poscounts")
    dds1 <- DESeq(dds1)

    factor_var <- all.vars(plan$design)[1]
    vals <- levels(droplevels(subset_meta[[factor_var]]))
    if (length(vals) < 2) next
    res <- results(dds1, contrast = c(factor_var, vals[2], vals[1]))

    res_df <- as.data.frame(res)
    res_df$gene <- rownames(res_df)
    res_df <- res_df[!is.na(res_df$pvalue), ]

    top_genes_df <- res_df %>%
      arrange(pvalue, desc(abs(log2FoldChange))) %>%
      filter(pvalue < 0.05) %>%
      head(20) %>%
      mutate(FC = 2^log2FoldChange) %>%
      select(gene, log2FoldChange, FC, pvalue, padj)

    if (nrow(top_genes_df) > 0) {
      summary_signif_genes_adj_model[[length(summary_signif_genes_adj_model) + 1]] <- data.frame(
        Tissue = tissue,
        Comparison = plan_name,
        Gene = top_genes_df$gene,
        log2FC = top_genes_df$log2FoldChange,
        FC = top_genes_df$FC,
        pvalue = top_genes_df$pvalue,
        padj = top_genes_df$padj,
        stringsAsFactors = FALSE
      )
    }

    cat(sprintf("<details><summary><strong>%s — %s</strong></summary>\n\n", tissue, plan_name))
    print(EnhancedVolcano(res_df,
                          lab = res_df$gene,
                          selectLab = top_genes_df$gene,
                          x = "log2FoldChange",
                          y = "pvalue",
                          pCutoff = 0.05,
                          FCcutoff = 1.0,
                          pointSize = 2.0,
                          labSize = 3.5,
                          title = paste(tissue, ":", plan_name),
                          subtitle = "Subset Adjusted",
                          caption = paste("total =", nrow(res_df), "genes tested")))
    cat(sprintf("<p><strong>Top 20 DE genes (%s):</strong></p>", plan_name))
    cat(kable(top_genes_df, format = "html", table.attr = "class='table table-bordered table-condensed'"))
    cat("</details>\n\n")
  }
}

cat("</details>\n\n")

if (length(summary_signif_genes_adj_model) > 0) {
  final_summary_table <- do.call(rbind, summary_signif_genes_adj_model)

  cat("<details><summary><strong>Summary of All Subset Comparisons (by Tissue)</strong></summary>\n\n")

  by_tissue <- split(final_summary_table, final_summary_table$Tissue)

  for (tissue_name in names(by_tissue)) {
    tissue_df <- by_tissue[[tissue_name]]
    cat(sprintf("<details><summary><strong>%s</strong></summary>\n\n", tissue_name))
    cat(kable(tissue_df, format = "html", table.attr = "class='table table-striped table-condensed'"))
    cat("</details>\n\n")
  }

  cat("</details>\n\n")
}



if (length(summary_signif_genes_adj_model) > 0) {
  final_summary_table <- do.call(rbind, summary_signif_genes_adj_model)

  # === New FDR < 0.2 summary ===
  filtered_summary <- final_summary_table[!is.na(final_summary_table$padj) & final_summary_table$padj < 0.2, ]

  if (nrow(filtered_summary) > 0) {
    cat("<details><summary><strong>Filtered Summary of Subset Comparisons (FDR < 0.2, All Tissues)</strong></summary>\n\n")
    cat(kable(filtered_summary, format = "html", table.attr = "class='table table-striped table-condensed'"))
    cat("</details>\n\n")
  } else {
    cat("<p><em>No genes with FDR < 0.2 across subset comparisons.</em></p>")
  }
}


```


### 4.2.1 Downstream Analyses with Pseudobulking adjuting by metadata with interactions


```{r PseudobulkDE2Interaction, echo=TRUE, results='asis', message=FALSE, warning=FALSE}

# ===========================
# Pseudobulk DE: Subset-Friendly Full Interaction (Age × Injury only)
# ===========================

summary_signif_genes_subset_full_interact <- list()

cat("<details><summary><strong>Subset-Based Interaction Models (Age × Injury only)</strong></summary>\n\n")

for (tissue in names(gene_filtered_list)) {
  cat(sprintf("<p>→ Processing tissue: <strong>%s</strong></p>\n", tissue))

  pb_counts <- pseudobulk_counts_list[[tissue]]
  meta <- pseudobulk_meta_list[[tissue]]

  meta$Sex <- factor(meta$Sex, levels = c(0, 1))
  meta$Age <- factor(meta$Age, levels = c(0, 1))
  meta$Injury <- factor(meta$Injury, levels = c(0, 2, 3))

  meta <- meta[rownames(meta) %in% colnames(pb_counts), ]
  counts <- pb_counts[, rownames(meta)]

  if (
    nrow(meta) >= 6 &&
    length(unique(meta$Sex)) > 1 &&
    length(unique(meta$Age)) > 1 &&
    length(unique(meta$Injury)) > 1 &&
    length(unique(interaction(meta$Age, meta$Injury))) > 1
  ) {
    dds_try <- try(
      DESeqDataSetFromMatrix(countData = as.matrix(counts),
                             colData = meta,
                             design = ~ Sex + Age + Injury + Age:Injury),
      silent = TRUE
    )

    if (inherits(dds_try, "try-error")) {
      cat(sprintf("<p><em>Skipping %s — model matrix not full rank</em></p>\n", tissue))
      next
    }

    dds <- dds_try
    dds <- estimateSizeFactors(dds, type = "poscounts")
    dds <- DESeq(dds)

    interaction_terms <- grep("Age:Injury", resultsNames(dds), value = TRUE)

    for (term in interaction_terms) {
      res <- results(dds, name = term)
      res_df <- as.data.frame(res)
      res_df$gene <- rownames(res_df)
      res_df <- res_df[!is.na(res_df$pvalue), ]

      top_genes <- res_df %>%
        arrange(pvalue, desc(abs(log2FoldChange))) %>%
        filter(pvalue < 0.05) %>%
        head(20) %>%
        mutate(FC = 2^log2FoldChange) %>%
        select(gene, log2FoldChange, FC, pvalue, padj)

      cat(sprintf("<details><summary><strong>%s — %s</strong></summary>\n\n", tissue, term))

      if (nrow(top_genes) > 0) {
        print(EnhancedVolcano(res_df,
                              lab = res_df$gene,
                              selectLab = top_genes$gene,
                              x = "log2FoldChange",
                              y = "pvalue",
                              pCutoff = 0.05,
                              FCcutoff = 1.0,
                              pointSize = 2.0,
                              labSize = 3.5,
                              title = paste(tissue, ":", term),
                              subtitle = "Subset Age × Injury Interaction",
                              caption = paste("total =", nrow(res_df), "genes tested")))
        cat(kable(top_genes, format = "html", table.attr = "class='table table-bordered table-condensed'"))
      } else {
        cat("<p><em>No significant genes (p < 0.05) for this interaction.</em></p>\n")
      }

      cat("</details>\n\n")

      if (nrow(top_genes) > 0) {
        summary_signif_genes_subset_full_interact[[length(summary_signif_genes_subset_full_interact) + 1]] <- data.frame(
          Tissue = tissue,
          Interaction = term,
          Gene = top_genes$gene,
          log2FC = top_genes$log2FoldChange,
          FC = top_genes$FC,
          pvalue = top_genes$pvalue,
          padj = top_genes$padj,
          stringsAsFactors = FALSE
        )
      }
    }

  } else {
    cat(sprintf("<p><strong>%s</strong>: Skipped — variation check failed.<br>
n = %d, Sex = %d, Age = %d, Injury = %d, Age:Injury = %d</p>\n",
      tissue,
      nrow(meta),
      length(unique(meta$Sex)),
      length(unique(meta$Age)),
      length(unique(meta$Injury)),
      length(unique(interaction(meta$Age, meta$Injury)))
    ))
  }
}

cat("</details>\n\n")

# === Summary collapsibles
if (length(summary_signif_genes_subset_full_interact) > 0) {
  full_inter_summary <- do.call(rbind, summary_signif_genes_subset_full_interact)
  full_inter_summary$Model <- "Subset Full Interaction"

  cat("<details><summary><strong>Summary of Full Interaction Terms by Tissue</strong></summary>\n\n")
  by_tissue <- split(full_inter_summary, full_inter_summary$Tissue)

  for (tissue_name in names(by_tissue)) {
    tissue_df <- by_tissue[[tissue_name]]
    cat(sprintf("<details><summary><strong>%s</strong></summary>\n\n", tissue_name))
    cat(kable(tissue_df, format = "html", table.attr = "class='table table-striped table-condensed'"))
    cat("</details>\n\n")
  }

  cat("</details>\n\n")

  # === Filtered summary by FDR
  filtered_summary <- full_inter_summary[!is.na(full_inter_summary$padj) & full_inter_summary$padj < 0.2, ]

  if (nrow(filtered_summary) > 0) {
    cat("<details><summary><strong>Filtered Summary of Subset Interaction Genes (FDR < 0.2, All Tissues)</strong></summary>\n\n")
    cat(kable(filtered_summary, format = "html", table.attr = "class='table table-striped table-condensed'"))
    cat("</details>\n\n")
  } else {
    cat("<p><em>No genes with FDR < 0.2 in subset interaction model across all tissues.</em></p>")
  }
}

```



## 4.3 Downstream Analyses with Pseudobulking and main effects model


```{r PseudobulkDEmainEffects, echo=TRUE, results='asis', message=FALSE, warning=FALSE}

use_filtered_counts <- TRUE  # ← Toggle this at the top of your Rmd file if you want dynamic control

# Initialize list to collect results
summary_signif_genes_main_model <- list()
gsea_results_main_model <- list()  # store GSEA results

# ---- NEW: GSEA speed/precision toggles + FDR cutoff (safe defaults if not set earlier) ----
gsea_mode <- get0("gsea_mode", ifnotfound = "fast")            # "fast" or "accurate"
gsea_nperm_fast <- get0("gsea_nperm_fast", ifnotfound = 5000)  # perms for fgsea() fast mode
gsea_q_cutoff <- get0("gsea_q_cutoff", ifnotfound = 0.20)      # always 0.20 for you

for (tissue in names(gene_filtered_list)) {
  cat(sprintf("<details><summary><strong>%s — Main Effects Model</strong></summary>\n\n", tissue))

  
  ########## TO DO #############
  
  # Load pseudobulk counts depending on filtering
  pb_counts <- if (use_filtered_counts) {
    pseudobulk_counts_list[[tissue]]
  } else {
    pseudobulk_counts_raw_list[[tissue]]
  }

  # Load corresponding metadata
  meta <- pseudobulk_meta_list[[tissue]]

  # Ensure factors are properly set
  meta$Sex <- factor(meta$Sex, levels = c(0, 1))
  meta$Age <- factor(meta$Age, levels = c(0, 1))
  meta$Injury <- factor(meta$Injury, levels = c(0, 2, 3))
  meta$Batch <- factor(meta$Batch, levels = c(0, 1))

  # Create DESeq2 object
  dds2 <- DESeqDataSetFromMatrix(countData = as.matrix(pb_counts),
                                 colData = meta,
                                 design = ~ Sex + Age + Injury + Batch)

  dds2 <- estimateSizeFactors(dds2, type = "poscounts")
  dds2 <- DESeq(dds2)

  # Run all pairwise contrasts
  contrast_list <- list(
    "DMM_vs_Naive" = c("Injury", "3", "0"),
    "Sham_vs_Naive" = c("Injury", "2", "0"),
    "DMM_vs_Sham" = c("Injury", "3", "2"),
    "Sex_Female_vs_Male" = c("Sex", "1", "0"),
    "Age_Aged_vs_Young" = c("Age", "1", "0")
  )

  for (contrast_name in names(contrast_list)) {
    res <- results(dds2, contrast = contrast_list[[contrast_name]])
    res_df <- as.data.frame(res)
    res_df$gene <- rownames(res_df)
    res_df <- res_df[!is.na(res_df$pvalue), ]

    top_genes <- res_df %>%
      arrange(pvalue, desc(abs(log2FoldChange))) %>%
      filter(pvalue < 0.05) %>%
      head(20) %>%
      mutate(FC = 2^log2FoldChange) %>%
      select(gene, log2FoldChange, FC, pvalue, padj)
    
    if (nrow(top_genes) > 0) {
      summary_signif_genes_main_model[[length(summary_signif_genes_main_model) + 1]] <- data.frame(
        Tissue = tissue,
        Comparison = contrast_name,
        Gene = top_genes$gene,
        log2FC = top_genes$log2FoldChange,
        FC = top_genes$FC,
        pvalue = top_genes$pvalue,
        padj = top_genes$padj,
        stringsAsFactors = FALSE
      )
    }

    cat(sprintf("<details><summary><strong>%s — %s</strong></summary>\n\n", tissue, contrast_name))
    print(EnhancedVolcano(res_df,
                          lab = res_df$gene,
                          selectLab = top_genes$gene,
                          x = "log2FoldChange",
                          y = "pvalue",
                          pCutoff = 0.05,
                          FCcutoff = 1.0,
                          pointSize = 2.0,
                          labSize = 3.5,
                          title = paste(tissue, ":", contrast_name),
                          subtitle = "Main Effects Model",
                          caption = paste("total =", nrow(res_df), "genes tested")))
    cat(kable(top_genes, format = "html", table.attr = "class='table table-condensed table-bordered'"))
    cat("</details>\n\n")

    # ===========================
    # NEW: Run GSEA for this contrast (fast/accurate toggle)
    # ===========================
    # Use Wald stat if present; fall back to signed z from p-value
    if (!"stat" %in% names(res_df)) {
      res_df$stat <- sign(res_df$log2FoldChange) *
        qnorm(pmax(pmin(res_df$pvalue, 1 - 1e-16), 1e-300), lower.tail = FALSE)
    }
    ranked_genes <- res_df$stat
    names(ranked_genes) <- res_df$gene
    ranked_genes <- ranked_genes[!is.na(ranked_genes)]
    ranked_genes <- sort(ranked_genes, decreasing = TRUE)

    set.seed(123)
    if (identical(gsea_mode, "fast")) {
      fg <- fgsea::fgsea(
        pathways = pathways_mouse,
        stats    = ranked_genes,
        minSize  = gsea_min_size,
        maxSize  = gsea_max_size,
        nperm    = gsea_nperm_fast
        # , nproc = max(1, parallel::detectCores()-1)  # uncomment if you want parallel here
      )
    } else {
      fg <- fgsea::fgseaMultilevel(
        pathways = pathways_mouse,
        stats    = ranked_genes,
        minSize  = gsea_min_size,
        maxSize  = gsea_max_size
      )
    }

    # Define DE genes for overlap calculation
    de_genes <- res_df$gene[!is.na(res_df$padj) & res_df$padj < 0.20]

    # Add leading edge info
    fg$leadingEdge_count    <- vapply(fg$leadingEdge, length, integer(1))
    fg$leadingEdge_DE_count <- vapply(fg$leadingEdge, function(g) sum(g %in% de_genes), integer(1))
    fg$leadingEdge_DE_genes <- vapply(
      fg$leadingEdge, function(g) paste(intersect(g, de_genes), collapse = ", "),
      FUN.VALUE = character(1)
    )
    fg$leadingEdge <- vapply(fg$leadingEdge, paste, collapse = ", ", FUN.VALUE = character(1))

    # Add metadata
    fg$Tissue <- tissue
    fg$Comparison <- contrast_name

    # Store
    gsea_results_main_model[[length(gsea_results_main_model) + 1]] <- fg

    # Print enriched pathways (FDR cutoff = gsea_q_cutoff, default 0.20)
    fg_sig <- fg[!is.na(fg$padj) & fg$padj < gsea_q_cutoff, ]
    if (nrow(fg_sig) > 0) {
      cat("<details><summary><em>Significant GSEA Pathways</em></summary>\n\n")
      cat(kable(fg_sig[, c("pathway", "NES", "padj", "leadingEdge_DE_genes")],
                format = "html", table.attr = "class='table table-condensed table-bordered'"))
      cat("</details>\n\n")
    }
  }

  cat("</details>\n\n")
}

# ===========================
# Construct combined_summary
# ===========================

combined_results <- list()

# Add Main Effects Model
if (length(summary_signif_genes_main_model) > 0) {
  tmp <- do.call(rbind, summary_signif_genes_main_model)
  tmp$Model <- "Main Effects"
  combined_results[["Main Effects"]] <- tmp
}

# Add other models if they exist
if (exists("summary_signif_genes_adj_model") && length(summary_signif_genes_adj_model) > 0) {
  tmp <- do.call(rbind, summary_signif_genes_adj_model)
  tmp$Model <- "Subset Adjusted"
  combined_results[["Subset Adjusted"]] <- tmp
}

if (exists("summary_signif_genes_interaction_model") && length(summary_signif_genes_interaction_model) > 0) {
  tmp <- do.call(rbind, summary_signif_genes_interaction_model)
  tmp$Model <- "Main Effects + Age × Injury"
  combined_results[["Main Effects + Age × Injury"]] <- tmp
}

if (exists("summary_signif_genes_subset_full_interact") && length(summary_signif_genes_subset_full_interact) > 0) {
  tmp <- do.call(rbind, summary_signif_genes_subset_full_interact)
  tmp$Model <- "Subset Full Interaction"
  combined_results[["Subset Full Interaction"]] <- tmp
}

# Bind all
if (length(combined_results) > 0) {
  combined_summary <- do.call(rbind, combined_results)
  # Force Model, Tissue, and Gene columns to UTF-8
  combined_summary$Model <- enc2utf8(as.character(combined_summary$Model))
  combined_summary$Tissue <- enc2utf8(as.character(combined_summary$Tissue))
  combined_summary$Gene <- enc2utf8(as.character(combined_summary$Gene))
}

# ===========================
# Combine GSEA results
# ===========================
if (length(gsea_results_main_model) > 0) {
  gsea_summary <- do.call(rbind, gsea_results_main_model)
  gsea_summary <- gsea_summary[order(gsea_summary$padj), ]
}

# ===========================
# Print DE summaries (original code preserved)
# ===========================
if (exists("combined_summary") && nrow(combined_summary) > 0) {
  cat("<details><summary><strong>Summary of All Comparisons by Model and Tissue</strong></summary>\n\n")

  by_model <- split(combined_summary, combined_summary$Model)

  for (model_name in names(by_model)) {
    model_df <- by_model[[model_name]]
    model_label <- iconv(model_name, from = "", to = "UTF-8", sub = "ASCII")
    cat(sprintf("<details><summary><strong>%s Model</strong></summary>\n\n", model_label))

    by_tissue <- split(model_df, model_df$Tissue)

    for (tissue_name in names(by_tissue)) {
      tissue_df <- by_tissue[[tissue_name]]
      tissue_label <- iconv(tissue_name, from = "", to = "UTF-8", sub = "ASCII")
      cat(sprintf("<details><summary><strong>%s</strong></summary>\n\n", tissue_label))

      # Fix column names
      colnames(tissue_df) <- iconv(colnames(tissue_df), from = "", to = "UTF-8", sub = "ASCII")

      # Fix cell values
      tissue_df[] <- lapply(tissue_df, function(x) {
        if (is.factor(x)) {
          x <- as.character(x)
          iconv(x, from = "", to = "UTF-8", sub = "ASCII")
        } else if (is.character(x)) {
          iconv(x, from = "", to = "UTF-8", sub = "ASCII")
        } else {
          x
        }
      })

      # Reconstruct with row names as character to sanitize
      tissue_df <- as.data.frame(lapply(tissue_df, function(x) {
        if (is.factor(x)) x <- as.character(x)
        if (is.character(x)) iconv(x, from = "", to = "UTF-8", sub = "ASCII") else x
      }), stringsAsFactors = FALSE)

      # Remove rownames to avoid encoded issues in them
      rownames(tissue_df) <- NULL

      cat(kable(tissue_df, format = "html", table.attr = "class='table table-striped table-condensed'"))

      cat("</details>\n\n")
    }

    cat("</details>\n\n")
  }

  cat("</details>\n\n")
}

# ===========================
# Print flat DE summary (original code preserved)
# ===========================
if (exists("combined_summary") && nrow(combined_summary) > 0) {
  # Filter to FDR < 0.2
  fdr_filtered <- combined_summary[!is.na(combined_summary$padj) & combined_summary$padj < 0.2, ]

  if (nrow(fdr_filtered) > 0) {
    # Clean up encoding (optional but avoids UTF-8 issues)
    fdr_filtered$Model <- iconv(as.character(fdr_filtered$Model), from = "", to = "UTF-8", sub = "ASCII")
    fdr_filtered$Tissue <- iconv(as.character(fdr_filtered$Tissue), from = "", to = "UTF-8", sub = "ASCII")
    fdr_filtered$Gene <- iconv(as.character(fdr_filtered$Gene), from = "", to = "UTF-8", sub = "ASCII")

    # Drop rownames and display
    rownames(fdr_filtered) <- NULL

    cat("<details><summary><strong>Flat Summary: All Genes with FDR < 0.2</strong></summary>\n\n")
    cat(kable(fdr_filtered, format = "html", table.attr = "class='table table-striped table-condensed'"))
    cat("</details>\n\n")
  } else {
    cat("<p><em>No genes found with FDR < 0.2 across any model/tissue.</em></p>\n")
  }
} else {
  cat("<p><em>No combined summary available to filter for FDR < 0.2.</em></p>\n")
}

# ===========================
# GSEA Summary (with leading-edge info)
# ===========================
if (exists("gsea_summary") && nrow(gsea_summary) > 0) {
  gsea_sig <- subset(gsea_summary, !is.na(padj) & padj < gsea_q_cutoff)
  cat("<details><summary><strong>GSEA Summary: Significant Pathways (FDR < ",
      gsea_q_cutoff, ")</strong></summary>\n\n", sep = "")
  cat(kable(gsea_sig[, c("Tissue","Comparison","pathway","NES","pval","padj",
                         "size","leadingEdge_count","leadingEdge_DE_count",
                         "leadingEdge_DE_genes")],
            format = "html", table.attr = "class='table table-striped table-condensed'"))
  cat("</details>\n\n")
}





# Save the GSEA summary table (significant only) as CSV
if (exists("gsea_summary") && nrow(gsea_summary) > 0) {
  gsea_sig <- subset(gsea_summary, !is.na(padj) & padj < gsea_q_cutoff)

  # Replace commas in gene lists to avoid CSV parsing issues
  gsea_sig$leadingEdge <- gsub(",", ";", gsea_sig$leadingEdge, fixed = TRUE)
  gsea_sig$leadingEdge_DE_genes <- gsub(",", ";", gsea_sig$leadingEdge_DE_genes, fixed = TRUE)

  write.csv(
    gsea_sig[, c("Tissue","Comparison","pathway","NES","pval","padj",
                 "size","leadingEdge_count","leadingEdge_DE_count",
                 "leadingEdge_DE_genes")],
    file = "GSEA_summary_significant.csv",
    row.names = FALSE
  )
}



```


## 4.3.0 Downstream Analyses with Pseudobulking and Main Effects Model (Males Only)

```{r PseudobulkDEmainEffects_MalesOnly, echo=TRUE, results='asis', message=FALSE, warning=FALSE}

use_filtered_counts <- TRUE  # Toggle if needed

# Initialize list
summary_signif_genes_main_model_males <- list()

for (tissue in names(gene_filtered_list)) {
  cat(sprintf("<details><summary><strong>%s — Main Effects Model (Males Only)</strong></summary>\n\n", tissue))

  pb_counts <- if (use_filtered_counts) pseudobulk_counts_list[[tissue]] else pseudobulk_counts_raw_list[[tissue]]
  meta <- pseudobulk_meta_list[[tissue]]

  # Filter to males only
  keep <- meta$Sex == 0
  meta <- meta[keep, ]
  pb_counts <- pb_counts[, keep]

  # Skip if insufficient data
  if (nrow(meta) < 3 || length(unique(meta$Age)) < 2 || length(unique(meta$Injury)) < 2) {
    cat("<p><em>Skipping due to insufficient male-only sample variation.</em></p>\n")
    cat("</details>\n\n")
    next
  }

  # Ensure factors
  meta$Sex <- factor(meta$Sex, levels = c(0, 1))  # still included for model completeness
  meta$Age <- factor(meta$Age, levels = c(0, 1))
  meta$Injury <- factor(meta$Injury, levels = c(0, 2, 3))
  if (!"Batch" %in% colnames(meta)) meta$Batch <- NA
  meta$Batch <- factor(meta$Batch, levels = c(0, 1))

  # Create DESeq2 object
  dds2 <- DESeqDataSetFromMatrix(countData = as.matrix(pb_counts),
                                 colData = meta,
                                 design = ~ Age + Injury + Batch)

  dds2 <- estimateSizeFactors(dds2, type = "poscounts")
  dds2 <- DESeq(dds2)

  # Pairwise contrasts (no Sex contrast anymore)
  contrast_list <- list(
    "DMM_vs_Naive" = c("Injury", "3", "0"),
    "Sham_vs_Naive" = c("Injury", "2", "0"),
    "DMM_vs_Sham" = c("Injury", "3", "2"),
    "Age_Aged_vs_Young" = c("Age", "1", "0")
  )

  for (contrast_name in names(contrast_list)) {
    res <- results(dds2, contrast = contrast_list[[contrast_name]])
    res_df <- as.data.frame(res)
    res_df$gene <- rownames(res_df)
    res_df <- res_df[!is.na(res_df$pvalue), ]

    top_genes <- res_df %>%
      arrange(pvalue, desc(abs(log2FoldChange))) %>%
      filter(pvalue < 0.05) %>%
      head(20) %>%
      mutate(FC = 2^log2FoldChange) %>%
      select(gene, log2FoldChange, FC, pvalue, padj)

    if (nrow(top_genes) > 0) {
      summary_signif_genes_main_model_males[[length(summary_signif_genes_main_model_males) + 1]] <- data.frame(
        Tissue = tissue,
        Comparison = contrast_name,
        Gene = top_genes$gene,
        log2FC = top_genes$log2FoldChange,
        FC = top_genes$FC,
        pvalue = top_genes$pvalue,
        padj = top_genes$padj,
        stringsAsFactors = FALSE
      )
    }

    cat(sprintf("<details><summary><strong>%s — %s</strong></summary>\n\n", tissue, contrast_name))
    print(EnhancedVolcano(res_df,
                          lab = res_df$gene,
                          selectLab = top_genes$gene,
                          x = "log2FoldChange",
                          y = "pvalue",
                          pCutoff = 0.05,
                          FCcutoff = 1.0,
                          pointSize = 2.0,
                          labSize = 3.5,
                          title = paste(tissue, ":", contrast_name),
                          subtitle = "Main Effects Model (Males Only)",
                          caption = paste("total =", nrow(res_df), "genes tested")))
    cat(kable(top_genes, format = "html", table.attr = "class='table table-condensed table-bordered'"))
    cat("</details>\n\n")
  }

  cat("</details>\n\n")
}

# ===========================
# Combined summary
# ===========================

combined_summary_males <- list()

if (length(summary_signif_genes_main_model_males) > 0) {
  tmp <- do.call(rbind, summary_signif_genes_main_model_males)
  tmp$Model <- "Main Effects (Males Only)"
  combined_summary_males[["Main Effects (Males Only)"]] <- tmp
}

if (length(combined_summary_males) > 0) {
  combined_summary <- do.call(rbind, combined_summary_males)

  # Encoding cleanup
  combined_summary$Model <- enc2utf8(as.character(combined_summary$Model))
  combined_summary$Tissue <- enc2utf8(as.character(combined_summary$Tissue))
  combined_summary$Gene <- enc2utf8(as.character(combined_summary$Gene))

  cat("<details><summary><strong>Summary of Comparisons (Males Only)</strong></summary>\n\n")
  by_model <- split(combined_summary, combined_summary$Model)

  for (model_name in names(by_model)) {
    model_df <- by_model[[model_name]]
    cat(sprintf("<details><summary><strong>%s</strong></summary>\n\n", model_name))

    by_tissue <- split(model_df, model_df$Tissue)
    for (tissue_name in names(by_tissue)) {
      tissue_df <- by_tissue[[tissue_name]]
      rownames(tissue_df) <- NULL
      cat(sprintf("<details><summary><strong>%s</strong></summary>\n\n", tissue_name))
      cat(kable(tissue_df, format = "html", table.attr = "class='table table-striped table-condensed'"))
      cat("</details>\n\n")
    }

    cat("</details>\n\n")
  }

  cat("</details>\n\n")

  # FDR < 0.2 flat summary
  fdr_filtered <- combined_summary[!is.na(combined_summary$padj) & combined_summary$padj < 0.2, ]
  if (nrow(fdr_filtered) > 0) {
    rownames(fdr_filtered) <- NULL
    cat("<details><summary><strong>Flat Summary: FDR < 0.2 (Males Only)</strong></summary>\n\n")
    cat(kable(fdr_filtered, format = "html", table.attr = "class='table table-striped table-condensed'"))
    cat("</details>\n\n")
  } else {
    cat("<p><em>No genes with FDR < 0.2 found in male-only main effects model.</em></p>\n")
  }
} else {
  cat("<p><em>No male-only main effects results available.</em></p>\n")
}





# ===========================
# GSEA for Main Effects (Males Only) — add AFTER your males-only DE block
# ===========================

# Safe defaults if not already defined earlier
gsea_mode        <- get0("gsea_mode",        ifnotfound = "fast")     # "fast" or "accurate"
gsea_nperm_fast  <- get0("gsea_nperm_fast",  ifnotfound = 5000)
gsea_q_cutoff    <- get0("gsea_q_cutoff",    ifnotfound = 0.20)
gsea_min_size    <- get0("gsea_min_size",    ifnotfound = 10)
gsea_max_size    <- get0("gsea_max_size",    ifnotfound = 500)

# Collect GSEA results here (males only)
gsea_results_main_model_males <- list()

for (tissue in names(gene_filtered_list)) {
  cat(sprintf("<details><summary><strong>%s — GSEA (Males Only)</strong></summary>\n\n", tissue))

  # Recreate the same male-only inputs WITHOUT altering your original block
  pb_counts <- if (isTRUE(use_filtered_counts)) pseudobulk_counts_list[[tissue]] else pseudobulk_counts_raw_list[[tissue]]
  meta <- pseudobulk_meta_list[[tissue]]

  # Filter to males only
  keep <- meta$Sex == 0
  meta <- meta[keep, , drop = FALSE]
  pb_counts <- pb_counts[, keep, drop = FALSE]

  # Skip if insufficient variation (mirror your checks)
  if (nrow(meta) < 3 || length(unique(meta$Age)) < 2 || length(unique(meta$Injury)) < 2) {
    cat("<p><em>Skipping GSEA due to insufficient male-only sample variation.</em></p>\n")
    cat("</details>\n\n")
    next
  }

  # Ensure factors match your males-only design
  meta$Sex    <- factor(meta$Sex,    levels = c(0, 1))
  meta$Age    <- factor(meta$Age,    levels = c(0, 1))
  meta$Injury <- factor(meta$Injury, levels = c(0, 2, 3))
  if (!"Batch" %in% colnames(meta)) meta$Batch <- NA
  meta$Batch  <- factor(meta$Batch,  levels = c(0, 1))

  # Recompute DESeq2 (isolated from your existing code so nothing is changed)
  dds2_m <- DESeq2::DESeqDataSetFromMatrix(
    countData = as.matrix(pb_counts),
    colData   = meta,
    design    = ~ Age + Injury + Batch
  )
  dds2_m <- DESeq2::estimateSizeFactors(dds2_m, type = "poscounts")
  dds2_m <- DESeq2::DESeq(dds2_m)

  # Same contrasts as your males-only block
  contrast_list_m <- list(
    "DMM_vs_Naive"      = c("Injury", "3", "0"),
    "Sham_vs_Naive"     = c("Injury", "2", "0"),
    "DMM_vs_Sham"       = c("Injury", "3", "2"),
    "Age_Aged_vs_Young" = c("Age",    "1", "0")
  )

  for (contrast_name in names(contrast_list_m)) {
    res <- DESeq2::results(dds2_m, contrast = contrast_list_m[[contrast_name]])
    res_df <- as.data.frame(res)
    res_df$gene <- rownames(res_df)
    res_df <- res_df[!is.na(res_df$pvalue), , drop = FALSE]

    # Wald stat if available; otherwise signed z
    if (!("stat" %in% names(res_df))) {
      res_df$stat <- sign(res_df$log2FoldChange) *
        qnorm(pmax(pmin(res_df$pvalue, 1 - 1e-16), 1e-300), lower.tail = FALSE)
    }

    ranked_genes <- res_df$stat
    names(ranked_genes) <- res_df$gene
    ranked_genes <- ranked_genes[!is.na(ranked_genes)]
    ranked_genes <- sort(ranked_genes, decreasing = TRUE)

    set.seed(123)
    if (identical(gsea_mode, "fast")) {
      fg <- fgsea::fgsea(
        pathways = pathways_mouse,
        stats    = ranked_genes,
        minSize  = gsea_min_size,
        maxSize  = gsea_max_size,
        nperm    = gsea_nperm_fast
      )
    } else {
      fg <- fgsea::fgseaMultilevel(
        pathways = pathways_mouse,
        stats    = ranked_genes,
        minSize  = gsea_min_size,
        maxSize  = gsea_max_size
      )
    }

    fg <- as.data.frame(fg)

    # Define DE genes to count overlaps (FDR < 0.20, same rule)
    de_genes <- res_df$gene[!is.na(res_df$padj) & res_df$padj < 0.20]

    # Leading-edge annotations
    fg$leadingEdge_count    <- vapply(fg$leadingEdge, length, integer(1))
    fg$leadingEdge_DE_count <- vapply(fg$leadingEdge, function(g) sum(g %in% de_genes), integer(1))
    fg$leadingEdge_DE_genes <- vapply(
      fg$leadingEdge, function(g) paste(intersect(g, de_genes), collapse = ", "),
      FUN.VALUE = character(1)
    )
    fg$leadingEdge <- vapply(fg$leadingEdge, paste, collapse = ", ", FUN.VALUE = character(1))

    # Add metadata and store
    fg$Tissue     <- tissue
    fg$Comparison <- contrast_name
    gsea_results_main_model_males[[length(gsea_results_main_model_males) + 1]] <- fg

    # Per-contrast significant pathways view
    fg_sig <- fg[!is.na(fg$padj) & fg$padj < gsea_q_cutoff, ]
    if (nrow(fg_sig) > 0) {
      cat(sprintf("<details><summary><em>%s — Significant GSEA Pathways</em></summary>\n\n", contrast_name))
      cat(knitr::kable(
        fg_sig[, c("pathway","NES","pval","padj","size","leadingEdge_count","leadingEdge_DE_count","leadingEdge_DE_genes")],
        format = "html",
        table.attr = "class='table table-condensed table-bordered'"
      ))
      cat("</details>\n\n")
    } else {
      cat(sprintf("<p><em>%s — no pathways at FDR &lt; %.2f.</em></p>\n\n", contrast_name, gsea_q_cutoff))
    }
  }

  cat("</details>\n\n")
}

# ===========================
# Combine & summarize males-only GSEA
# ===========================
if (length(gsea_results_main_model_males) > 0) {
  gsea_summary_males <- do.call(rbind, gsea_results_main_model_males)
  gsea_summary_males <- gsea_summary_males[order(gsea_summary_males$padj), , drop = FALSE]

  gsea_sig_males <- subset(gsea_summary_males, !is.na(padj) & padj < gsea_q_cutoff)

  cat("<details><summary><strong>GSEA Summary (Males Only): Significant Pathways (FDR &lt; ",
      gsea_q_cutoff, ")</strong></summary>\n\n", sep = "")
  if (nrow(gsea_sig_males) > 0) {
    cat(knitr::kable(
      gsea_sig_males[, c("Tissue","Comparison","pathway","NES","pval","padj","size",
                         "leadingEdge_count","leadingEdge_DE_count","leadingEdge_DE_genes")],
      format = "html",
      table.attr = "class='table table-striped table-condensed'"
    ))
  } else {
    cat("<p><em>No significant pathways at the selected FDR across tissues (males only).</em></p>\n")
  }
  cat("</details>\n\n")

  # Save CSV (males only)
  if (nrow(gsea_sig_males) > 0) {
    # Replace commas to avoid CSV parsing issues
    gsea_sig_males$leadingEdge             <- gsub(",", ";", gsea_sig_males$leadingEdge, fixed = TRUE)
    gsea_sig_males$leadingEdge_DE_genes    <- gsub(",", ";", gsea_sig_males$leadingEdge_DE_genes, fixed = TRUE)

    write.csv(
      gsea_sig_males[, c("Tissue","Comparison","pathway","NES","pval","padj","size",
                         "leadingEdge_count","leadingEdge_DE_count","leadingEdge_DE_genes")],
      file = "GSEA_summary_significant_males.csv",
      row.names = FALSE
    )
  }
} else {
  cat("<p><em>No GSEA results were generated for males-only analysis.</em></p>\n")
}





```





### 4.3.1 Downstream Analyses with Pseudobulking and main effects model with interaction AgexInjury

```{r PseudobulkDEmainEffectsInteraction, echo=TRUE, results='asis', message=FALSE, warning=FALSE}

# Initialize list to collect results
summary_signif_genes_interaction_model <- list()

# Reduced interaction formula (drop Sex:Injury)
interaction_formula <- ~ Sex + Age + Injury + Age:Injury + Batch

for (tissue in names(gene_filtered_list)) {
  cat(sprintf("<details><summary><strong>%s — Age × Injury Interaction Model</strong></summary>\n\n", tissue))

  pb_counts <- if (use_filtered_counts) {
    pseudobulk_counts_list[[tissue]]
  } else {
    pseudobulk_counts_raw_list[[tissue]]
  }

  meta <- pseudobulk_meta_list[[tissue]]
  meta$Sex <- factor(meta$Sex, levels = c(0, 1))
  meta$Age <- factor(meta$Age, levels = c(0, 1))
  meta$Injury <- factor(meta$Injury, levels = c(0, 2, 3))
  meta$Batch <- factor(meta$Batch, levels = c(0, 1))

  # Pre-check for Age × Injury interaction
  if (
    nrow(meta) >= 6 &&
    length(unique(meta$Sex)) > 1 &&
    length(unique(meta$Age)) > 1 &&
    length(unique(meta$Injury)) > 1 &&
    length(unique(interaction(meta$Age, meta$Injury))) > 1
  ) {
    dds3_try <- try(DESeqDataSetFromMatrix(countData = as.matrix(pb_counts),
                                           colData = meta,
                                           design = interaction_formula),
                    silent = TRUE)

    if (inherits(dds3_try, "try-error")) {
      cat(sprintf("<p><em>Skipping %s — model matrix not full rank</em></p>\n", tissue))
      cat("</details>\n\n")
      next
    }

    dds3 <- dds3_try
    dds3 <- estimateSizeFactors(dds3, type = "poscounts")
    dds3 <- DESeq(dds3)

    # === Interaction terms ===
    interaction_contrasts <- list(
      "AgeInjury_DMM_vs_Naive" = list(name = "Age1.Injury3"),
      "AgeInjury_Sham_vs_Naive" = list(name = "Age1.Injury2"),
      "AgeInjury_DMM_vs_Sham"  = list(name = "Age1.Injury3") # duplicate, optionally remove
    )

    for (contrast_name in names(interaction_contrasts)) {
      contrast_info <- interaction_contrasts[[contrast_name]]
      if (!(contrast_info$name %in% resultsNames(dds3))) {
        cat(sprintf("<p><em>Skipping %s — %s not found in resultsNames().</em></p>\n", tissue, contrast_info$name))
        next
      }

      res <- results(dds3, name = contrast_info$name)
      res_df <- as.data.frame(res)
      res_df$gene <- rownames(res_df)
      res_df <- res_df[!is.na(res_df$pvalue), ]

      top_genes <- res_df %>%
        arrange(pvalue, desc(abs(log2FoldChange))) %>%
        filter(pvalue < 0.05) %>%
        head(20) %>%
        mutate(FC = 2^log2FoldChange) %>%
        select(gene, log2FoldChange, FC, pvalue, padj)

      if (nrow(top_genes) > 0) {
        summary_signif_genes_interaction_model[[length(summary_signif_genes_interaction_model) + 1]] <- data.frame(
          Tissue = tissue,
          Comparison = contrast_name,
          Gene = top_genes$gene,
          log2FC = top_genes$log2FoldChange,
          FC = top_genes$FC,
          pvalue = top_genes$pvalue,
          padj = top_genes$padj,
          stringsAsFactors = FALSE
        )
      }

      cat(sprintf("<details><summary><strong>%s — %s (Interaction)</strong></summary>\n\n", tissue, contrast_name))
      print(EnhancedVolcano(res_df,
                            lab = res_df$gene,
                            selectLab = top_genes$gene,
                            x = "log2FoldChange",
                            y = "pvalue",
                            pCutoff = 0.05,
                            FCcutoff = 1.0,
                            pointSize = 2.0,
                            labSize = 3.5,
                            title = paste(tissue, ":", contrast_name),
                            subtitle = "Age × Injury Interaction",
                            caption = paste("total =", nrow(res_df), "genes tested")))
      cat(kable(top_genes, format = "html", table.attr = "class='table table-condensed table-bordered'"))
      cat("</details>\n\n")
    }

    # === Main effects (from interaction model) ===
    main_effects_contrasts <- list(
      "Sex_Female_vs_Male" = c("Sex", "1", "0"),
      "Age_Aged_vs_Young" = c("Age", "1", "0"),
      "DMM_vs_Naive" = c("Injury", "3", "0"),
      "Sham_vs_Naive" = c("Injury", "2", "0"),
      "DMM_vs_Sham" = c("Injury", "3", "2")
    )

    for (contrast_name in names(main_effects_contrasts)) {
      res <- results(dds3, contrast = main_effects_contrasts[[contrast_name]])
      res_df <- as.data.frame(res)
      res_df$gene <- rownames(res_df)
      res_df <- res_df[!is.na(res_df$pvalue), ]

      top_genes <- res_df %>%
        arrange(pvalue, desc(abs(log2FoldChange))) %>%
        filter(pvalue < 0.05) %>%
        head(20) %>%
        mutate(FC = 2^log2FoldChange) %>%
        select(gene, log2FoldChange, FC, pvalue, padj)

      if (nrow(top_genes) > 0) {
        summary_signif_genes_interaction_model[[length(summary_signif_genes_interaction_model) + 1]] <- data.frame(
          Tissue = tissue,
          Comparison = contrast_name,
          Gene = top_genes$gene,
          log2FC = top_genes$log2FoldChange,
          FC = top_genes$FC,
          pvalue = top_genes$pvalue,
          padj = top_genes$padj,
          stringsAsFactors = FALSE
        )
      }

      cat(sprintf("<details><summary><strong>%s — %s (Main Effect)</strong></summary>\n\n", tissue, contrast_name))
      print(EnhancedVolcano(res_df,
                            lab = res_df$gene,
                            selectLab = top_genes$gene,
                            x = "log2FoldChange",
                            y = "pvalue",
                            pCutoff = 0.05,
                            FCcutoff = 1.0,
                            pointSize = 2.0,
                            labSize = 3.5,
                            title = paste(tissue, ":", contrast_name),
                            subtitle = "Main Effect from Interaction Model",
                            caption = paste("total =", nrow(res_df), "genes tested")))
      cat(kable(top_genes, format = "html", table.attr = "class='table table-condensed table-bordered'"))
      cat("</details>\n\n")
    }

  } else {
    cat(sprintf("<p><em>Skipping %s — insufficient variation for Age × Injury.</em></p>\n", tissue))
  }

  cat("</details>\n\n")
}

# Optional summary table
if (length(summary_signif_genes_interaction_model) > 0) {
  final_summary_table <- do.call(rbind, summary_signif_genes_interaction_model)

  cat("<details><summary><strong>Summary of Age × Injury Interaction Model Results (by Tissue)</strong></summary>\n\n")

  by_tissue <- split(final_summary_table, final_summary_table$Tissue)

  for (tissue_name in names(by_tissue)) {
    tissue_df <- by_tissue[[tissue_name]]
    cat(sprintf("<details><summary><strong>%s</strong></summary>\n\n", tissue_name))
    cat(kable(tissue_df, format = "html", table.attr = "class='table table-striped table-condensed'"))
    cat("</details>\n\n")
  }

  cat("</details>\n\n")
}

# Flat FDR < 0.2 summary
if (exists("summary_signif_genes_interaction_model") && length(summary_signif_genes_interaction_model) > 0) {
  interaction_summary <- do.call(rbind, summary_signif_genes_interaction_model)

  filtered_interaction <- interaction_summary[!is.na(interaction_summary$padj) & interaction_summary$padj < 0.2, ]

  if (nrow(filtered_interaction) > 0) {
    filtered_interaction$Tissue <- iconv(as.character(filtered_interaction$Tissue), from = "", to = "UTF-8", sub = "ASCII")
    filtered_interaction$Gene <- iconv(as.character(filtered_interaction$Gene), from = "", to = "UTF-8", sub = "ASCII")
    rownames(filtered_interaction) <- NULL

    cat("<details><summary><strong>Flat Summary: Interaction Model — Genes with FDR < 0.2</strong></summary>\n\n")
    cat(kable(filtered_interaction, format = "html", table.attr = "class='table table-striped table-condensed'"))
    cat("</details>\n\n")
  } else {
    cat("<p><em>No genes with FDR < 0.2 found in interaction model.</em></p>\n")
  }
} else {
  cat("<p><em>No interaction model results available.</em></p>\n")
}


```



### 4.3.1.1 Downstream Analyses with Pseudobulking and main effects model with interaction AgexInjury (Males Only)


```{r PseudobulkDEmainEffectsInteraction_MalesOnly, echo=TRUE, results='asis', message=FALSE, warning=FALSE}

# Initialize list to collect results
summary_signif_genes_interaction_model <- list()

# Formula for males only (Sex removed)
interaction_formula <- ~ Age + Injury + Age:Injury + Batch

for (tissue in names(gene_filtered_list)) {
  cat(sprintf("<details><summary><strong>%s — Age × Injury Interaction Model (Males Only)</strong></summary>\n\n", tissue))

  pb_counts <- if (use_filtered_counts) {
    pseudobulk_counts_list[[tissue]]
  } else {
    pseudobulk_counts_raw_list[[tissue]]
  }

  meta <- pseudobulk_meta_list[[tissue]]

  # Subset to males only
  keep <- meta$Sex == 0
  meta <- meta[keep, ]
  pb_counts <- pb_counts[, keep]

  # Ensure factors
  meta$Age <- factor(meta$Age, levels = c(0, 1))
  meta$Injury <- factor(meta$Injury, levels = c(0, 2, 3))
  if (!"Batch" %in% colnames(meta)) meta$Batch <- NA
  meta$Batch <- factor(meta$Batch, levels = c(0, 1))

  # Check if model can be fit
  if (
    nrow(meta) >= 6 &&
    length(unique(meta$Age)) > 1 &&
    length(unique(meta$Injury)) > 1 &&
    length(unique(interaction(meta$Age, meta$Injury))) > 1
  ) {
    dds_try <- try(DESeqDataSetFromMatrix(countData = as.matrix(pb_counts),
                                          colData = meta,
                                          design = interaction_formula),
                   silent = TRUE)

    if (inherits(dds_try, "try-error")) {
      cat(sprintf("<p><em>Skipping %s — model matrix not full rank</em></p>\n", tissue))
      cat("</details>\n\n")
      next
    }

    dds <- dds_try
    dds <- estimateSizeFactors(dds, type = "poscounts")
    dds <- DESeq(dds)

    # === Interaction contrasts ===
    interaction_contrasts <- list(
      "AgeInjury_DMM_vs_Naive" = list(name = "Age1.Injury3"),
      "AgeInjury_Sham_vs_Naive" = list(name = "Age1.Injury2"),
      "AgeInjury_DMM_vs_Sham"  = list(name = "Age1.Injury3")  # optional duplicate
    )

    for (contrast_name in names(interaction_contrasts)) {
      contrast_info <- interaction_contrasts[[contrast_name]]
      if (!(contrast_info$name %in% resultsNames(dds))) {
        cat(sprintf("<p><em>Skipping %s — %s not found in resultsNames().</em></p>\n", tissue, contrast_info$name))
        next
      }

      res <- results(dds, name = contrast_info$name)
      res_df <- as.data.frame(res)
      res_df$gene <- rownames(res_df)
      res_df <- res_df[!is.na(res_df$pvalue), ]

      top_genes <- res_df %>%
        arrange(pvalue, desc(abs(log2FoldChange))) %>%
        filter(pvalue < 0.05) %>%
        head(20) %>%
        mutate(FC = 2^log2FoldChange) %>%
        select(gene, log2FoldChange, FC, pvalue, padj)

      if (nrow(top_genes) > 0) {
        summary_signif_genes_interaction_model[[length(summary_signif_genes_interaction_model) + 1]] <- data.frame(
          Tissue = tissue,
          Comparison = contrast_name,
          Gene = top_genes$gene,
          log2FC = top_genes$log2FoldChange,
          FC = top_genes$FC,
          pvalue = top_genes$pvalue,
          padj = top_genes$padj,
          stringsAsFactors = FALSE
        )
      }

      cat(sprintf("<details><summary><strong>%s — %s (Interaction)</strong></summary>\n\n", tissue, contrast_name))
      print(EnhancedVolcano(res_df,
                            lab = res_df$gene,
                            selectLab = top_genes$gene,
                            x = "log2FoldChange",
                            y = "pvalue",
                            pCutoff = 0.05,
                            FCcutoff = 1.0,
                            pointSize = 2.0,
                            labSize = 3.5,
                            title = paste(tissue, ":", contrast_name),
                            subtitle = "Age × Injury Interaction (Males Only)",
                            caption = paste("total =", nrow(res_df), "genes tested")))
      cat(kable(top_genes, format = "html", table.attr = "class='table table-condensed table-bordered'"))
      cat("</details>\n\n")
    }

    # === Main effects (Age, Injury) — from interaction model ===
    main_effects_contrasts <- list(
      "Age_Aged_vs_Young" = c("Age", "1", "0"),
      "DMM_vs_Naive"      = c("Injury", "3", "0"),
      "Sham_vs_Naive"     = c("Injury", "2", "0"),
      "DMM_vs_Sham"       = c("Injury", "3", "2")
    )

    for (contrast_name in names(main_effects_contrasts)) {
      res <- results(dds, contrast = main_effects_contrasts[[contrast_name]])
      res_df <- as.data.frame(res)
      res_df$gene <- rownames(res_df)
      res_df <- res_df[!is.na(res_df$pvalue), ]

      top_genes <- res_df %>%
        arrange(pvalue, desc(abs(log2FoldChange))) %>%
        filter(pvalue < 0.05) %>%
        head(20) %>%
        mutate(FC = 2^log2FoldChange) %>%
        select(gene, log2FoldChange, FC, pvalue, padj)

      if (nrow(top_genes) > 0) {
        summary_signif_genes_interaction_model[[length(summary_signif_genes_interaction_model) + 1]] <- data.frame(
          Tissue = tissue,
          Comparison = contrast_name,
          Gene = top_genes$gene,
          log2FC = top_genes$log2FoldChange,
          FC = top_genes$FC,
          pvalue = top_genes$pvalue,
          padj = top_genes$padj,
          stringsAsFactors = FALSE
        )
      }

      cat(sprintf("<details><summary><strong>%s — %s (Main Effect)</strong></summary>\n\n", tissue, contrast_name))
      print(EnhancedVolcano(res_df,
                            lab = res_df$gene,
                            selectLab = top_genes$gene,
                            x = "log2FoldChange",
                            y = "pvalue",
                            pCutoff = 0.05,
                            FCcutoff = 1.0,
                            pointSize = 2.0,
                            labSize = 3.5,
                            title = paste(tissue, ":", contrast_name),
                            subtitle = "Main Effect from Interaction Model (Males Only)",
                            caption = paste("total =", nrow(res_df), "genes tested")))
      cat(kable(top_genes, format = "html", table.attr = "class='table table-condensed table-bordered'"))
      cat("</details>\n\n")
    }

  } else {
    cat(sprintf("<p><em>Skipping %s — insufficient variation for Age × Injury (males only).</em></p>\n", tissue))
  }

  cat("</details>\n\n")
}

# Summary by tissue
if (length(summary_signif_genes_interaction_model) > 0) {
  final_summary_table <- do.call(rbind, summary_signif_genes_interaction_model)

  cat("<details><summary><strong>Summary of Age × Injury Interaction Model (Males Only)</strong></summary>\n\n")
  by_tissue <- split(final_summary_table, final_summary_table$Tissue)

  for (tissue_name in names(by_tissue)) {
    tissue_df <- by_tissue[[tissue_name]]
    cat(sprintf("<details><summary><strong>%s</strong></summary>\n\n", tissue_name))
    cat(kable(tissue_df, format = "html", table.attr = "class='table table-striped table-condensed'"))
    cat("</details>\n\n")
  }

  cat("</details>\n\n")
}

# Flat summary: FDR < 0.2
if (length(summary_signif_genes_interaction_model) > 0) {
  interaction_summary <- do.call(rbind, summary_signif_genes_interaction_model)
  filtered <- interaction_summary[!is.na(interaction_summary$padj) & interaction_summary$padj < 0.2, ]

  if (nrow(filtered) > 0) {
    filtered$Tissue <- iconv(as.character(filtered$Tissue), from = "", to = "UTF-8", sub = "ASCII")
    filtered$Gene <- iconv(as.character(filtered$Gene), from = "", to = "UTF-8", sub = "ASCII")
    rownames(filtered) <- NULL

    cat("<details><summary><strong>Flat Summary: Age × Injury (Males Only, FDR < 0.2)</strong></summary>\n\n")
    cat(kable(filtered, format = "html", table.attr = "class='table table-striped table-condensed'"))
    cat("</details>\n\n")
  } else {
    cat("<p><em>No genes with FDR < 0.2 found in interaction model (males only).</em></p>\n")
  }
} else {
  cat("<p><em>No interaction model results available (males only).</em></p>\n")
}


```





### 4.3.2 Downstream Analyses with Pseudobulking and main effects model with interaction SexxInjury

```{r PseudobulkDEmainEffectsInteraction2, echo=TRUE, results='asis', message=FALSE, warning=FALSE}

# Initialize list to collect results
summary_signif_genes_sexinjury_model <- list()

# Interaction formula with Sex × Injury
sex_injury_formula <- ~ Sex + Age + Injury + Sex:Injury + Batch

for (tissue in names(gene_filtered_list)) {
  cat(sprintf("<details><summary><strong>%s — Sex × Injury Interaction Model</strong></summary>\n\n", tissue))

  pb_counts <- if (use_filtered_counts) {
    pseudobulk_counts_list[[tissue]]
  } else {
    pseudobulk_counts_raw_list[[tissue]]
  }

  meta <- pseudobulk_meta_list[[tissue]]

  # Subset to Naive and DMM
  keep <- meta$Injury %in% c(0, 3)
  meta_si <- meta[keep, ]
  pb_counts_si <- pb_counts[, keep]

  # Re-factor levels
  meta_si$Sex <- factor(meta_si$Sex, levels = c(0, 1))
  meta_si$Age <- factor(meta_si$Age, levels = c(0, 1))
  meta_si$Injury <- factor(meta_si$Injury, levels = c(0, 3))
  meta_si$Batch <- factor(meta_si$Batch, levels = c(0, 1))

  if (
    nrow(meta_si) >= 6 &&
    length(unique(meta_si$Sex)) > 1 &&
    length(unique(meta_si$Injury)) > 1 &&
    length(unique(interaction(meta_si$Sex, meta_si$Injury))) > 1
  ) {
    dds_si_try <- try(DESeqDataSetFromMatrix(countData = as.matrix(pb_counts_si),
                                             colData = meta_si,
                                             design = sex_injury_formula),
                      silent = TRUE)

    if (inherits(dds_si_try, "try-error")) {
      cat(sprintf("<p><em>Skipping %s — model matrix not full rank</em></p>\n", tissue))
      cat("</details>\n\n")
      next
    }

    dds_si <- dds_si_try
    dds_si <- estimateSizeFactors(dds_si, type = "poscounts")
    dds_si <- DESeq(dds_si)

    # === Interaction term ===
    interaction_name <- "Sex1.Injury3"
    if (interaction_name %in% resultsNames(dds_si)) {
      res <- results(dds_si, name = interaction_name)
      res_df <- as.data.frame(res)
      res_df$gene <- rownames(res_df)
      res_df <- res_df[!is.na(res_df$pvalue), ]

      top_genes <- res_df %>%
        arrange(pvalue, desc(abs(log2FoldChange))) %>%
        filter(pvalue < 0.05) %>%
        head(20) %>%
        mutate(FC = 2^log2FoldChange) %>%
        select(gene, log2FoldChange, FC, pvalue, padj)

      if (nrow(top_genes) > 0) {
        summary_signif_genes_sexinjury_model[[length(summary_signif_genes_sexinjury_model) + 1]] <- data.frame(
          Tissue = tissue,
          Comparison = "SexInjury_DMM_vs_Naive",
          Gene = top_genes$gene,
          log2FC = top_genes$log2FoldChange,
          FC = top_genes$FC,
          pvalue = top_genes$pvalue,
          padj = top_genes$padj,
          stringsAsFactors = FALSE
        )
      }

      cat(sprintf("<details><summary><strong>%s — Sex × Injury (DMM vs Naive)</strong></summary>\n\n", tissue))
      print(EnhancedVolcano(res_df,
                            lab = res_df$gene,
                            selectLab = top_genes$gene,
                            x = "log2FoldChange",
                            y = "pvalue",
                            pCutoff = 0.05,
                            FCcutoff = 1.0,
                            pointSize = 2.0,
                            labSize = 3.5,
                            title = paste(tissue, ": Sex × Injury"),
                            subtitle = "Interaction: Sex × Injury (DMM vs Naive)",
                            caption = paste("total =", nrow(res_df), "genes tested")))
      cat(kable(top_genes, format = "html", table.attr = "class='table table-condensed table-bordered'"))
      cat("</details>\n\n")
    } else {
      cat(sprintf("<p><em>Skipping %s — %s not found in resultsNames().</em></p>\n", tissue, interaction_name))
    }

    # === Main effects (no sham) ===
    main_contrasts <- list(
      "Sex_Female_vs_Male" = c("Sex", "1", "0"),
      "Age_Aged_vs_Young"  = c("Age", "1", "0"),
      "DMM_vs_Naive"       = c("Injury", "3", "0")
    )

    for (contrast_name in names(main_contrasts)) {
      res <- results(dds_si, contrast = main_contrasts[[contrast_name]])
      res_df <- as.data.frame(res)
      res_df$gene <- rownames(res_df)
      res_df <- res_df[!is.na(res_df$pvalue), ]

      top_genes <- res_df %>%
        arrange(pvalue, desc(abs(log2FoldChange))) %>%
        filter(pvalue < 0.05) %>%
        head(20) %>%
        mutate(FC = 2^log2FoldChange) %>%
        select(gene, log2FoldChange, FC, pvalue, padj)

      if (nrow(top_genes) > 0) {
        summary_signif_genes_sexinjury_model[[length(summary_signif_genes_sexinjury_model) + 1]] <- data.frame(
          Tissue = tissue,
          Comparison = contrast_name,
          Gene = top_genes$gene,
          log2FC = top_genes$log2FoldChange,
          FC = top_genes$FC,
          pvalue = top_genes$pvalue,
          padj = top_genes$padj,
          stringsAsFactors = FALSE
        )
      }

      cat(sprintf("<details><summary><strong>%s — %s (Main Effect)</strong></summary>\n\n", tissue, contrast_name))
      print(EnhancedVolcano(res_df,
                            lab = res_df$gene,
                            selectLab = top_genes$gene,
                            x = "log2FoldChange",
                            y = "pvalue",
                            pCutoff = 0.05,
                            FCcutoff = 1.0,
                            pointSize = 2.0,
                            labSize = 3.5,
                            title = paste(tissue, ":", contrast_name),
                            subtitle = "Main Effect from Sex × Injury Model",
                            caption = paste("total =", nrow(res_df), "genes tested")))
      cat(kable(top_genes, format = "html", table.attr = "class='table table-condensed table-bordered'"))
      cat("</details>\n\n")
    }

  } else {
    cat(sprintf("<p><em>Skipping %s — insufficient variation for Sex × Injury.</em></p>\n", tissue))
  }

  cat("</details>\n\n")
}

# Summary by Tissue
if (length(summary_signif_genes_sexinjury_model) > 0) {
  final_summary_table <- do.call(rbind, summary_signif_genes_sexinjury_model)

  cat("<details><summary><strong>Summary of Sex × Injury Model Results (by Tissue)</strong></summary>\n\n")
  by_tissue <- split(final_summary_table, final_summary_table$Tissue)

  for (tissue_name in names(by_tissue)) {
    tissue_df <- by_tissue[[tissue_name]]
    cat(sprintf("<details><summary><strong>%s</strong></summary>\n\n", tissue_name))
    cat(kable(tissue_df, format = "html", table.attr = "class='table table-striped table-condensed'"))
    cat("</details>\n\n")
  }

  cat("</details>\n\n")
}

# Flat Summary: FDR < 0.2
if (length(summary_signif_genes_sexinjury_model) > 0) {
  interaction_summary <- do.call(rbind, summary_signif_genes_sexinjury_model)
  filtered_interaction <- interaction_summary[!is.na(interaction_summary$padj) & interaction_summary$padj < 0.2, ]

  if (nrow(filtered_interaction) > 0) {
    filtered_interaction$Tissue <- iconv(as.character(filtered_interaction$Tissue), from = "", to = "UTF-8", sub = "ASCII")
    filtered_interaction$Gene <- iconv(as.character(filtered_interaction$Gene), from = "", to = "UTF-8", sub = "ASCII")
    rownames(filtered_interaction) <- NULL

    cat("<details><summary><strong>Flat Summary: Sex × Injury — Genes with FDR < 0.2</strong></summary>\n\n")
    cat(kable(filtered_interaction, format = "html", table.attr = "class='table table-striped table-condensed'"))
    cat("</details>\n\n")
  } else {
    cat("<p><em>No genes with FDR < 0.2 found in Sex × Injury model.</em></p>\n")
  }
} else {
  cat("<p><em>No Sex × Injury model results available.</em></p>\n")
}



```


#### 4.3.2.1 Downstream Analyses with Pseudobulking and Main Effects Model (young mice Only)

```{r PseudobulkDEmainEffects_youngOnly, echo=TRUE, results='asis', message=FALSE, warning=FALSE}

# Initialize list to collect results
summary_signif_genes_sexinjury_model <- list()

# Interaction formula with Sex × Injury
main_effects_formula <- ~ Sex + Injury + Batch

for (tissue in names(gene_filtered_list)) {
  cat(sprintf("<details><summary><strong>%s — Main Effects Model (No Aged Males)</strong></summary>\n\n", tissue))

  pb_counts <- if (use_filtered_counts) {
    pseudobulk_counts_list[[tissue]]
  } else {
    pseudobulk_counts_raw_list[[tissue]]
  }

  meta <- pseudobulk_meta_list[[tissue]]

  # Subset to Naive and DMM and exclude aged males (Sex = 0 & Age = 1)
  keep <- !(meta$Sex == 0 & meta$Age == 1)
  meta_si <- meta[keep, ]
  pb_counts_si <- pb_counts[, keep]

  # Re-factor levels
  meta_si$Sex <- factor(meta_si$Sex, levels = c(0, 1))
  meta_si$Injury <- factor(meta_si$Injury, levels = c(0, 3))
  meta_si$Batch <- factor(meta_si$Batch, levels = c(0, 1))

  if (
    nrow(meta_si) >= 6 &&
    length(unique(meta_si$Sex)) > 1 &&
    length(unique(meta_si$Injury)) > 1 &&
    length(unique(interaction(meta_si$Sex, meta_si$Injury))) > 1
  ) {
    dds_si_try <- try(DESeqDataSetFromMatrix(countData = as.matrix(pb_counts_si),
                                             colData = meta_si,
                                             design = main_effects_formula),
                      silent = TRUE)

    if (inherits(dds_si_try, "try-error")) {
      cat(sprintf("<p><em>Skipping %s — model matrix not full rank</em></p>\n", tissue))
      cat("</details>\n\n")
      next
    }

    dds_si <- dds_si_try
    dds_si <- estimateSizeFactors(dds_si, type = "poscounts")
    dds_si <- DESeq(dds_si)

    # === Main effects (no sham) ===
    main_contrasts <- list(
      "Sex_Female_vs_Male" = c("Sex", "1", "0"),
      "DMM_vs_Naive"       = c("Injury", "3", "0")
    )

    for (contrast_name in names(main_contrasts)) {
      res <- results(dds_si, contrast = main_contrasts[[contrast_name]])
      res_df <- as.data.frame(res)
      res_df$gene <- rownames(res_df)
      res_df <- res_df[!is.na(res_df$pvalue), ]

      top_genes <- res_df %>%
        arrange(pvalue, desc(abs(log2FoldChange))) %>%
        filter(pvalue < 0.05) %>%
        head(20) %>%
        mutate(FC = 2^log2FoldChange) %>%
        select(gene, log2FoldChange, FC, pvalue, padj)

      if (nrow(top_genes) > 0) {
        summary_signif_genes_sexinjury_model[[length(summary_signif_genes_sexinjury_model) + 1]] <- data.frame(
          Tissue = tissue,
          Comparison = contrast_name,
          Gene = top_genes$gene,
          log2FC = top_genes$log2FoldChange,
          FC = top_genes$FC,
          pvalue = top_genes$pvalue,
          padj = top_genes$padj,
          stringsAsFactors = FALSE
        )
      }

      cat(sprintf("<details><summary><strong>%s — %s (Main Effect)</strong></summary>\n\n", tissue, contrast_name))
      print(EnhancedVolcano(res_df,
                            lab = res_df$gene,
                            selectLab = top_genes$gene,
                            x = "log2FoldChange",
                            y = "pvalue",
                            pCutoff = 0.05,
                            FCcutoff = 1.0,
                            pointSize = 2.0,
                            labSize = 3.5,
                            title = paste(tissue, ":", contrast_name),
                            subtitle = "Main Effect from main effect Model",
                            caption = paste("total =", nrow(res_df), "genes tested")))
      cat(kable(top_genes, format = "html", table.attr = "class='table table-condensed table-bordered'"))
      cat("</details>\n\n")
    }

  } else {
    cat(sprintf("<p><em>Skipping %s — insufficient variation for main effect model.</em></p>\n", tissue))
  }

  cat("</details>\n\n")
}

# Summary by Tissue
if (length(summary_signif_genes_sexinjury_model) > 0) {
  final_summary_table <- do.call(rbind, summary_signif_genes_sexinjury_model)

  cat("<details><summary><strong>Summary of Main Effects Model Results (by Tissue)</strong></summary>\n\n")
  by_tissue <- split(final_summary_table, final_summary_table$Tissue)

  for (tissue_name in names(by_tissue)) {
    tissue_df <- by_tissue[[tissue_name]]
    cat(sprintf("<details><summary><strong>%s</strong></summary>\n\n", tissue_name))
    cat(kable(tissue_df, format = "html", table.attr = "class='table table-striped table-condensed'"))
    cat("</details>\n\n")
  }

  cat("</details>\n\n")
}

# Flat Summary: FDR < 0.2
if (length(summary_signif_genes_sexinjury_model) > 0) {
  interaction_summary <- do.call(rbind, summary_signif_genes_sexinjury_model)
  filtered_interaction <- interaction_summary[!is.na(interaction_summary$padj) & interaction_summary$padj < 0.2, ]

  if (nrow(filtered_interaction) > 0) {
    filtered_interaction$Tissue <- iconv(as.character(filtered_interaction$Tissue), from = "", to = "UTF-8", sub = "ASCII")
    filtered_interaction$Gene <- iconv(as.character(filtered_interaction$Gene), from = "", to = "UTF-8", sub = "ASCII")
    rownames(filtered_interaction) <- NULL

    cat("<details><summary><strong>Flat Summary: main effect model — Genes with FDR < 0.2</strong></summary>\n\n")
    cat(kable(filtered_interaction, format = "html", table.attr = "class='table table-striped table-condensed'"))
    cat("</details>\n\n")
  } else {
    cat("<p><em>No genes with FDR < 0.2 found in main effect model.</em></p>\n")
  }
} else {
  cat("<p><em>No main effect model results available.</em></p>\n")
}




# ===========================
# GSEA — Male Main Effect (No Aged Males, Naive vs DMM only)
# ===========================

# Safe defaults (won't overwrite if already set earlier)
gsea_mode        <- get0("gsea_mode",        ifnotfound = "fast")     # "fast" or "accurate"
gsea_nperm_fast  <- get0("gsea_nperm_fast",  ifnotfound = 5000)
gsea_q_cutoff    <- get0("gsea_q_cutoff",    ifnotfound = 0.20)
gsea_min_size    <- get0("gsea_min_size",    ifnotfound = 10)
gsea_max_size    <- get0("gsea_max_size",    ifnotfound = 500)

if (!exists("pathways_mouse")) stop("pathways_mouse not found. Load msigdbr and build it first.")

set.seed(123)

gsea_results_no_aged_males <- list()

for (tissue in names(gene_filtered_list)) {
  cat(sprintf("<details><summary><strong>%s — GSEA (Male Main Effect, No Aged Males)</strong></summary>\n\n", tissue))

  # Choose pseudobulk counts
  pb_counts <- if (isTRUE(use_filtered_counts)) {
    pseudobulk_counts_list[[tissue]]
  } else {
    pseudobulk_counts_raw_list[[tissue]]
  }
  meta <- pseudobulk_meta_list[[tissue]]

  # Filter: drop aged males AND Sham (2)
  keep <- !(meta$Sex == 0 & meta$Age == 1) & meta$Injury %in% c(0, 3)
  meta_si <- droplevels(meta[keep, , drop = FALSE])
  pb_counts_si <- pb_counts[, keep, drop = FALSE]

  # Re-factor levels to expected set
  meta_si$Sex    <- factor(meta_si$Sex,    levels = c(0, 1))  # 0=Female, 1=Male
  meta_si$Injury <- factor(meta_si$Injury, levels = c(0, 3))  # 0=Naive, 3=DMM
  meta_si$Batch  <- factor(meta_si$Batch,  levels = c(0, 1))

  # Only fit if both sexes and both injury groups are present
  if (
    nrow(meta_si) >= 6 &&
    length(unique(meta_si$Sex)) > 1 &&
    length(unique(meta_si$Injury)) > 1
  ) {
    dds_si_try <- try(
      DESeq2::DESeqDataSetFromMatrix(
        countData = as.matrix(pb_counts_si),
        colData   = meta_si,
        design    = ~ Sex + Injury + Batch
      ),
      silent = TRUE
    )

    if (inherits(dds_si_try, "try-error")) {
      cat("<p><em>Skipping — model matrix not full rank (likely due to complete confounding).</em></p>\n")
      cat("</details>\n\n")
      next
    }

    dds_si <- DESeq2::estimateSizeFactors(dds_si_try, type = "poscounts")
    dds_si <- DESeq2::DESeq(dds_si)

    # Main effect: Male vs Female
    res <- DESeq2::results(dds_si, contrast = c("Sex", "1", "0"))
    res_df <- as.data.frame(res)
    res_df$gene <- rownames(res_df)
    res_df <- res_df[!is.na(res_df$pvalue), , drop = FALSE]

    # Rank genes by Wald stat (or compute signed z if missing)
    if (!("stat" %in% names(res_df))) {
      res_df$stat <- sign(res_df$log2FoldChange) *
        qnorm(pmax(pmin(res_df$pvalue, 1 - 1e-16), 1e-300), lower.tail = FALSE)
    }

    ranked_genes <- setNames(res_df$stat, res_df$gene)
    ranked_genes <- ranked_genes[!is.na(ranked_genes)]
    ranked_genes <- sort(ranked_genes, decreasing = TRUE)

    # Run fgsea
    fg <- if (identical(gsea_mode, "fast")) {
      fgsea::fgsea(
        pathways = pathways_mouse,
        stats    = ranked_genes,
        minSize  = gsea_min_size,
        maxSize  = gsea_max_size,
        nperm    = gsea_nperm_fast
      )
    } else {
      fgsea::fgseaMultilevel(
        pathways = pathways_mouse,
        stats    = ranked_genes,
        minSize  = gsea_min_size,
        maxSize  = gsea_max_size
      )
    }
    fg <- as.data.frame(fg)

    # DE gene list for overlap
    de_genes <- res_df$gene[!is.na(res_df$padj) & res_df$padj < 0.20]

    fg$leadingEdge_count    <- vapply(fg$leadingEdge, length, integer(1))
    fg$leadingEdge_DE_count <- vapply(fg$leadingEdge, function(g) sum(g %in% de_genes), integer(1))
    fg$leadingEdge_DE_genes <- vapply(
      fg$leadingEdge, function(g) paste(intersect(g, de_genes), collapse = ", "),
      FUN.VALUE = character(1)
    )
    fg$leadingEdge <- vapply(fg$leadingEdge, paste, collapse = ", ", FUN.VALUE = character(1))

    fg$Tissue     <- tissue
    fg$Comparison <- "Male_vs_Female"
    fg$Model      <- "Male Main Effect (No Aged Males, Naive vs DMM)"

    gsea_results_no_aged_males[[length(gsea_results_no_aged_males) + 1]] <- fg

    # Report significant pathways
    fg_sig <- fg[!is.na(fg$padj) & fg$padj < gsea_q_cutoff, ]
    if (nrow(fg_sig) > 0) {
      cat("<details><summary><em>Significant GSEA Pathways (Male Main Effect)</em></summary>\n\n")
      cat(knitr::kable(
        fg_sig[, c("pathway","NES","pval","padj","size",
                   "leadingEdge_count","leadingEdge_DE_count","leadingEdge_DE_genes")],
        format = "html",
        table.attr = "class='table table-condensed table-bordered'"
      ))
      cat("</details>\n\n")
    } else {
      cat(sprintf("<p><em>No pathways at FDR &lt; %.2f.</em></p>\n\n", gsea_q_cutoff))
    }

  } else {
    cat("<p><em>Skipping — insufficient variation for male main effect model.</em></p>\n")
  }

  cat("</details>\n\n")
}

# ===========================
# Combine & summarize
# ===========================
if (length(gsea_results_no_aged_males) > 0) {
  gsea_summary_no_aged_males <- do.call(rbind, gsea_results_no_aged_males)
  gsea_summary_no_aged_males <- gsea_summary_no_aged_males[order(gsea_summary_no_aged_males$padj), , drop = FALSE]

  gsea_sig_no_aged_males <- subset(gsea_summary_no_aged_males, !is.na(padj) & padj < gsea_q_cutoff)

  cat("<details><summary><strong>GSEA Summary (Male Main Effect, No Aged Males)</strong></summary>\n\n")
  if (nrow(gsea_sig_no_aged_males) > 0) {
    cat(knitr::kable(
      gsea_sig_no_aged_males[, c("Model","Tissue","Comparison","pathway","NES","pval","padj","size",
                                 "leadingEdge_count","leadingEdge_DE_count","leadingEdge_DE_genes")],
      format = "html",
      table.attr = "class='table table-striped table-condensed'"
    ))
  } else {
    cat("<p><em>No significant pathways at the selected FDR.</em></p>\n")
  }
  cat("</details>\n\n")

  # Save CSV
  if (nrow(gsea_sig_no_aged_males) > 0) {
    gsea_sig_no_aged_males$leadingEdge          <- gsub(",", ";", gsea_sig_no_aged_males$leadingEdge, fixed = TRUE)
    gsea_sig_no_aged_males$leadingEdge_DE_genes <- gsub(",", ";", gsea_sig_no_aged_males$leadingEdge_DE_genes, fixed = TRUE)

    write.csv(
      gsea_sig_no_aged_males[, c("Model","Tissue","Comparison","pathway","NES","pval","padj","size",
                                 "leadingEdge_count","leadingEdge_DE_count","leadingEdge_DE_genes")],
      file = "GSEA_summary_significant_male_main_effect_no_aged_males.csv",
      row.names = FALSE
    )
  }
} else {
  cat("<p><em>No GSEA results generated for Male Main Effect (No Aged Males).</em></p>\n")
}



```




#### 4.3.2.2 Downstream Analyses with Pseudobulking and main effects model with interaction SexxInjury (young mice only)

```{r PseudobulkDEmainEffectsInteractionyoung, echo=TRUE, results='asis', message=FALSE, warning=FALSE}

# Initialize list to collect results
summary_signif_genes_sexinjury_model <- list()

# Interaction formula with Sex × Injury
sex_injury_formula <- ~ Sex + Injury + Sex:Injury + Batch

for (tissue in names(gene_filtered_list)) {
  cat(sprintf("<details><summary><strong>%s — Sex × Injury Interaction Model</strong></summary>\n\n", tissue))

  pb_counts <- if (use_filtered_counts) {
    pseudobulk_counts_list[[tissue]]
  } else {
    pseudobulk_counts_raw_list[[tissue]]
  }

  meta <- pseudobulk_meta_list[[tissue]]

  # Subset to Naive and DMM and exclude aged males (Sex = 0 & Age = 1)
  keep <- meta$Injury %in% c(0, 3) & !(meta$Sex == 0 & meta$Age == 1)
  meta_si <- meta[keep, ]
  pb_counts_si <- pb_counts[, keep]

  # Re-factor levels
  meta_si$Sex <- factor(meta_si$Sex, levels = c(0, 1))
  meta_si$Injury <- factor(meta_si$Injury, levels = c(0, 3))
  meta_si$Batch <- factor(meta_si$Batch, levels = c(0, 1))

  if (
    nrow(meta_si) >= 6 &&
    length(unique(meta_si$Sex)) > 1 &&
    length(unique(meta_si$Injury)) > 1 &&
    length(unique(interaction(meta_si$Sex, meta_si$Injury))) > 1
  ) {
    dds_si_try <- try(DESeqDataSetFromMatrix(countData = as.matrix(pb_counts_si),
                                             colData = meta_si,
                                             design = sex_injury_formula),
                      silent = TRUE)

    if (inherits(dds_si_try, "try-error")) {
      cat(sprintf("<p><em>Skipping %s — model matrix not full rank</em></p>\n", tissue))
      cat("</details>\n\n")
      next
    }

    dds_si <- dds_si_try
    dds_si <- estimateSizeFactors(dds_si, type = "poscounts")
    dds_si <- DESeq(dds_si)

    # === Interaction term ===
    interaction_name <- "Sex1.Injury3"
    if (interaction_name %in% resultsNames(dds_si)) {
      res <- results(dds_si, name = interaction_name)
      res_df <- as.data.frame(res)
      res_df$gene <- rownames(res_df)
      res_df <- res_df[!is.na(res_df$pvalue), ]

      top_genes <- res_df %>%
        arrange(pvalue, desc(abs(log2FoldChange))) %>%
        filter(pvalue < 0.05) %>%
        head(20) %>%
        mutate(FC = 2^log2FoldChange) %>%
        select(gene, log2FoldChange, FC, pvalue, padj)

      if (nrow(top_genes) > 0) {
        summary_signif_genes_sexinjury_model[[length(summary_signif_genes_sexinjury_model) + 1]] <- data.frame(
          Tissue = tissue,
          Comparison = "SexInjury_DMM_vs_Naive",
          Gene = top_genes$gene,
          log2FC = top_genes$log2FoldChange,
          FC = top_genes$FC,
          pvalue = top_genes$pvalue,
          padj = top_genes$padj,
          stringsAsFactors = FALSE
        )
      }

      cat(sprintf("<details><summary><strong>%s — Sex × Injury (DMM vs Naive)</strong></summary>\n\n", tissue))
      print(EnhancedVolcano(res_df,
                            lab = res_df$gene,
                            selectLab = top_genes$gene,
                            x = "log2FoldChange",
                            y = "pvalue",
                            pCutoff = 0.05,
                            FCcutoff = 1.0,
                            pointSize = 2.0,
                            labSize = 3.5,
                            title = paste(tissue, ": Sex × Injury"),
                            subtitle = "Interaction: Sex × Injury (DMM vs Naive)",
                            caption = paste("total =", nrow(res_df), "genes tested")))
      cat(kable(top_genes, format = "html", table.attr = "class='table table-condensed table-bordered'"))
      cat("</details>\n\n")
    } else {
      cat(sprintf("<p><em>Skipping %s — %s not found in resultsNames().</em></p>\n", tissue, interaction_name))
    }

    # === Main effects (no sham) ===
    main_contrasts <- list(
      "Sex_Female_vs_Male" = c("Sex", "1", "0"),
      "DMM_vs_Naive"       = c("Injury", "3", "0")
    )

    for (contrast_name in names(main_contrasts)) {
      res <- results(dds_si, contrast = main_contrasts[[contrast_name]])
      res_df <- as.data.frame(res)
      res_df$gene <- rownames(res_df)
      res_df <- res_df[!is.na(res_df$pvalue), ]

      top_genes <- res_df %>%
        arrange(pvalue, desc(abs(log2FoldChange))) %>%
        filter(pvalue < 0.05) %>%
        head(20) %>%
        mutate(FC = 2^log2FoldChange) %>%
        select(gene, log2FoldChange, FC, pvalue, padj)

      if (nrow(top_genes) > 0) {
        summary_signif_genes_sexinjury_model[[length(summary_signif_genes_sexinjury_model) + 1]] <- data.frame(
          Tissue = tissue,
          Comparison = contrast_name,
          Gene = top_genes$gene,
          log2FC = top_genes$log2FoldChange,
          FC = top_genes$FC,
          pvalue = top_genes$pvalue,
          padj = top_genes$padj,
          stringsAsFactors = FALSE
        )
      }

      cat(sprintf("<details><summary><strong>%s — %s (Main Effect)</strong></summary>\n\n", tissue, contrast_name))
      print(EnhancedVolcano(res_df,
                            lab = res_df$gene,
                            selectLab = top_genes$gene,
                            x = "log2FoldChange",
                            y = "pvalue",
                            pCutoff = 0.05,
                            FCcutoff = 1.0,
                            pointSize = 2.0,
                            labSize = 3.5,
                            title = paste(tissue, ":", contrast_name),
                            subtitle = "Main Effect from Sex × Injury Model",
                            caption = paste("total =", nrow(res_df), "genes tested")))
      cat(kable(top_genes, format = "html", table.attr = "class='table table-condensed table-bordered'"))
      cat("</details>\n\n")
    }

  } else {
    cat(sprintf("<p><em>Skipping %s — insufficient variation for Sex × Injury.</em></p>\n", tissue))
  }

  cat("</details>\n\n")
}

# Summary by Tissue
if (length(summary_signif_genes_sexinjury_model) > 0) {
  final_summary_table <- do.call(rbind, summary_signif_genes_sexinjury_model)

  cat("<details><summary><strong>Summary of Sex × Injury Model Results (by Tissue)</strong></summary>\n\n")
  by_tissue <- split(final_summary_table, final_summary_table$Tissue)

  for (tissue_name in names(by_tissue)) {
    tissue_df <- by_tissue[[tissue_name]]
    cat(sprintf("<details><summary><strong>%s</strong></summary>\n\n", tissue_name))
    cat(kable(tissue_df, format = "html", table.attr = "class='table table-striped table-condensed'"))
    cat("</details>\n\n")
  }

  cat("</details>\n\n")
}

# Flat Summary: FDR < 0.2
if (length(summary_signif_genes_sexinjury_model) > 0) {
  interaction_summary <- do.call(rbind, summary_signif_genes_sexinjury_model)
  filtered_interaction <- interaction_summary[!is.na(interaction_summary$padj) & interaction_summary$padj < 0.2, ]

  if (nrow(filtered_interaction) > 0) {
    filtered_interaction$Tissue <- iconv(as.character(filtered_interaction$Tissue), from = "", to = "UTF-8", sub = "ASCII")
    filtered_interaction$Gene <- iconv(as.character(filtered_interaction$Gene), from = "", to = "UTF-8", sub = "ASCII")
    rownames(filtered_interaction) <- NULL

    cat("<details><summary><strong>Flat Summary: Sex × Injury — Genes with FDR < 0.2</strong></summary>\n\n")
    cat(kable(filtered_interaction, format = "html", table.attr = "class='table table-striped table-condensed'"))
    cat("</details>\n\n")
  } else {
    cat("<p><em>No genes with FDR < 0.2 found in Sex × Injury model.</em></p>\n")
  }
} else {
  cat("<p><em>No Sex × Injury model results available.</em></p>\n")
}



```








### 4.3.3 Downstream Analyses with Pseudobulking and main effects model with interactions AgexInjury and SexxInjury

```{r PseudobulkDEmainEffectsInteraction3, echo=TRUE, results='asis', message=FALSE, warning=FALSE}

# Initialize list to collect results
summary_signif_genes_combined_model <- list()

# Combined interaction formula
combined_formula <- ~ Sex + Age + Injury + Age:Injury + Sex:Injury + Batch

for (tissue in names(gene_filtered_list)) {
  cat(sprintf("<details><summary><strong>%s — Combined Age × Injury & Sex × Injury Model (Injury 0 vs 3)</strong></summary>\n\n", tissue))

  pb_counts <- if (use_filtered_counts) {
    pseudobulk_counts_list[[tissue]]
  } else {
    pseudobulk_counts_raw_list[[tissue]]
  }

  meta <- pseudobulk_meta_list[[tissue]]

  # Subset to Naive and DMM only
  keep <- meta$Injury %in% c(0, 3)
  meta_sub <- meta[keep, ]
  pb_counts_sub <- pb_counts[, keep]

  # Re-factor levels
  meta_sub$Sex <- factor(meta_sub$Sex, levels = c(0, 1))
  meta_sub$Age <- factor(meta_sub$Age, levels = c(0, 1))
  meta_sub$Injury <- factor(meta_sub$Injury, levels = c(0, 3))
  meta_sub$Batch <- factor(meta_sub$Batch, levels = c(0, 1))

  if (
    nrow(meta_sub) >= 6 &&
    length(unique(meta_sub$Sex)) > 1 &&
    length(unique(meta_sub$Age)) > 1 &&
    length(unique(meta_sub$Injury)) > 1
  ) {
    dds_try <- try(DESeqDataSetFromMatrix(countData = as.matrix(pb_counts_sub),
                                          colData = meta_sub,
                                          design = combined_formula),
                   silent = TRUE)

    if (inherits(dds_try, "try-error")) {
      cat(sprintf("<p><em>Skipping %s — model matrix not full rank</em></p>\n", tissue))
      cat("</details>\n\n")
      next
    }

    dds <- dds_try
    dds <- estimateSizeFactors(dds, type = "poscounts")
    dds <- DESeq(dds)

    # === Interaction terms ===
    interaction_terms <- list(
      "AgeInjury_DMM_vs_Naive" = "Age1.Injury3",
      "SexInjury_DMM_vs_Naive" = "Sex1.Injury3"
    )

    for (contrast_name in names(interaction_terms)) {
      term <- interaction_terms[[contrast_name]]
      if (!(term %in% resultsNames(dds))) {
        cat(sprintf("<p><em>Skipping %s — %s not found in resultsNames().</em></p>\n", tissue, term))
        next
      }

      res <- results(dds, name = term)
      res_df <- as.data.frame(res)
      res_df$gene <- rownames(res_df)
      res_df <- res_df[!is.na(res_df$pvalue), ]

      top_genes <- res_df %>%
        arrange(pvalue, desc(abs(log2FoldChange))) %>%
        filter(pvalue < 0.05) %>%
        head(20) %>%
        mutate(FC = 2^log2FoldChange) %>%
        select(gene, log2FoldChange, FC, pvalue, padj)

      if (nrow(top_genes) > 0) {
        summary_signif_genes_combined_model[[length(summary_signif_genes_combined_model) + 1]] <- data.frame(
          Tissue = tissue,
          Comparison = contrast_name,
          Gene = top_genes$gene,
          log2FC = top_genes$log2FoldChange,
          FC = top_genes$FC,
          pvalue = top_genes$pvalue,
          padj = top_genes$padj,
          stringsAsFactors = FALSE
        )
      }

      cat(sprintf("<details><summary><strong>%s — %s (Interaction)</strong></summary>\n\n", tissue, contrast_name))
      print(EnhancedVolcano(res_df,
                            lab = res_df$gene,
                            selectLab = top_genes$gene,
                            x = "log2FoldChange",
                            y = "pvalue",
                            pCutoff = 0.05,
                            FCcutoff = 1.0,
                            pointSize = 2.0,
                            labSize = 3.5,
                            title = paste(tissue, contrast_name),
                            subtitle = paste("Interaction term:", term),
                            caption = paste("total =", nrow(res_df), "genes tested")))
      cat(kable(top_genes, format = "html", table.attr = "class='table table-condensed table-bordered'"))
      cat("</details>\n\n")
    }

    # === Main effect contrasts (only: Sex, Age, DMM vs Naive) ===
    main_contrasts <- list(
      "Sex_Female_vs_Male" = c("Sex", "1", "0"),
      "Age_Aged_vs_Young"  = c("Age", "1", "0"),
      "DMM_vs_Naive"       = c("Injury", "3", "0")
    )

    for (contrast_name in names(main_contrasts)) {
      res <- results(dds, contrast = main_contrasts[[contrast_name]])
      res_df <- as.data.frame(res)
      res_df$gene <- rownames(res_df)
      res_df <- res_df[!is.na(res_df$pvalue), ]

      top_genes <- res_df %>%
        arrange(pvalue, desc(abs(log2FoldChange))) %>%
        filter(pvalue < 0.05) %>%
        head(20) %>%
        mutate(FC = 2^log2FoldChange) %>%
        select(gene, log2FoldChange, FC, pvalue, padj)

      if (nrow(top_genes) > 0) {
        summary_signif_genes_combined_model[[length(summary_signif_genes_combined_model) + 1]] <- data.frame(
          Tissue = tissue,
          Comparison = contrast_name,
          Gene = top_genes$gene,
          log2FC = top_genes$log2FoldChange,
          FC = top_genes$FC,
          pvalue = top_genes$pvalue,
          padj = top_genes$padj,
          stringsAsFactors = FALSE
        )
      }

      cat(sprintf("<details><summary><strong>%s — %s (Main Effect)</strong></summary>\n\n", tissue, contrast_name))
      print(EnhancedVolcano(res_df,
                            lab = res_df$gene,
                            selectLab = top_genes$gene,
                            x = "log2FoldChange",
                            y = "pvalue",
                            pCutoff = 0.05,
                            FCcutoff = 1.0,
                            pointSize = 2.0,
                            labSize = 3.5,
                            title = paste(tissue, contrast_name),
                            subtitle = "Main Effect from Combined Interaction Model",
                            caption = paste("total =", nrow(res_df), "genes tested")))
      cat(kable(top_genes, format = "html", table.attr = "class='table table-condensed table-bordered'"))
      cat("</details>\n\n")
    }

  } else {
    cat(sprintf("<p><em>Skipping %s — insufficient variation.</em></p>\n", tissue))
  }

  cat("</details>\n\n")
}

# Summary by Tissue
if (length(summary_signif_genes_combined_model) > 0) {
  final_summary_table <- do.call(rbind, summary_signif_genes_combined_model)

  cat("<details><summary><strong>Summary of Combined Interaction Results (by Tissue)</strong></summary>\n\n")
  by_tissue <- split(final_summary_table, final_summary_table$Tissue)

  for (tissue_name in names(by_tissue)) {
    tissue_df <- by_tissue[[tissue_name]]
    cat(sprintf("<details><summary><strong>%s</strong></summary>\n\n", tissue_name))
    cat(kable(tissue_df, format = "html", table.attr = "class='table table-striped table-condensed'"))
    cat("</details>\n\n")
  }

  cat("</details>\n\n")
}

# Flat Summary (FDR < 0.2)
if (length(summary_signif_genes_combined_model) > 0) {
  interaction_summary <- do.call(rbind, summary_signif_genes_combined_model)
  filtered <- interaction_summary[!is.na(interaction_summary$padj) & interaction_summary$padj < 0.2, ]

  if (nrow(filtered) > 0) {
    filtered$Tissue <- iconv(as.character(filtered$Tissue), from = "", to = "UTF-8", sub = "ASCII")
    filtered$Gene <- iconv(as.character(filtered$Gene), from = "", to = "UTF-8", sub = "ASCII")
    rownames(filtered) <- NULL

    cat("<details><summary><strong>Flat Summary: Combined Interaction Model — Genes with FDR < 0.2</strong></summary>\n\n")
    cat(kable(filtered, format = "html", table.attr = "class='table table-striped table-condensed'"))
    cat("</details>\n\n")
  } else {
    cat("<p><em>No genes with FDR < 0.2 found in combined interaction model.</em></p>\n")
  }
} else {
  cat("<p><em>No combined interaction model results available.</em></p>\n")
}


```












## 4.4 Diagnostic Plots for Main Effects Model


```{r PseudobulkDiagnostics, echo=TRUE, results='asis', message=FALSE, warning=FALSE}

cat("<details><summary><strong>Diagnostic Plots: Dispersion and MA per Contrast</strong></summary>\n\n")

use_filtered_counts <- TRUE  # Ensure this is consistent

# Initialize list to collect diagnostic stats
diagnostic_stats_table <- list()

for (tissue in names(gene_filtered_list)) {
  cat(sprintf("<details><summary><strong>%s</strong></summary>\n\n", tissue))

  # Load pseudobulk counts and metadata
  pb_counts <- if (use_filtered_counts) pseudobulk_counts_list[[tissue]] else pseudobulk_counts_raw_list[[tissue]]
  meta <- pseudobulk_meta_list[[tissue]]

  # Ensure correct factor levels
  meta$Sex <- factor(meta$Sex, levels = c(0, 1))
  meta$Age <- factor(meta$Age, levels = c(0, 1))
  meta$Injury <- factor(meta$Injury, levels = c(0, 2, 3))
  meta$Batch <- factor(meta$Batch, levels = c(0, 1))

  # Create DESeq2 object and fit
  dds <- DESeqDataSetFromMatrix(countData = as.matrix(pb_counts),
                                colData = meta,
                                design = ~ Sex + Age + Injury + Batch)
  dds <- estimateSizeFactors(dds, type = "poscounts")
  dds <- DESeq(dds)

  # Dispersion Plot (once per tissue)
  plotDispEsts(dds)
  cat("<p><strong>Dispersion Plot:</strong></p>\n")

  # Define named contrasts (same as in DE chunk)
  contrast_list <- list(
    "DMM_vs_Naive" = c("Injury", "3", "0"),
    "Sham_vs_Naive" = c("Injury", "2", "0"),
    "DMM_vs_Sham" = c("Injury", "3", "2"),
    "Sex_Female_vs_Male" = c("Sex", "1", "0"),
    "Age_Aged_vs_Young" = c("Age", "1", "0")
  )

  for (contrast_name in names(contrast_list)) {
    res <- results(dds, contrast = contrast_list[[contrast_name]])
    res_df <- as.data.frame(res)
    res_df <- res_df[!is.na(res_df$pvalue), ]

    # MA plot for this contrast
    plotMA(res, ylim = c(-3, 3), main = paste(tissue, contrast_name))
    cat(sprintf("<p><strong>MA Plot: %s</strong></p>\n", contrast_name))

    # Diagnostic stats per contrast
    converged_vals <- mcols(dds)$converged
    n_convergence_issues <- if (!is.null(converged_vals) && is.logical(converged_vals)) {
      sum(!converged_vals, na.rm = TRUE)
    } else {
      NA
    }

    diagnostics <- data.frame(
      Tissue = tissue,
      Contrast = contrast_name,
      Total_Genes = nrow(res),
      NonZero_Genes = nrow(res_df),
      Median_dispersion = median(mcols(dds)$dispersion, na.rm = TRUE),
      n_outliers = sum(mcols(dds)$maxCooks > 10, na.rm = TRUE),
      n_convergence_issues = n_convergence_issues,
      padj_lt_0.1 = sum(res_df$padj < 0.1, na.rm = TRUE),
      padj_lt_0.05 = sum(res_df$padj < 0.05, na.rm = TRUE)
    )

    diagnostic_stats_table[[length(diagnostic_stats_table) + 1]] <- diagnostics
  }

  cat("</details>\n\n")
}

cat("</details>\n\n")

# Summary Table — now includes Contrast
final_diag_stats <- do.call(rbind, diagnostic_stats_table)

cat("<details><summary><strong>🧪 DESeq2 Diagnostic Summary per Tissue and Contrast</strong></summary>\n\n")

# Split table by Tissue
by_tissue <- split(final_diag_stats, final_diag_stats$Tissue)

for (tissue_name in names(by_tissue)) {
  tissue_df <- by_tissue[[tissue_name]]
  cat(sprintf("<details><summary><strong>%s</strong></summary>\n\n", tissue_name))
  cat(knitr::kable(tissue_df, format = "html", table.attr = "class='table table-bordered table-condensed'"))
  cat("</details>\n\n")
}

cat("</details>\n\n")

```


### 4.4.1 Diagnostic Plots for Main Effects Model males only


```{r PseudobulkDiagnosticsmales, echo=TRUE, results='asis', message=FALSE, warning=FALSE}


injury_levels <- c(0, 2, 3)

cat("<details><summary><strong>🧪 Diagnostic MA Plots — Males Only per Injury (Grouped by Tissue)</strong></summary>\n\n")

# Initialize storage for diagnostics
diagnostic_stats_table <- list()

for (tissue in names(gene_filtered_list)) {
  cat(sprintf("<details><summary><strong>%s</strong></summary>\n\n", tissue))

  meta <- pseudobulk_meta_list[[tissue]]
  counts <- pseudobulk_counts_list[[tissue]]

  # Set factors BEFORE subsetting
  meta$Sex <- factor(meta$Sex, levels = c(0, 1))
  meta$Age <- factor(meta$Age, levels = c(0, 1))
  meta$Injury <- factor(meta$Injury, levels = c(0, 2, 3))
  meta$Batch <- factor(meta$Batch, levels = c(0, 1))

  for (inj in injury_levels) {
    subset_idx <- meta$Sex == 0 & meta$Injury == inj
    meta_subset <- meta[subset_idx, ]
    counts_subset <- counts[, subset_idx]

    if (nrow(meta_subset) < 2) next
    if (length(unique(meta_subset$Age)) < 2) next

    # DESeq2 analysis
    #########################TO DO###################################
    # Check and ensure Batch exists
    if (!"Batch" %in% colnames(meta)) {
      meta$Batch <- NA
    }
    meta$Batch <- factor(meta$Batch, levels = c(0, 1))

    # Subset before modeling
    subset_idx <- meta$Sex == 0 & meta$Injury == inj
    meta_subset <- meta[subset_idx, ]
    counts_subset <- counts[, subset_idx]

    if (nrow(meta_subset) < 2) next
    if (length(unique(meta_subset$Age)) < 2) next

    # Determine if Batch has variation
    use_batch <- length(unique(meta_subset$Batch)) > 1

    # Create design formula
    design_formula <- if (use_batch) ~ Age + Batch else ~ Age

    
    
    
    # DESeq2 analysis
    dds <- DESeqDataSetFromMatrix(countData = counts_subset,
                                  colData = meta_subset,
                                  design = design_formula)
    dds <- estimateSizeFactors(dds, type = "poscounts")
    dds <- DESeq(dds)


    res <- results(dds, contrast = c("Age", "1", "0"))
    res <- res[!is.na(res$pvalue), ]

    # MA Plot inside collapsible
    cat(sprintf("<details><summary><strong>Injury = %s</strong></summary>\n\n", inj))
    cat(sprintf("<p><strong>MA Plot — Age Aged vs Young (Males), Injury = %s:</strong></p>\n", inj))
    print(plotMA(res, ylim = c(-3, 3),
                 main = paste(tissue, "- Injury", inj, "- Age Aged vs Young (Males)")))

    # Collect diagnostics
    converged_vals <- mcols(dds)$converged
    n_convergence_issues <- if (!is.null(converged_vals) && is.logical(converged_vals)) {
      sum(!converged_vals, na.rm = TRUE)
    } else {
      NA
    }

    diagnostics <- data.frame(
      Tissue = tissue,
      Contrast = paste0("Injury_", inj, "_Age_Aged_vs_Young"),
      Total_Genes = nrow(res),
      NonZero_Genes = sum(!is.na(res$pvalue)),
      Median_dispersion = median(mcols(dds)$dispersion, na.rm = TRUE),
      n_outliers = sum(mcols(dds)$maxCooks > 10, na.rm = TRUE),
      n_convergence_issues = n_convergence_issues,
      padj_lt_0.1 = sum(res$padj < 0.1, na.rm = TRUE),
      padj_lt_0.05 = sum(res$padj < 0.05, na.rm = TRUE)
    )

    diagnostic_stats_table[[length(diagnostic_stats_table) + 1]] <- diagnostics

    cat("</details>\n\n") # end of injury collapsible
  }

  cat("</details>\n\n") # end of tissue collapsible
}

cat("</details>\n\n") # end of outer collapsible

# === Summary Table ===
final_diag_stats <- do.call(rbind, diagnostic_stats_table)

cat("<details><summary><strong>📊 DESeq2 Diagnostic Summary per Tissue and Injury (Males Only)</strong></summary>\n\n")
cat(knitr::kable(final_diag_stats, format = "html", table.attr = "class='table table-bordered table-condensed'"))
cat("</details>\n\n")




```


### 4.4.2 Diagnostic Plots for Main Effects Model (Males Only, All Injury Comparisons)

```{r PseudobulkDiagnosticsMalesAllContrasts, echo=TRUE, results='asis', message=FALSE, warning=FALSE}

cat("<details><summary><strong>🧪 Diagnostic MA Plots — Males Only (Age & Injury Contrasts per Tissue)</strong></summary>\n\n")

diagnostic_stats_table <- list()

for (tissue in names(gene_filtered_list)) {
  cat(sprintf("<details><summary><strong>%s</strong></summary>\n\n", tissue))

  meta <- pseudobulk_meta_list[[tissue]]
  counts <- pseudobulk_counts_list[[tissue]]

  # Factor setup
  meta$Sex <- factor(meta$Sex, levels = c(0, 1))
  meta$Age <- factor(meta$Age, levels = c(0, 1))
  meta$Injury <- factor(meta$Injury, levels = c(0, 2, 3),
                        labels = c("Naive", "Sham", "DMM"))
  if (!"Batch" %in% colnames(meta)) meta$Batch <- NA
  meta$Batch <- factor(meta$Batch, levels = c(0, 1))

  # Subset to males only
  subset_idx <- meta$Sex == 0
  meta_subset <- meta[subset_idx, ]
  counts_subset <- counts[, subset_idx]

  if (nrow(meta_subset) < 2 || length(unique(meta_subset$Age)) < 2 || length(unique(meta_subset$Injury)) < 2) next

  # Design formula
  use_batch <- length(unique(meta_subset$Batch)) > 1
  design_formula <- if (use_batch) ~ Age + Injury + Batch else ~ Age + Injury

  # DESeq2
  dds <- DESeqDataSetFromMatrix(countData = counts_subset,
                                colData = meta_subset,
                                design = design_formula)
  dds <- estimateSizeFactors(dds, type = "poscounts")
  dds <- DESeq(dds)

  # Define contrasts
  contrast_list <- list(
    "Age_Aged_vs_Young"     = c("Age", "1", "0"),
    "Injury_Sham_vs_Naive"  = c("Injury", "Sham", "Naive"),
    "Injury_DMM_vs_Naive"   = c("Injury", "DMM", "Naive"),
    "Injury_DMM_vs_Sham"    = c("Injury", "DMM", "Sham")
  )

  for (contrast_name in names(contrast_list)) {
    contrast <- contrast_list[[contrast_name]]

    res <- results(dds, contrast = contrast)
    res <- res[!is.na(res$pvalue), ]

    cat(sprintf("<details><summary><strong>%s</strong></summary>\n\n", contrast_name))
    cat(sprintf("<p><strong>MA Plot — %s:</strong></p>\n", contrast_name))
    print(plotMA(res, ylim = c(-3, 3),
                 main = paste(tissue, "-", contrast_name)))

    converged_vals <- mcols(dds)$converged
    n_convergence_issues <- if (!is.null(converged_vals) && is.logical(converged_vals)) {
      sum(!converged_vals, na.rm = TRUE)
    } else {
      NA
    }

    diagnostics <- data.frame(
      Tissue = tissue,
      Contrast = contrast_name,
      Total_Genes = nrow(res),
      NonZero_Genes = sum(!is.na(res$pvalue)),
      Median_dispersion = median(mcols(dds)$dispersion, na.rm = TRUE),
      n_outliers = sum(mcols(dds)$maxCooks > 10, na.rm = TRUE),
      n_convergence_issues = n_convergence_issues,
      padj_lt_0.1 = sum(res$padj < 0.1, na.rm = TRUE),
      padj_lt_0.05 = sum(res$padj < 0.05, na.rm = TRUE)
    )

    diagnostic_stats_table[[length(diagnostic_stats_table) + 1]] <- diagnostics
    cat("</details>\n\n")
  }

  cat("</details>\n\n") # tissue
}

cat("</details>\n\n") # outer

# === Summary Table ===
final_diag_stats <- do.call(rbind, diagnostic_stats_table)

cat("<details><summary><strong>📊 DESeq2 Diagnostic Summary per Tissue and Contrast</strong></summary>\n\n")
cat(knitr::kable(final_diag_stats, format = "html", table.attr = "class='table table-bordered table-condensed'"))
cat("</details>\n\n")



```





### 4.4.3 Diagnostic Plots for Main Effects Model (Young Only, All Injury Comparisons)

```{r PseudobulkDiagnosticsYoungAllContrasts, echo=TRUE, results='asis', message=FALSE, warning=FALSE}

cat("<details><summary><strong>🧪 Diagnostic MA Plots — Young Only (Sex & Injury Contrasts per Tissue)</strong></summary>\n\n")

diagnostic_stats_table <- list()

for (tissue in names(gene_filtered_list)) {
  cat(sprintf("<details><summary><strong>%s</strong></summary>\n\n", tissue))

  meta <- pseudobulk_meta_list[[tissue]]
  counts <- pseudobulk_counts_list[[tissue]]

  # Factor setup
  meta$Sex <- factor(meta$Sex, levels = c(0, 1))
  meta$Age <- factor(meta$Age, levels = c(0, 1))
  meta$Injury <- factor(meta$Injury, levels = c(0, 2, 3),
                        labels = c("Naive", "Sham", "DMM"))
  if (!"Batch" %in% colnames(meta)) meta$Batch <- NA
  meta$Batch <- factor(meta$Batch, levels = c(0, 1))

  # Subset to males only
  subset_idx <- meta$Age == 0
  meta_subset <- meta[subset_idx, ]
  counts_subset <- counts[, subset_idx]

  if (nrow(meta_subset) < 2 || length(unique(meta_subset$Injury)) < 2) next

  # Design formula
  use_batch <- length(unique(meta_subset$Batch)) > 1
  design_formula <- if (use_batch) ~ Sex + Injury + Batch else ~ Sex + Injury

  # DESeq2
  dds <- DESeqDataSetFromMatrix(countData = counts_subset,
                                colData = meta_subset,
                                design = design_formula)
  dds <- estimateSizeFactors(dds, type = "poscounts")
  dds <- DESeq(dds)

  # Define contrasts
  contrast_list <- list(
    "Sex_Female_vs_Male"     = c("Sex", "1", "0"),
    "Injury_Sham_vs_Naive"  = c("Injury", "Sham", "Naive"),
    "Injury_DMM_vs_Naive"   = c("Injury", "DMM", "Naive"),
    "Injury_DMM_vs_Sham"    = c("Injury", "DMM", "Sham")
  )

  for (contrast_name in names(contrast_list)) {
    contrast <- contrast_list[[contrast_name]]

    res <- results(dds, contrast = contrast)
    res <- res[!is.na(res$pvalue), ]

    cat(sprintf("<details><summary><strong>%s</strong></summary>\n\n", contrast_name))
    cat(sprintf("<p><strong>MA Plot — %s:</strong></p>\n", contrast_name))
    print(plotMA(res, ylim = c(-3, 3),
                 main = paste(tissue, "-", contrast_name)))

    converged_vals <- mcols(dds)$converged
    n_convergence_issues <- if (!is.null(converged_vals) && is.logical(converged_vals)) {
      sum(!converged_vals, na.rm = TRUE)
    } else {
      NA
    }

    diagnostics <- data.frame(
      Tissue = tissue,
      Contrast = contrast_name,
      Total_Genes = nrow(res),
      NonZero_Genes = sum(!is.na(res$pvalue)),
      Median_dispersion = median(mcols(dds)$dispersion, na.rm = TRUE),
      n_outliers = sum(mcols(dds)$maxCooks > 10, na.rm = TRUE),
      n_convergence_issues = n_convergence_issues,
      padj_lt_0.1 = sum(res$padj < 0.1, na.rm = TRUE),
      padj_lt_0.05 = sum(res$padj < 0.05, na.rm = TRUE)
    )

    diagnostic_stats_table[[length(diagnostic_stats_table) + 1]] <- diagnostics
    cat("</details>\n\n")
  }

  cat("</details>\n\n") # tissue
}

cat("</details>\n\n") # outer

# === Summary Table ===
final_diag_stats <- do.call(rbind, diagnostic_stats_table)

cat("<details><summary><strong>📊 DESeq2 Diagnostic Summary per Tissue and Contrast</strong></summary>\n\n")
cat(knitr::kable(final_diag_stats, format = "html", table.attr = "class='table table-bordered table-condensed'"))
cat("</details>\n\n")



```







## 4.5 Downstream Analyses with Pseudobulking for PCA and heatmap generation


```{r PseudobulkAnalyses, echo=TRUE, results='asis', message=FALSE, warning=FALSE}

# Required packages
if (!requireNamespace("edgeR", quietly = TRUE)) {
  if (!requireNamespace("BiocManager", quietly = TRUE)) {
    install.packages("BiocManager")
  }
}
if (!requireNamespace("pheatmap", quietly = TRUE)) {
  install.packages("pheatmap", repos = "https://cloud.r-project.org")
}

library(edgeR)
library(Seurat)
library(ggplot2)
library(pheatmap)
library(reshape2)

required_cols <- c("ID", "Age", "Sex", "Injury", "Slide", "Batch")

# 1. Pseudobulk by sample (using ID column)
pseudobulk_counts <- list()

for (tissue in names(gene_filtered_list)) {
  seurat_obj <- gene_filtered_list[[tissue]]
  DefaultAssay(seurat_obj) <- "RawCounts"
  counts <- GetAssayData(seurat_obj, slot = "counts")
  metadata <- seurat_obj@meta.data
  metadata$barcode <- rownames(metadata)

  if (!"ID" %in% colnames(metadata)) {
    cat(sprintf("<p><strong>Skipping %s because 'ID' not found in metadata.</strong></p>\n", tissue))
    next
  }

  split_cells <- base::split(metadata$barcode, f = metadata$ID)

  pseudobulk_matrix <- sapply(split_cells, function(cells) {
    Matrix::rowSums(counts[, cells, drop = FALSE])
  })

  pseudobulk_counts[[tissue]] <- pseudobulk_matrix
}

# 2. Normalize pseudobulk counts with edgeR
logCPM_list <- list()

for (tissue in names(pseudobulk_counts)) {
  counts_mat <- pseudobulk_counts[[tissue]]
  if (any(is.na(counts_mat)) || ncol(counts_mat) < 2) {
    next
  }

  dge <- DGEList(counts = counts_mat)
  dge <- calcNormFactors(dge)
  logCPM <- cpm(dge, log = TRUE, prior.count = 1)
  logCPM_list[[tissue]] <- logCPM
}

cat("<p>Sample ID group breakdown:</p>\n")
print(table(metadata$Sex, metadata$Age, metadata$Injury))

# 2b. PCA by tissue with outlier detection

cat('<details><summary><strong>PCA by Tissue (logCPM Pseudobulked Samples)</strong></summary>\n\n')


# ✅ Explicitly define variance function to avoid masking issues
VAR_FUN <- stats::var

for (tissue in names(logCPM_list)) {
  cat(sprintf('<details><summary><strong>%s</strong></summary>\n\n', tissue))
  cat("Current tissue:", tissue, "<br>\n")
  
  logcpm_mat <- logCPM_list[[tissue]]
  if (is.null(logcpm_mat) || ncol(logcpm_mat) < 2) {
    cat("<p style='color:red;'>⚠️ logCPM matrix missing or too few samples</p>\n</details>\n")
    next
  }

  num_genes <- nrow(logcpm_mat)
  top_var_genes <- head(order(apply(logcpm_mat, 1, VAR_FUN, na.rm = TRUE), decreasing = TRUE), floor(num_genes * 0.5))
  logcpm_mat <- logcpm_mat[top_var_genes, , drop = FALSE]
  logcpm_t <- t(logcpm_mat)

  # PCA
  pca_res <- prcomp(logcpm_t, center = TRUE, scale. = TRUE)
  var_explained <- round(100 * (pca_res$sdev^2 / sum(pca_res$sdev^2)), 2)
  
  # Scree plot
  var_df <- data.frame(
    PC = paste0("PC", seq_along(var_explained)),
    VarianceExplained = var_explained
  )[1:9, ]

  scree_plot <- ggplot(var_df, aes(x = PC, y = VarianceExplained)) +
    geom_bar(stat = "identity", fill = "steelblue") +
    theme_minimal() +
    labs(title = paste("Scree Plot:", tissue), y = "% Variance Explained") +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))
  print(scree_plot)

  # Continue with metadata, outlier detection, and PCA plotting
  meta <- gene_filtered_list[[tissue]]@meta.data
  meta <- as.data.frame(meta)
  colnames(meta) <- make.names(colnames(meta))
  sample_annot <- unique(meta[, required_cols, drop = FALSE])
  rownames(sample_annot) <- sample_annot$ID
  sample_annot <- sample_annot[rownames(logcpm_t), , drop = FALSE]

  pca_df <- as.data.frame(pca_res$x[, 1:2])
  pca_df$ID <- rownames(pca_df)
  pca_df$Slide <- factor(sample_annot[["Slide"]])
  pca_df$Batch <- factor(sample_annot[["Batch"]])

  center <- colMeans(pca_df[, c("PC1", "PC2")])
  pca_df$Distance <- sqrt((pca_df$PC1 - center["PC1"])^2 + (pca_df$PC2 - center["PC2"])^2)
  threshold <- mean(pca_df$Distance) + 2 * sd(pca_df$Distance)
  pca_df$Outlier <- pca_df$Distance > threshold
  pca_df$Outlier_Label <- ifelse(pca_df$Outlier, "Outlier", "Normal")

  p <- ggplot(pca_df, aes(x = PC1, y = PC2, color = Slide, shape = Batch)) +
    geom_point(aes(size = Outlier, alpha = Outlier), stroke = 1.2) +
    geom_text_repel(aes(label = ID), size = 3.2, show.legend = FALSE) +
    scale_size_manual(values = c("TRUE" = 4, "FALSE" = 2), guide = "none") +
    scale_alpha_manual(values = c("TRUE" = 1, "FALSE" = 0.6), guide = "none") +
    ggtitle(paste("PCA of", tissue, "logCPM (Top 50% Most Variable Genes)")) +
    xlab(paste0("PC1 (", var_explained[1], "% variance)")) +
    ylab(paste0("PC2 (", var_explained[2], "% variance)")) +
    theme_minimal() +
    theme(legend.position = "bottom")
  print(p)

  if (any(pca_df$Outlier)) {
    outliers <- pca_df[pca_df$Outlier, c("ID", "PC1", "PC2", "Distance")]
    cat("<p><strong>\u26a0\ufe0f Outliers detected:</strong></p>\n")
    print(knitr::kable(outliers, format = "html", table.attr = "class='table table-condensed table-bordered'"))
  } else {
    cat("<p>No PCA outliers detected.</p>\n")
  }

  cat("</details>\n\n")
}






cat("<p>Sample ID group breakdown:</p>\n")
print(table(metadata$Sex, metadata$Age, metadata$Injury))

cat('<details><summary><strong>PCA by Tissue (logCPM Pseudobulked Samples)</strong></summary>\n\n')

VAR_FUN <- stats::var

for (tissue in names(logCPM_list)) {
  cat(sprintf('<details><summary><strong>%s</strong></summary>\n\n', tissue))

  logcpm_mat <- logCPM_list[[tissue]]
  if (is.null(logcpm_mat) || ncol(logcpm_mat) < 2) {
    cat("<p style='color:red;'>⚠️ logCPM matrix missing or too few samples</p>\n</details>\n")
    next
  }

  num_genes <- nrow(logcpm_mat)
  top_var_genes <- head(order(apply(logcpm_mat, 1, VAR_FUN, na.rm = TRUE), decreasing = TRUE), floor(num_genes * 0.5))
  logcpm_mat <- logcpm_mat[top_var_genes, , drop = FALSE]
  logcpm_t <- t(logcpm_mat)

  # PCA
  pca_res <- prcomp(logcpm_t, center = TRUE, scale. = TRUE)
  var_explained <- round(100 * (pca_res$sdev^2 / sum(pca_res$sdev^2)), 2)
  pc1_var <- var_explained[1]
  pc2_var <- var_explained[2]

  # Metadata
  meta <- gene_filtered_list[[tissue]]@meta.data
  meta <- as.data.frame(meta)
  colnames(meta) <- make.names(colnames(meta))
  required_cols <- c("ID", "Age", "Sex", "Injury", "Slide", "Batch")
  stopifnot(all(required_cols %in% colnames(meta)))
  sample_annot <- unique(meta[, required_cols, drop = FALSE])
  rownames(sample_annot) <- sample_annot$ID
  sample_annot <- sample_annot[rownames(logcpm_t), , drop = FALSE]

  # PCA DataFrame
  pca_df <- as.data.frame(pca_res$x[, 1:2])
  pca_df$ID <- rownames(pca_df)
  pca_df$Slide <- factor(sample_annot[["Slide"]])
  pca_df$Batch <- factor(sample_annot[["Batch"]])

  # Outlier Detection
  center <- colMeans(pca_df[, c("PC1", "PC2")])
  pca_df$Distance <- sqrt((pca_df$PC1 - center["PC1"])^2 + (pca_df$PC2 - center["PC2"])^2)
  threshold <- mean(pca_df$Distance) + 2 * sd(pca_df$Distance)
  pca_df$Outlier <- pca_df$Distance > threshold
  pca_df$Outlier_Label <- ifelse(pca_df$Outlier, "Outlier", "Normal")

  # PCA Plot
  p <- ggplot(pca_df, aes(x = PC1, y = PC2, color = Slide, shape = Batch)) +
    geom_point(aes(size = Outlier, alpha = Outlier), stroke = 1.2) +
    geom_text_repel(aes(label = ID), size = 3.2, show.legend = FALSE) +
    scale_size_manual(values = c("TRUE" = 4, "FALSE" = 2), guide = "none") +
    scale_alpha_manual(values = c("TRUE" = 1, "FALSE" = 0.6), guide = "none") +
    ggtitle(paste("PCA of", tissue, "logCPM (Top 50% Most Variable Genes)")) +
    xlab(paste0("PC1 (", pc1_var, "% variance)")) +
    ylab(paste0("PC2 (", pc2_var, "% variance)")) +
    theme_minimal() +
    theme(legend.position = "bottom")

  print(p)

  # Outlier Table
  if (any(pca_df$Outlier)) {
    outliers <- pca_df[pca_df$Outlier, c("ID", "PC1", "PC2", "Distance")]
    cat("<p><strong>\u26a0\ufe0f Outliers detected:</strong></p>\n")
    print(knitr::kable(outliers, format = "html", table.attr = "class='table table-condensed table-bordered'"))
  } else {
    cat("<p>No PCA outliers detected.</p>\n")
  }

  cat('</details>\n\n')
}

cat('</details>\n\n')












# 3. Heatmaps
library(circlize)
library(ComplexHeatmap)

# Use a namespaced safe version of var to avoid masking errors
VAR_FUN <- stats::var

colors_age <- setNames(c("dodgerblue", "orange"), c(0, 1))
colors_sex <- setNames(c("blue", "pink"), c(0, 1))
colors_injury <- setNames(c("grey", "gold", "firebrick"), c(0, 2, 3))

# Collect all slide/batch levels from all tissues
all_slide_levels <- unique(unlist(lapply(gene_filtered_list, function(seu) seu@meta.data$Slide)))
all_batch_levels <- unique(unlist(lapply(gene_filtered_list, function(seu) seu@meta.data$Batch)))
colors_slide <- setNames(
  RColorBrewer::brewer.pal(max(3, min(12, length(all_slide_levels))), "Set3"),
  sort(na.omit(as.character(all_slide_levels)))
)
colors_batch <- setNames(
  RColorBrewer::brewer.pal(max(3, min(9, length(all_batch_levels))), "Pastel1"),
  sort(na.omit(as.character(all_batch_levels)))
)

tissue_names <- c("CartilageFemur", "CartilageTibia", "SubchondralFemur", "SubchondralTibia", "Meniscus", "IPFP", "Synovium", "BoneMarrowFemur", "BoneMarrowTibia", "GrowthPlateTibia", "GrowthPlateFemur")

cat('<details><summary><strong>Top Variable Genes Heatmap by Tissue</strong></summary>\n\n')

for (tissue in tissue_names) {
  cat(sprintf('\n<details><summary><strong>%s</strong></summary>\n\n', tissue))
  
  logcpm <- logCPM_list[[tissue]]
  if (is.null(logcpm)) {
    cat(sprintf("<p style='color:red;'>⚠️ logCPM data missing for %s</p>\n", tissue))
    cat('</details>\n')
    next
  }

  # Top 50% most variable genes
  num_genes <- nrow(logcpm)
  top_genes <- head(order(apply(logcpm, 1, VAR_FUN, na.rm = TRUE), decreasing = TRUE), floor(num_genes * 0.5))
  heatmap_data <- logcpm[top_genes, , drop = FALSE]

  # Extract and prepare annotation
  metadata <- gene_filtered_list[[tissue]]@meta.data
  metadata <- as.data.frame(metadata)
  colnames(metadata) <- make.names(colnames(metadata))
  required_cols <- c("ID", "Age", "Sex", "Injury", "Slide", "Batch")
  stopifnot(all(required_cols %in% colnames(metadata)))

  annotation_df <- unique(metadata[, required_cols, drop = FALSE])
  annotation_df <- annotation_df[match(colnames(logcpm), annotation_df$ID), ]
  rownames(annotation_df) <- annotation_df$ID
  annotation_df$ID <- NULL

  # Adjust color levels per tissue
  local_colors_slide <- colors_slide[names(colors_slide) %in% annotation_df$Slide]
  local_colors_batch <- colors_batch[names(colors_batch) %in% annotation_df$Batch]

  top_annotation <- HeatmapAnnotation(
    Age = annotation_df[["Age"]],
    Sex = annotation_df[["Sex"]],
    Injury = annotation_df[["Injury"]],
    Slide = annotation_df[["Slide"]],
    Batch = annotation_df[["Batch"]],
    col = list(
      Age = colors_age,
      Sex = colors_sex,
      Injury = colors_injury,
      Slide = local_colors_slide,
      Batch = local_colors_batch
    ),
    annotation_height = unit(rep(0.5, 5), "cm")
  )

  col_fun <- colorRamp2(
    breaks = c(min(heatmap_data, na.rm = TRUE),
               mean(heatmap_data, na.rm = TRUE),
               max(heatmap_data, na.rm = TRUE)),
    colors = c("navy", "white", "firebrick3")
  )

  ht <- Heatmap(
    heatmap_data,
    name = "Expression",
    top_annotation = top_annotation,
    col = col_fun,
    cluster_rows = TRUE,
    cluster_columns = TRUE,
    show_row_names = TRUE,
    show_column_names = TRUE,
    row_names_gp = gpar(fontsize = 8),
    column_names_gp = gpar(fontsize = 10),
    heatmap_legend_param = list(
      title = "Expression",
      title_gp = gpar(fontsize = 10, fontface = "bold"),
      labels_gp = gpar(fontsize = 8)
    )
  )

  print(ht)
  cat('</details>\n')
}
cat('</details>\n')



# 4. Export to CSV
output_dir <- "Pseudobulk_logCPM_outputs"
dir.create(output_dir, showWarnings = FALSE)
for (tissue in names(logCPM_list)) {
  out_file <- file.path(output_dir, paste0("logCPM_", tissue, ".csv"))
  write.csv(logCPM_list[[tissue]], out_file)
}

# 5. Expression Boxplots
cat('<details><summary><strong>logCPM Expression Boxplots by Tissue</strong></summary>\n\n')
for (tissue in names(logCPM_list)) {
  cat(sprintf('<details><summary><strong>%s</strong></summary>\n\n', tissue))
  logcpm_mat <- logCPM_list[[tissue]]
  logcpm_df <- as.data.frame(logcpm_mat)
  logcpm_df$Gene <- rownames(logcpm_df)
  melted <- melt(logcpm_df, id.vars = "Gene", variable.name = "Sample", value.name = "logCPM")

  meta <- gene_filtered_list[[tissue]]@meta.data
  annotation_df <- unique(meta[, c("ID", "Sex", "Injury")])
  melted$Injury <- annotation_df$Injury[match(melted$Sample, annotation_df$ID)]
  melted$Sex <- annotation_df$Sex[match(melted$Sample, annotation_df$ID)]
  melted$Injury[is.na(melted$Injury)] <- "Unknown"
  melted$Sex[is.na(melted$Sex)] <- "Unknown"
  melted$Sample_Label <- paste0(melted$Sample, " (", melted$Sex, "-", melted$Injury, ")")

  deg_table <- do.call(rbind, summary_signif_genes_main_model)
  deg_genes <- deg_table$Gene[deg_table$Tissue == tissue]
  top3_genes <- head(unique(deg_genes), 3)

  # Fallback to variable genes if not enough DEGs
  if (length(top3_genes) < 3) {
    gene_vars <- apply(logcpm_mat, 1, var, na.rm = TRUE)
    top3_genes <- names(sort(gene_vars, decreasing = TRUE))[1:3]
  }


  for (gene in top3_genes) {
    p <- ggplot(subset(melted, Gene == gene), aes(x = Sample_Label, y = logCPM)) +
      geom_boxplot(fill = "skyblue", color = "black", outlier.shape = 16, outlier.size = 2) +
      geom_jitter(width = 0.2, size = 1.5, alpha = 0.7) +
      theme_minimal(base_size = 12) +
      xlab("") +
      ylab("logCPM") +
      ggtitle(paste(tissue, "-", gene)) +
      theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 8))
    print(p)
  }
  cat('</details>\n\n')
}
cat('</details>\n\n')





```


## 4.6 Downstream Analyses with Pseudobulking for PCA and heatmap generation separated by injury 



```{r PseudobulkInjuryStratified, echo=TRUE, message=FALSE, warning=FALSE, results='asis'}


injury_levels <- c(0, 2, 3)

aging_signature_list <- list()


for (injury in injury_levels) {
  cat(sprintf("<h3>Injury = %s</h3>\n", injury))

  # 1. Pseudobulk by sample (only for current injury group)
  pseudobulk_counts <- list()

  for (tissue in names(gene_filtered_list)) {
    seurat_obj <- gene_filtered_list[[tissue]]
    seurat_obj <- subset(seurat_obj, subset = Injury == injury)

    if (ncol(seurat_obj) < 2) next

    DefaultAssay(seurat_obj) <- "RawCounts"
    counts <- GetAssayData(seurat_obj, slot = "counts")
    metadata <- seurat_obj@meta.data
    metadata$barcode <- rownames(metadata)

    if (!"ID" %in% colnames(metadata)) {
      cat(sprintf("<p><strong>Skipping %s because 'ID' not found in metadata.</strong></p>\n", tissue))
      next
    }

    split_cells <- base::split(metadata$barcode, f = metadata$ID)
    pseudobulk_matrix <- sapply(split_cells, function(cells) {
      Matrix::rowSums(counts[, cells, drop = FALSE])
    })

    pseudobulk_counts[[tissue]] <- pseudobulk_matrix
  }

  # 2. Normalize pseudobulk counts with edgeR
  logCPM_list <- list()

  for (tissue in names(pseudobulk_counts)) {
    counts_mat <- pseudobulk_counts[[tissue]]
    if (any(is.na(counts_mat)) || ncol(counts_mat) < 2) next

    dge <- edgeR::DGEList(counts = counts_mat)
    dge <- edgeR::calcNormFactors(dge)
    logCPM <- edgeR::cpm(dge, log = TRUE, prior.count = 1)
    logCPM_list[[tissue]] <- logCPM
  }

  # PCA by tissue
  cat('<details><summary><strong>PCA by Tissue (logCPM, Injury =', injury, ')</strong></summary>\n\n')

  VAR_FUN <- stats::var

  for (tissue in names(logCPM_list)) {
    cat("Current tissue:", tissue, "\n")
    logcpm_mat <- logCPM_list[[tissue]]
    
    cat(sprintf("→ %s (Injury = %s): %d genes, %d samples\n", tissue, injury, nrow(logcpm_mat), ncol(logcpm_mat)))

    gene_vars <- apply(logcpm_mat, 1, VAR_FUN, na.rm = TRUE)
    gene_vars <- gene_vars[gene_vars > 0]  # Filter out constant genes
    
    cat(sprintf("  └ Genes with non-zero variance: %d\n", length(gene_vars)))

    # Use gene names to get top 50% variable genes
    top_n <- floor(length(gene_vars) * 0.5)
    top_gene_names <- names(sort(gene_vars, decreasing = TRUE))[seq_len(top_n)]


    # Ensure we have at least 2 genes
    if (length(top_gene_names) < 2) {
      cat(sprintf("<p style='color:red;'>⚠️ Only %d variable genes found in %s (Injury = %s)</p>\n",
                  length(top_gene_names), tissue, injury))
      next
    }

    logcpm_mat <- logcpm_mat[top_gene_names, , drop = FALSE]

    
    if (nrow(logcpm_mat) < 2) {
      cat(sprintf("<p style='color:red;'>⚠️ Not enough variable genes in %s for PCA (Injury = %s)</p>\n", tissue, injury))
      next
    }

    
    logcpm_t <- t(logcpm_mat)

    pca_res <- prcomp(logcpm_t, center = TRUE, scale. = TRUE)
    
    
    pc1_loadings <- pca_res$rotation[, "PC1"]
    pc1_up <- names(sort(pc1_loadings, decreasing = TRUE))[1:25]
    pc1_down <- names(sort(pc1_loadings, decreasing = FALSE))[1:25]

    aging_signature_list[[paste0(tissue, "_Injury", injury)]] <- list(
      Up_in_Aged = pc1_up,
      Down_in_Aged = pc1_down
    )

    
    
    var_explained <- round(100 * (pca_res$sdev^2 / sum(pca_res$sdev^2)), 2)
    
    # Variance explained by all PCs
    var_explained <- round(100 * (pca_res$sdev^2 / sum(pca_res$sdev^2)), 2)

    # Scree plot (first 9 PCs)
    var_df <- data.frame(
      PC = paste0("PC", seq_along(var_explained)),
      VarianceExplained = var_explained
    )[1:min(9, length(var_explained)), ]  # guard against <9 PCs

    scree_plot <- ggplot(var_df, aes(x = PC, y = VarianceExplained)) +
      geom_bar(stat = "identity", fill = "steelblue") +
      theme_minimal() +
      labs(title = paste("Scree Plot:", tissue, "- Injury =", injury),
          y = "% Variance Explained", x = "Principal Components") +
      theme(axis.text.x = element_text(angle = 45, hjust = 1))

    print(scree_plot)


    meta <- gene_filtered_list[[tissue]]@meta.data
    meta <- meta[meta$Injury == injury, ]
    meta <- as.data.frame(meta)
    colnames(meta) <- make.names(colnames(meta))
    required_cols <- c("ID", "Age", "Sex", "Injury", "Slide", "Batch")
    sample_annot <- unique(meta[, required_cols, drop = FALSE])
    rownames(sample_annot) <- sample_annot$ID
    sample_annot <- sample_annot[rownames(logcpm_t), , drop = FALSE]

    pca_df <- as.data.frame(pca_res$x[, 1:2])
    
    # Save PCA scores + metadata for downstream inspection
    # Ensure consistent structure across all pca_df_full objects
    pca_df_full <- data.frame(
      ID = sample_annot$ID,
      PC1 = pca_df$PC1,
      PC2 = pca_df$PC2,
      Age = sample_annot$Age,
      Sex = sample_annot$Sex,
      Injury = sample_annot$Injury,
      Slide = sample_annot$Slide,
      Batch = sample_annot$Batch,
      Tissue = rep(tissue, nrow(sample_annot)),
      stringsAsFactors = FALSE
    )

    # Initialize or append safely
    if (!exists("pca_results_all")) {
      pca_results_all <- pca_df_full
    } else {
      # Ensure column names and order are aligned
      common_cols <- intersect(colnames(pca_results_all), colnames(pca_df_full))
      pca_results_all <- pca_results_all[, common_cols, drop = FALSE]
      pca_df_full <- pca_df_full[, common_cols, drop = FALSE]
      pca_results_all <- rbind(pca_results_all, pca_df_full)
    }



    
    pca_df$ID <- rownames(pca_df)
    pca_df$Age <- factor(sample_annot[["Age"]])
    pca_df$Sex <- factor(sample_annot[["Sex"]])
    pca_df$Injury <- factor(sample_annot[["Injury"]])

    center <- colMeans(pca_df[, c("PC1", "PC2")])
    pca_df$Distance <- sqrt((pca_df$PC1 - center["PC1"])^2 + (pca_df$PC2 - center["PC2"])^2)
    threshold <- mean(pca_df$Distance) + 2 * sd(pca_df$Distance)
    pca_df$Outlier <- pca_df$Distance > threshold
    pca_df$Outlier_Label <- ifelse(pca_df$Outlier, "Outlier", "Normal")

    p <- ggplot(pca_df, aes(x = PC1, y = PC2, color = Sex, shape = Age)) +
      geom_point(aes(size = Outlier, alpha = Outlier), stroke = 1.2) +
      geom_text_repel(aes(label = ID), size = 3.2, show.legend = FALSE) +
      scale_shape_manual(values = c("0" = 16, "1" = 17)) +
      scale_size_manual(values = c("TRUE" = 4, "FALSE" = 2), guide = "none") +
      scale_alpha_manual(values = c("TRUE" = 1, "FALSE" = 0.6), guide = "none") +
      ggtitle(paste("PCA of", tissue, "- Injury =", injury)) +
      xlab(paste0("PC1 (", var_explained[1], "%)")) +
      ylab(paste0("PC2 (", var_explained[2], "%)")) +
      theme_minimal()

    print(p)

    if (any(pca_df$Outlier)) {
      outliers <- pca_df[pca_df$Outlier, c("ID", "PC1", "PC2", "Distance")]
      cat("<p><strong>⚠️ Outliers detected:</strong></p>\n")
      print(knitr::kable(outliers, format = "html", table.attr = "class='table table-condensed table-bordered'"))
    } else {
      cat("<p>No PCA outliers detected.</p>\n")
    }
  }

  cat('</details>\n\n')
  
  

  # Define color palettes for Slide and Batch
  all_slide_levels <- unique(unlist(lapply(gene_filtered_list, function(seu) seu@meta.data$Slide)))
  all_batch_levels <- unique(unlist(lapply(gene_filtered_list, function(seu) seu@meta.data$Batch)))

  all_slide_levels <- sort(na.omit(as.character(all_slide_levels)))
  all_batch_levels <- sort(na.omit(as.character(all_batch_levels)))

  colors_slide <- setNames(
    RColorBrewer::brewer.pal(max(3, min(12, length(all_slide_levels))), "Set3"),
    all_slide_levels
  )

  colors_batch <- setNames(
    RColorBrewer::brewer.pal(max(3, min(9, length(all_batch_levels))), "Pastel1"),
    all_batch_levels
  )



  # 3. Heatmaps
  cat('<details><summary><strong>Heatmaps by Tissue (Injury =', injury, ')</strong></summary>\n\n')

  for (tissue in names(logCPM_list)) {
    logcpm <- logCPM_list[[tissue]]
    if (is.null(logcpm)) next

    gene_vars <- apply(logcpm, 1, VAR_FUN, na.rm = TRUE)
    top_n <- max(10, floor(length(gene_vars) * 0.5))  # optional minimum of 10
    top_genes <- names(sort(gene_vars, decreasing = TRUE))[seq_len(top_n)]


    heatmap_data <- logcpm[top_genes, , drop = FALSE]

    metadata <- gene_filtered_list[[tissue]]@meta.data
    metadata <- metadata[metadata$Injury == injury, ]
    metadata <- as.data.frame(metadata)
    colnames(metadata) <- make.names(colnames(metadata))
    annotation_df <- unique(metadata[, required_cols, drop = FALSE])
    annotation_df <- annotation_df[match(colnames(logcpm), annotation_df$ID), ]
    
    # Ensure color vectors match current annotation levels
    local_colors_slide <- colors_slide[names(colors_slide) %in% annotation_df$Slide]
    local_colors_batch <- colors_batch[names(colors_batch) %in% annotation_df$Batch]

    rownames(annotation_df) <- annotation_df$ID
    annotation_df$ID <- NULL

    top_annotation <- HeatmapAnnotation(
      Age = annotation_df[["Age"]],
      Sex = annotation_df[["Sex"]],
      Injury = annotation_df[["Injury"]],
      Slide = annotation_df[["Slide"]],
      Batch = annotation_df[["Batch"]],
      col = list(Age = colors_age, Sex = colors_sex, Injury = colors_injury, Slide = local_colors_slide, Batch = local_colors_batch ),
      annotation_height = unit(rep(0.5, 5), "cm")
    )

    col_fun <- circlize::colorRamp2(
      c(min(heatmap_data), mean(heatmap_data), max(heatmap_data)),
      c("navy", "white", "firebrick3")
    )

    ht <- Heatmap(
      heatmap_data,
      name = "Expression",
      top_annotation = top_annotation,
      col = col_fun,
      cluster_rows = TRUE,
      cluster_columns = TRUE,
      show_row_names = TRUE,
      show_column_names = TRUE
    )

    cat(sprintf("<h4>%s</h4>\n", tissue))
    print(ht)
  }

  cat('</details>\n\n')
}










injury_levels <- c(0, 2, 3)
aging_signature_list <- list()

for (injury in injury_levels) {
  cat(sprintf("<h3>Injury = %s</h3>\n", injury))

  pseudobulk_counts <- list()

  for (tissue in names(gene_filtered_list)) {
    seurat_obj <- gene_filtered_list[[tissue]]
    seurat_obj <- subset(seurat_obj, subset = Injury == injury)

    if (ncol(seurat_obj) < 2) next

    DefaultAssay(seurat_obj) <- "RawCounts"
    counts <- GetAssayData(seurat_obj, slot = "counts")
    metadata <- seurat_obj@meta.data
    metadata$barcode <- rownames(metadata)

    if (!"ID" %in% colnames(metadata)) {
      cat(sprintf("<p><strong>Skipping %s because 'ID' not found in metadata.</strong></p>\n", tissue))
      next
    }

    split_cells <- base::split(metadata$barcode, f = metadata$ID)
    pseudobulk_matrix <- sapply(split_cells, function(cells) {
      Matrix::rowSums(counts[, cells, drop = FALSE])
    })

    pseudobulk_counts[[tissue]] <- pseudobulk_matrix
  }

  logCPM_list <- list()

  for (tissue in names(pseudobulk_counts)) {
    counts_mat <- pseudobulk_counts[[tissue]]
    if (any(is.na(counts_mat)) || ncol(counts_mat) < 2) next

    dge <- edgeR::DGEList(counts = counts_mat)
    dge <- edgeR::calcNormFactors(dge)
    logCPM <- edgeR::cpm(dge, log = TRUE, prior.count = 1)
    logCPM_list[[tissue]] <- logCPM
  }

  cat('<details><summary><strong>PCA by Tissue (logCPM, Injury =', injury, ')</strong></summary>\n\n')

  VAR_FUN <- stats::var

  for (tissue in names(logCPM_list)) {
    cat("Current tissue:", tissue, "\n")
    logcpm_mat <- logCPM_list[[tissue]]
    
    cat(sprintf("→ %s (Injury = %s): %d genes, %d samples\n", tissue, injury, nrow(logcpm_mat), ncol(logcpm_mat)))

    gene_vars <- apply(logcpm_mat, 1, VAR_FUN, na.rm = TRUE)
    gene_vars <- gene_vars[gene_vars > 0]
    
    cat(sprintf("  └ Genes with non-zero variance: %d\n", length(gene_vars)))

    top_n <- floor(length(gene_vars) * 0.5)
    top_gene_names <- names(sort(gene_vars, decreasing = TRUE))[seq_len(top_n)]

    if (length(top_gene_names) < 2) {
      cat(sprintf("<p style='color:red;'>⚠️ Only %d variable genes found in %s (Injury = %s)</p>\n",
                  length(top_gene_names), tissue, injury))
      next
    }

    logcpm_mat <- logcpm_mat[top_gene_names, , drop = FALSE]
    if (nrow(logcpm_mat) < 2) next

    logcpm_t <- t(logcpm_mat)
    pca_res <- prcomp(logcpm_t, center = TRUE, scale. = TRUE)

    pc1_loadings <- pca_res$rotation[, "PC1"]
    aging_signature_list[[paste0(tissue, "_Injury", injury)]] <- list(
      Up_in_Aged = names(sort(pc1_loadings, decreasing = TRUE))[1:25],
      Down_in_Aged = names(sort(pc1_loadings, decreasing = FALSE))[1:25]
    )

    var_explained <- round(100 * (pca_res$sdev^2 / sum(pca_res$sdev^2)), 2)

    meta <- gene_filtered_list[[tissue]]@meta.data
    meta <- meta[meta$Injury == injury, ]
    meta <- as.data.frame(meta)
    colnames(meta) <- make.names(colnames(meta))
    required_cols <- c("ID", "Age", "Sex", "Injury", "Slide", "Batch")
    sample_annot <- unique(meta[, required_cols, drop = FALSE])
    rownames(sample_annot) <- sample_annot$ID
    sample_annot <- sample_annot[rownames(logcpm_t), , drop = FALSE]

    pca_df <- as.data.frame(pca_res$x[, 1:2])
    pca_df$ID <- rownames(pca_df)
    pca_df$Slide <- factor(sample_annot[["Slide"]])
    pca_df$Batch <- factor(sample_annot[["Batch"]])

    center <- colMeans(pca_df[, c("PC1", "PC2")])
    pca_df$Distance <- sqrt((pca_df$PC1 - center["PC1"])^2 + (pca_df$PC2 - center["PC2"])^2)
    threshold <- mean(pca_df$Distance) + 2 * sd(pca_df$Distance)
    pca_df$Outlier <- pca_df$Distance > threshold
    pca_df$Outlier_Label <- ifelse(pca_df$Outlier, "Outlier", "Normal")

    p <- ggplot(pca_df, aes(x = PC1, y = PC2, color = Slide, shape = Batch)) +
      geom_point(aes(size = Outlier, alpha = Outlier), stroke = 1.2) +
      geom_text_repel(aes(label = ID), size = 3.2, show.legend = FALSE) +
      scale_shape_manual(values = 1:length(unique(pca_df$Batch))) +
      scale_color_manual(values = colors_slide) +
      scale_size_manual(values = c("TRUE" = 4, "FALSE" = 2), guide = "none") +
      scale_alpha_manual(values = c("TRUE" = 1, "FALSE" = 0.6), guide = "none") +
      ggtitle(paste("PCA of", tissue, "- Injury =", injury)) +
      xlab(paste0("PC1 (", var_explained[1], "%)")) +
      ylab(paste0("PC2 (", var_explained[2], "%)")) +
      theme_minimal()

    print(p)

    if (any(pca_df$Outlier)) {
      outliers <- pca_df[pca_df$Outlier, c("ID", "PC1", "PC2", "Distance")]
      cat("<p><strong>⚠️ Outliers detected:</strong></p>\n")
      print(knitr::kable(outliers, format = "html", table.attr = "class='table table-condensed table-bordered'"))
    } else {
      cat("<p>No PCA outliers detected.</p>\n")
    }
  }

  cat('</details>\n\n')
}









## Subsetting only males


cat("<hr><h2>Male-only PCA Analyses</h2>\n")

for (injury in injury_levels) {
  cat(sprintf("<h3>Injury = %s (Males only)</h3>\n", injury))

  # Step 1: Build pseudobulk counts
  pseudobulk_counts <- list()

  for (tissue in names(gene_filtered_list)) {
    seurat_obj <- gene_filtered_list[[tissue]]
    seurat_obj <- subset(seurat_obj, subset = Injury == injury & Sex == 0)  # Males only

    if (ncol(seurat_obj) < 2) next

    DefaultAssay(seurat_obj) <- "RawCounts"
    counts <- GetAssayData(seurat_obj, slot = "counts")
    metadata <- seurat_obj@meta.data
    metadata$barcode <- rownames(metadata)

    if (!"ID" %in% colnames(metadata)) {
      cat(sprintf("<p><strong>Skipping %s because 'ID' not found in metadata.</strong></p>\n", tissue))
      next
    }

    split_cells <- base::split(metadata$barcode, f = metadata$ID)
    pseudobulk_matrix <- sapply(split_cells, function(cells) {
      Matrix::rowSums(counts[, cells, drop = FALSE])
    })

    pseudobulk_counts[[tissue]] <- pseudobulk_matrix
  }

  # Step 2: Normalize to logCPM
  logCPM_list <- list()
  for (tissue in names(pseudobulk_counts)) {
    counts_mat <- pseudobulk_counts[[tissue]]
    if (any(is.na(counts_mat)) || ncol(counts_mat) < 2) next

    dge <- edgeR::DGEList(counts = counts_mat)
    dge <- edgeR::calcNormFactors(dge)
    logCPM <- edgeR::cpm(dge, log = TRUE, prior.count = 1)
    logCPM_list[[tissue]] <- logCPM
  }

  # Step 3: PCA
  cat('<details><summary><strong>Male-only PCA by Tissue (Injury =', injury, ')</strong></summary>\n\n')
  VAR_FUN <- stats::var

  for (tissue in names(logCPM_list)) {
    cat("Current tissue:", tissue, "\n")
    logcpm_mat <- logCPM_list[[tissue]]

    gene_vars <- apply(logcpm_mat, 1, VAR_FUN, na.rm = TRUE)
    gene_vars <- gene_vars[gene_vars > 0]
    top_n <- floor(length(gene_vars) * 0.5)
    top_gene_names <- names(sort(gene_vars, decreasing = TRUE))[seq_len(top_n)]

    if (length(top_gene_names) < 2) next
    logcpm_mat <- logcpm_mat[top_gene_names, , drop = FALSE]
    logcpm_t <- t(logcpm_mat)

    pca_res <- prcomp(logcpm_t, center = TRUE, scale. = TRUE)
    var_explained <- round(100 * (pca_res$sdev^2 / sum(pca_res$sdev^2)), 2)

    meta <- gene_filtered_list[[tissue]]@meta.data
    meta <- meta[meta$Injury == injury & meta$Sex == 0, ]
    meta <- as.data.frame(meta)
    colnames(meta) <- make.names(colnames(meta))
    sample_annot <- unique(meta[, c("ID", "Age", "Sex", "Injury", "Slide", "Batch"), drop = FALSE])
    rownames(sample_annot) <- sample_annot$ID
    sample_annot <- sample_annot[rownames(logcpm_t), , drop = FALSE]

    pca_df <- as.data.frame(pca_res$x[, 1:2])
    pca_df$ID <- rownames(pca_df)
    pca_df$Age <- factor(sample_annot[["Age"]])
    pca_df$Sex <- factor(sample_annot[["Sex"]])
    pca_df$Injury <- factor(sample_annot[["Injury"]])

    center <- colMeans(pca_df[, c("PC1", "PC2")])
    pca_df$Distance <- sqrt((pca_df$PC1 - center["PC1"])^2 + (pca_df$PC2 - center["PC2"])^2)
    threshold <- mean(pca_df$Distance) + 2 * sd(pca_df$Distance)
    pca_df$Outlier <- pca_df$Distance > threshold

    # Scree plot
    var_df <- data.frame(
      PC = paste0("PC", seq_along(var_explained)),
      VarianceExplained = var_explained
    )[1:min(9, length(var_explained)), ]

    scree_plot <- ggplot(var_df, aes(x = PC, y = VarianceExplained)) +
      geom_bar(stat = "identity", fill = "darkgreen") +
      theme_minimal() +
      labs(title = paste("Scree Plot (Males Only):", tissue, "- Injury =", injury),
           y = "% Variance Explained", x = "Principal Components") +
      theme(axis.text.x = element_text(angle = 45, hjust = 1))

    print(scree_plot)

    # PCA scatter
    p <- ggplot(pca_df, aes(x = PC1, y = PC2, shape = Age)) +
      geom_point(aes(size = Outlier, alpha = Outlier), stroke = 1.2, color = "darkgreen") +
      geom_text_repel(aes(label = ID), size = 3.2, show.legend = FALSE) +
      scale_shape_manual(values = c("0" = 16, "1" = 17)) +
      scale_size_manual(values = c("TRUE" = 4, "FALSE" = 2), guide = "none") +
      scale_alpha_manual(values = c("TRUE" = 1, "FALSE" = 0.6), guide = "none") +
      ggtitle(paste("Male-only PCA of", tissue, "- Injury =", injury)) +
      xlab(paste0("PC1 (", var_explained[1], "%)")) +
      ylab(paste0("PC2 (", var_explained[2], "%)")) +
      theme_minimal()

    print(p)

    if (any(pca_df$Outlier)) {
      outliers <- pca_df[pca_df$Outlier, c("ID", "PC1", "PC2", "Distance")]
      cat("<p><strong>⚠️ Outliers detected (males only):</strong></p>\n")
      print(knitr::kable(outliers, format = "html", table.attr = "class='table table-condensed table-bordered'"))
    } else {
      cat("<p>No PCA outliers detected in male-only subset.</p>\n")
    }
  }

  cat('</details>\n\n')

  # Step 4: Heatmaps
  cat('<details><summary><strong>Heatmaps by Tissue (Injury =', injury, ', Males only)</strong></summary>\n\n')

  for (tissue in names(logCPM_list)) {
    logcpm <- logCPM_list[[tissue]]
    if (is.null(logcpm)) next

    gene_vars <- apply(logcpm, 1, stats::var, na.rm = TRUE)
    top_n <- max(10, floor(length(gene_vars) * 0.5))
    top_genes <- names(sort(gene_vars, decreasing = TRUE))[seq_len(top_n)]
    heatmap_data <- logcpm[top_genes, , drop = FALSE]

    metadata <- gene_filtered_list[[tissue]]@meta.data
    metadata <- metadata[metadata$Injury == injury & metadata$Sex == 0, ]
    metadata <- as.data.frame(metadata)
    colnames(metadata) <- make.names(colnames(metadata))
    annotation_df <- unique(metadata[, c("ID", "Age", "Sex", "Injury", "Slide", "Batch"), drop = FALSE])
    annotation_df <- annotation_df[match(colnames(logcpm), annotation_df$ID), ]

    local_colors_slide <- colors_slide[names(colors_slide) %in% annotation_df$Slide]
    local_colors_batch <- colors_batch[names(colors_batch) %in% annotation_df$Batch]

    rownames(annotation_df) <- annotation_df$ID
    annotation_df$ID <- NULL

    top_annotation <- HeatmapAnnotation(
      Age = annotation_df$Age,
      Sex = annotation_df$Sex,
      Injury = annotation_df$Injury,
      Slide = annotation_df$Slide,
      Batch = annotation_df$Batch,
      col = list(
        Age = colors_age,
        Sex = colors_sex,
        Injury = colors_injury,
        Slide = local_colors_slide,
        Batch = local_colors_batch
      ),
      annotation_height = unit(rep(0.5, 5), "cm")
    )

    col_fun <- circlize::colorRamp2(
      c(min(heatmap_data), mean(heatmap_data), max(heatmap_data)),
      c("navy", "white", "firebrick3")
    )

    cat(sprintf("<p><strong>Heatmap — %s (Injury = %s, Males only):</strong></p>\n", tissue, injury))

    print(Heatmap(
      heatmap_data,
      name = "Expression",
      top_annotation = top_annotation,
      col = col_fun,
      cluster_rows = TRUE,
      cluster_columns = TRUE,
      show_row_names = TRUE,
      show_column_names = TRUE
    ))
  }

  cat('</details>\n\n')
}





# 📦 New Chunk: PCA for Males Only (All Injuries Combined)

cat('<details><summary><strong>Male-only PCA by Tissue (All Injuries Combined)</strong></summary>\n\n')

for (tissue in names(gene_filtered_list)) {
  seurat_obj <- gene_filtered_list[[tissue]]
  seurat_obj <- subset(seurat_obj, subset = Sex == 0)  # ✅ filter males

  if (ncol(seurat_obj) < 2) next

  DefaultAssay(seurat_obj) <- "RawCounts"
  counts <- GetAssayData(seurat_obj, slot = "counts")
  metadata <- seurat_obj@meta.data
  metadata$barcode <- rownames(metadata)

  if (!"ID" %in% colnames(metadata)) {
    cat(sprintf("<p><strong>Skipping %s because 'ID' not found in metadata.</strong></p>\n", tissue))
    next
  }

  split_cells <- base::split(metadata$barcode, f = metadata$ID)
  pseudobulk_matrix <- sapply(split_cells, function(cells) {
    Matrix::rowSums(counts[, cells, drop = FALSE])
  })

  if (ncol(pseudobulk_matrix) < 2) next

  # Normalize and logCPM
  dge <- edgeR::DGEList(counts = pseudobulk_matrix)
  dge <- edgeR::calcNormFactors(dge)
  logCPM <- edgeR::cpm(dge, log = TRUE, prior.count = 1)

  # PCA
  gene_vars <- apply(logCPM, 1, stats::var, na.rm = TRUE)
  top_n <- max(10, floor(length(gene_vars) * 0.5))
  top_genes <- names(sort(gene_vars, decreasing = TRUE))[seq_len(top_n)]
  logcpm_mat <- logCPM[top_genes, , drop = FALSE]
  logcpm_t <- t(logcpm_mat)

  pca_res <- prcomp(logcpm_t, center = TRUE, scale. = TRUE)
  var_explained <- round(100 * (pca_res$sdev^2 / sum(pca_res$sdev^2)), 2)

  # Scree plot
  var_df <- data.frame(
    PC = paste0("PC", seq_along(var_explained)),
    VarianceExplained = var_explained
  )[1:min(9, length(var_explained)), ]

  scree_plot <- ggplot(var_df, aes(x = PC, y = VarianceExplained)) +
    geom_bar(stat = "identity", fill = "steelblue") +
    theme_minimal() +
    labs(title = paste("Scree Plot (Males Only):", tissue),
         y = "% Variance Explained", x = "Principal Components") +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))

  print(scree_plot)

  # Sample annotation
  metadata <- as.data.frame(metadata)
  metadata <- metadata[metadata$Sex == 0, ]
  colnames(metadata) <- make.names(colnames(metadata))
  annotation_df <- unique(metadata[, c("ID", "Age", "Sex", "Injury"), drop = FALSE])
  rownames(annotation_df) <- annotation_df$ID
  annotation_df <- annotation_df[rownames(logcpm_t), , drop = FALSE]

  # PCA plotting
  pca_df <- as.data.frame(pca_res$x[, 1:2])
  pca_df$ID <- rownames(pca_df)
  pca_df$Age <- factor(annotation_df[["Age"]])
  pca_df$Sex <- factor(annotation_df[["Sex"]])
  pca_df$Injury <- factor(annotation_df[["Injury"]])

  center <- colMeans(pca_df[, c("PC1", "PC2")])
  pca_df$Distance <- sqrt((pca_df$PC1 - center["PC1"])^2 + (pca_df$PC2 - center["PC2"])^2)
  threshold <- mean(pca_df$Distance) + 2 * sd(pca_df$Distance)
  pca_df$Outlier <- pca_df$Distance > threshold
  pca_df$Outlier_Label <- ifelse(pca_df$Outlier, "Outlier", "Normal")

  p <- ggplot(pca_df, aes(x = PC1, y = PC2, shape = Age, color = Injury)) +
    geom_point(aes(size = Outlier, alpha = Outlier), stroke = 1.2) +
    geom_text_repel(aes(label = ID), size = 3.2, show.legend = FALSE) +
    scale_shape_manual(values = c("0" = 16, "1" = 17)) +
    scale_size_manual(values = c("TRUE" = 4, "FALSE" = 2), guide = "none") +
    scale_alpha_manual(values = c("TRUE" = 1, "FALSE" = 0.6), guide = "none") +
    ggtitle(paste("Male-only PCA of", tissue, "(All Injuries)")) +
    xlab(paste0("PC1 (", var_explained[1], "%)")) +
    ylab(paste0("PC2 (", var_explained[2], "%)")) +
    theme_minimal()

  print(p)

  if (any(pca_df$Outlier)) {
    outliers <- pca_df[pca_df$Outlier, c("ID", "PC1", "PC2", "Distance")]
    cat("<p><strong>⚠️ Outliers detected (males only):</strong></p>\n")
    print(knitr::kable(outliers, format = "html", table.attr = "class='table table-condensed table-bordered'"))
  } else {
    cat("<p>No PCA outliers detected in male-only subset.</p>\n")
  }
}

cat('</details>\n\n')






cat('<details><summary><strong>Male-only PCA by Tissue (All Injuries Combined)</strong></summary>\n\n')

for (tissue in names(gene_filtered_list)) {
  seurat_obj <- gene_filtered_list[[tissue]]
  seurat_obj <- subset(seurat_obj, subset = Sex == 0)  # ✅ filter males

  if (ncol(seurat_obj) < 2) next

  DefaultAssay(seurat_obj) <- "RawCounts"
  counts <- GetAssayData(seurat_obj, slot = "counts")
  metadata <- seurat_obj@meta.data
  metadata$barcode <- rownames(metadata)

  if (!"ID" %in% colnames(metadata)) {
    cat(sprintf("<p><strong>Skipping %s because 'ID' not found in metadata.</strong></p>\n", tissue))
    next
  }

  split_cells <- base::split(metadata$barcode, f = metadata$ID)
  pseudobulk_matrix <- sapply(split_cells, function(cells) {
    Matrix::rowSums(counts[, cells, drop = FALSE])
  })

  if (ncol(pseudobulk_matrix) < 2) next

  # Normalize and logCPM
  dge <- edgeR::DGEList(counts = pseudobulk_matrix)
  dge <- edgeR::calcNormFactors(dge)
  logCPM <- edgeR::cpm(dge, log = TRUE, prior.count = 1)

  # PCA
  gene_vars <- apply(logCPM, 1, stats::var, na.rm = TRUE)
  top_n <- max(10, floor(length(gene_vars) * 0.5))
  top_genes <- names(sort(gene_vars, decreasing = TRUE))[seq_len(top_n)]
  logcpm_mat <- logCPM[top_genes, , drop = FALSE]
  logcpm_t <- t(logcpm_mat)

  pca_res <- prcomp(logcpm_t, center = TRUE, scale. = TRUE)
  var_explained <- round(100 * (pca_res$sdev^2 / sum(pca_res$sdev^2)), 2)

  # Sample annotation
  metadata <- as.data.frame(metadata)
  metadata <- metadata[metadata$Sex == 0, ]
  colnames(metadata) <- make.names(colnames(metadata))
  annotation_df <- unique(metadata[, c("ID", "Slide", "Batch"), drop = FALSE])
  rownames(annotation_df) <- annotation_df$ID
  annotation_df <- annotation_df[rownames(logcpm_t), , drop = FALSE]

  # PCA plotting
  pca_df <- as.data.frame(pca_res$x[, 1:2])
  pca_df$ID <- rownames(pca_df)
  pca_df$Slide <- factor(annotation_df[["Slide"]])
  pca_df$Batch <- factor(annotation_df[["Batch"]])

  center <- colMeans(pca_df[, c("PC1", "PC2")])
  pca_df$Distance <- sqrt((pca_df$PC1 - center["PC1"])^2 + (pca_df$PC2 - center["PC2"])^2)
  threshold <- mean(pca_df$Distance) + 2 * sd(pca_df$Distance)
  pca_df$Outlier <- pca_df$Distance > threshold
  pca_df$Outlier_Label <- ifelse(pca_df$Outlier, "Outlier", "Normal")

  p <- ggplot(pca_df, aes(x = PC1, y = PC2, color = Slide, shape = Batch)) +
    geom_point(aes(size = Outlier, alpha = Outlier), stroke = 1.2) +
    geom_text_repel(aes(label = ID), size = 3.2, show.legend = FALSE) +
    scale_size_manual(values = c("TRUE" = 4, "FALSE" = 2), guide = "none") +
    scale_alpha_manual(values = c("TRUE" = 1, "FALSE" = 0.6), guide = "none") +
    ggtitle(paste("Male-only PCA of", tissue, "(All Injuries)")) +
    xlab(paste0("PC1 (", var_explained[1], "%)")) +
    ylab(paste0("PC2 (", var_explained[2], "%)")) +
    theme_minimal()

  print(p)

  if (any(pca_df$Outlier)) {
    outliers <- pca_df[pca_df$Outlier, c("ID", "PC1", "PC2", "Distance")]
    cat("<p><strong>⚠️ Outliers detected (males only):</strong></p>\n")
    print(knitr::kable(outliers, format = "html", table.attr = "class='table table-condensed table-bordered'"))
  } else {
    cat("<p>No PCA outliers detected in male-only subset.</p>\n")
  }
}

cat('</details>\n\n')






# 📦 New Chunk: Heatmaps for Males Only (All Injuries Combined)

cat('<details><summary><strong>Heatmaps by Tissue (Males Only, All Injuries)</strong></summary>\n\n')

for (tissue in names(gene_filtered_list)) {
  seurat_obj <- gene_filtered_list[[tissue]]
  seurat_obj <- subset(seurat_obj, subset = Sex == 0)  # ✅ filter to males only

  if (ncol(seurat_obj) < 2) next

  DefaultAssay(seurat_obj) <- "RawCounts"
  counts <- GetAssayData(seurat_obj, slot = "counts")
  metadata <- seurat_obj@meta.data
  metadata$barcode <- rownames(metadata)

  if (!"ID" %in% colnames(metadata)) {
    cat(sprintf("<p><strong>Skipping %s because 'ID' not found in metadata.</strong></p>\n", tissue))
    next
  }

  # Aggregate counts by ID
  split_cells <- base::split(metadata$barcode, f = metadata$ID)
  pseudobulk_matrix <- sapply(split_cells, function(cells) {
    Matrix::rowSums(counts[, cells, drop = FALSE])
  })

  if (ncol(pseudobulk_matrix) < 2) next

  dge <- edgeR::DGEList(counts = pseudobulk_matrix)
  dge <- edgeR::calcNormFactors(dge)
  logCPM <- edgeR::cpm(dge, log = TRUE, prior.count = 1)

  # Select top 50% most variable genes
  gene_vars <- apply(logCPM, 1, stats::var, na.rm = TRUE)
  top_n <- max(10, floor(length(gene_vars) * 0.5))
  top_genes <- names(sort(gene_vars, decreasing = TRUE))[seq_len(top_n)]
  heatmap_data <- logCPM[top_genes, , drop = FALSE]

  # Prepare annotation
  metadata <- as.data.frame(metadata)
  metadata <- metadata[metadata$Sex == 0, ]
  colnames(metadata) <- make.names(colnames(metadata))
  annotation_df <- unique(metadata[, c("ID", "Age", "Sex", "Injury", "Slide", "Batch"), drop = FALSE])
  annotation_df <- annotation_df[match(colnames(logCPM), annotation_df$ID), ]

  # Filter color palettes
  local_colors_slide <- colors_slide[names(colors_slide) %in% annotation_df$Slide]
  local_colors_batch <- colors_batch[names(colors_batch) %in% annotation_df$Batch]

  rownames(annotation_df) <- annotation_df$ID
  annotation_df$ID <- NULL  # optional: remove ID if not used in annotation

  top_annotation <- HeatmapAnnotation(
    df = annotation_df[, c("Age", "Sex", "Injury", "Slide", "Batch")],
    col = list(
      Age = colors_age,
      Sex = colors_sex,
      Injury = colors_injury,
      Slide = local_colors_slide,
      Batch = local_colors_batch
    ),
    annotation_height = unit(rep(0.5, 5), "cm")
  )

  col_fun <- circlize::colorRamp2(
    c(min(heatmap_data), mean(heatmap_data), max(heatmap_data)),
    c("navy", "white", "firebrick3")
  )

  cat(sprintf("<p><strong>Heatmap — %s (Males Only, All Injuries):</strong></p>\n", tissue))

  print(Heatmap(
    heatmap_data,
    name = "Expression",
    top_annotation = top_annotation,
    col = col_fun,
    cluster_rows = TRUE,
    cluster_columns = TRUE,
    show_row_names = TRUE,
    show_column_names = TRUE,
    column_names_gp = grid::gpar(fontsize = 8)  # Show sample IDs
  ))
}

cat('</details>\n\n')


```



## 4.7 Downstream Analyses with Pseudobulking for PCA inspection 


```{r PseudobulkInjuryStratified2, echo=TRUE, message=FALSE, warning=FALSE, results='asis'}

# Convert factors if necessary
pca_results_all$Age <- as.factor(pca_results_all$Age)
pca_results_all$Sex <- as.factor(pca_results_all$Sex)
pca_results_all$Injury <- as.factor(pca_results_all$Injury)
pca_results_all$Slide <- as.factor(pca_results_all$Slide)
pca_results_all$Batch <- as.factor(pca_results_all$Batch)
pca_results_all$ID <- as.factor(pca_results_all$ID)



cat("<hr><h2>PCA Histograms and Boxplots</h2>\n")

group_vars <- c("Age", "Sex", "Slide", "Batch", "ID")

for (group in group_vars) {
  cat(sprintf('<details><summary><strong>Histograms of PC1 and PC2 by %s</strong></summary>\n\n', group))

  for (pc in c("PC1", "PC2")) {
    p <- ggplot(pca_results_all, aes_string(x = pc, fill = group)) +
      geom_histogram(binwidth = 0.5, color = "black", alpha = 0.8, position = "identity") +
      ggtitle(sprintf("Histogram of %s by %s", pc, group)) +
      xlab(sprintf("%s Value", pc)) +
      ylab("Frequency") +
      theme_minimal()
    print(p)
  }

  cat('</details>\n\n')
}




cat('<details><summary><strong>Boxplots of PC1 and PC2 by Age, Sex, Batch, Slide, and ID</strong></summary>\n\n')

# 1. Utility: summary boxplot (2 groups)
plot_box_with_summary <- function(pca_var, group_var, group_labels) {
  formula <- as.formula(paste(pca_var, "~", group_var))
  bp <- boxplot(formula,
                data = pca_results_all,
                main = paste(pca_var, "vs", group_var),
                col = c("skyblue", "orange"))

  text(x = 1:2, y = bp$stats[3, ], labels = round(bp$stats[3, ], 1), pos = 3, cex = 0.9)
  text(x = 1:2,
       y = par("usr")[3] - 0.2 * diff(par("usr")[3:4]),
       labels = paste("n =", bp$n),
       xpd = TRUE)

  summary_table <- data.frame(
    Group = group_labels,
    N = bp$n,
    Min = round(bp$stats[1, ], 2),
    Q1 = round(bp$stats[2, ], 2),
    Median = round(bp$stats[3, ], 2),
    Q3 = round(bp$stats[4, ], 2),
    Max = round(bp$stats[5, ], 2)
  )

  cat(sprintf("<details><summary><strong>Boxplot Summary (%s vs %s)</strong></summary>\n\n", pca_var, group_var))
  print(knitr::kable(summary_table, format = "html", table.attr = "class='table table-condensed table-striped'"))
  cat("</details>\n\n")
}

# 2. Utility: general boxplot (multi-levels, no summary)
plot_box_no_table <- function(pca_var, group_var) {
  formula <- as.formula(paste(pca_var, "~", group_var))
  boxplot(formula,
          data = pca_results_all,
          main = paste(pca_var, "vs", group_var),
          col = "skyblue")
}

# 3. Utility: boxplot for ID with rotated x-axis labels
plot_box_id <- function(pca_var) {
  pca_results_all$ID <- factor(pca_results_all$ID, levels = desired_sample_order)
  par(mar = c(8, 4, 4, 2) + 0.1)
  boxplot(as.formula(paste(pca_var, "~ ID")),
          data = pca_results_all,
          main = paste(pca_var, "vs ID"),
          col = "skyblue",
          las = 2,
          cex.axis = 0.7,
          xlab = "", ylab = pca_var)
}

# 4. Loop through groupings and PCs
groupings <- list(
  Age = c("Young (0)", "Aged (1)"),
  Sex = c("Female (0)", "Male (1)"),
  Batch = c("Batch 0", "Batch 1")
)

for (group_var in names(groupings)) {
  for (pc in c("PC1", "PC2")) {
    plot_box_with_summary(pc, group_var, groupings[[group_var]])
  }
}

# 5. Slide — multi-group, no table
for (pc in c("PC1", "PC2")) {
  plot_box_no_table(pc, "Slide")
}

# 6. ID — special case with sample order
for (pc in c("PC1", "PC2")) {
  plot_box_id(pc)
}

cat('</details>\n\n')





cat('<details><summary><strong>PC1 vs PC2 Scatterplots by Metadata</strong></summary>\n\n')

library(ggplot2)

# Variables to loop over
color_vars <- c("Age", "Sex", "Batch", "Slide", "ID")

# Loop over each variable and plot
for (var in color_vars) {
  cat(sprintf("<details><summary><strong>Colored by %s</strong></summary>\n\n", var))

  if (var %in% c("Age", "Sex")) {
    # Base R plot (as in original)
    print(
      plot(pca_results_all$PC1, pca_results_all$PC2,
           col = as.factor(pca_results_all[[var]]),
           pch = 19,
           main = paste("PC1 vs PC2 colored by", var),
           xlab = "PC1", ylab = "PC2")
    )
  } else {
    # ggplot version
    p <- ggplot(pca_results_all, aes_string(x = "PC1", y = "PC2", color = var)) +
      geom_point(size = 2, alpha = 0.8) +
      labs(title = paste("PC1 vs PC2 colored by", var)) +
      theme_minimal()

    if (var == "ID") {
      # Hide legend if too many samples
      p <- p + theme(legend.position = "none")
    }

    print(p)
  }

  cat("</details>\n\n")
}

# Additional: Total Read Count from first tissue (used in earlier code)
cat("<details><summary><strong>Colored by Total Read Count</strong></summary>\n\n")

# Get total counts from first tissue (as before)
total_counts <- colSums(pseudobulk_counts_list[[1]])
pca_df <- pca_results_all
pca_df$TotalReadCount <- total_counts[as.character(pca_df$ID)]

# Plot
p <- ggplot(pca_df, aes(x = PC1, y = PC2, color = TotalReadCount)) +
  geom_point(size = 2, alpha = 0.9) +
  scale_color_gradient(low = "lightblue", high = "red") +
  labs(title = "PC1 vs PC2 colored by Total Read Counts",
       color = "Read Count") +
  theme_minimal()

print(p)

cat("</details>\n\n")
cat('</details>\n\n')





# Run ANOVA models
library(broom)

# Ensure ReadCount is included
if (!"ReadCount" %in% colnames(pca_results_all)) {
  pca_results_all$ReadCount <- colSums(pseudobulk_counts_list[[1]])[as.character(pca_results_all$ID)]
}

# Define all models and labels
predictors <- c("ID", "Batch", "Slide", "ReadCount")
pcs <- c("PC1", "PC2")

# Loop through predictors and PCs
for (pc in pcs) {
  for (var in predictors) {
    formula <- as.formula(paste(pc, "~", var))
    model <- aov(formula, data = pca_results_all)
    model_table <- tidy(model)

    cat(sprintf("<details><summary><strong>ANOVA Summary: %s ~ %s</strong></summary>\n\n", pc, var))
    print(knitr::kable(model_table, format = "html", table.attr = "class='table table-condensed table-striped'"))
    cat("</details>\n\n")
  }
}









# Run correlation tests
cor_list <- list(
  "PC1 ~ Age" = cor.test(as.numeric(as.character(pca_results_all$Age)), pca_results_all$PC1),
  "PC2 ~ Age" = cor.test(as.numeric(as.character(pca_results_all$Age)), pca_results_all$PC2),
  "PC1 ~ Sex" = cor.test(as.numeric(as.character(pca_results_all$Sex)), pca_results_all$PC1),
  "PC2 ~ Sex" = cor.test(as.numeric(as.character(pca_results_all$Sex)), pca_results_all$PC2),
  "PC1 ~ Slide" = cor.test(as.numeric(as.character(pca_results_all$Slide)), pca_results_all$PC1),
  "PC2 ~ Slide" = cor.test(as.numeric(as.character(pca_results_all$Slide)), pca_results_all$PC2),
  "PC1 ~ Batch" = cor.test(as.numeric(as.character(pca_results_all$Batch)), pca_results_all$PC1),
  "PC2 ~ Batch" = cor.test(as.numeric(as.character(pca_results_all$Batch)), pca_results_all$PC2),
  "PC1 ~ ReadCount" = cor.test(pca_results_all$ReadCount, pca_results_all$PC1),
  "PC2 ~ ReadCount" = cor.test(pca_results_all$ReadCount, pca_results_all$PC2)

)


# Convert to summary table
cor_table <- do.call(rbind, lapply(names(cor_list), function(name) {
  res <- cor_list[[name]]
  data.frame(
    Test = name,
    Estimate = round(res$estimate, 4),
    `p-value` = signif(res$p.value, 4),
    `95% CI Lower` = round(res$conf.int[1], 4),
    `95% CI Upper` = round(res$conf.int[2], 4),
    stringsAsFactors = FALSE
  )
}))

# Output as collapsible HTML
cat("<details><summary><strong>Correlation Summary: Age Sex Slide Batch and ReadCount vs PC1/PC2</strong></summary>\n\n")
cat(knitr::kable(cor_table, format = "html", table.attr = "class='table table-striped'"))
cat("\n</details>\n\n")








# Create binary PC1 variable
pca_results_all$PC1_binary <- ifelse(pca_results_all$PC1 > 1, 1, 0)

# Add ReadCount from pseudobulk tissue (if not already added)
if (!"ReadCount" %in% colnames(pca_results_all)) {
  read_counts <- colSums(pseudobulk_counts_list[[1]])  # Use first tissue
  pca_results_all$ReadCount <- read_counts[as.character(pca_results_all$ID)]
}

# Define model formulas as named list
model_formulas <- list(
  "Age + Sex + Injury + Tissue + Slide + Batch" = PC1_binary ~ Age + Sex + Injury + Tissue + Slide + Batch,
  "Slide + Batch" = PC1_binary ~ Slide + Batch,
  "Batch only" = PC1_binary ~ Batch,
  "Slide only" = PC1_binary ~ Slide,
  "ID only" = PC1_binary ~ ID,
  "ReadCount only" = PC1_binary ~ ReadCount
)

# Fit and print each model
for (label in names(model_formulas)) {
  formula <- model_formulas[[label]]
  model <- glm(formula, data = pca_results_all, family = binomial)

  cat(sprintf("<details><summary><strong>Logistic Model: PC1_binary ~ %s</strong></summary>\n\n", label))
  cat("<pre>\n")
  print(summary(model))
  cat("</pre>\n</details>\n\n")
}






# Visual confirmation
ggplot(pca_results_all, aes(x = PC1, fill = factor(PC1_binary))) +
  geom_histogram(binwidth = 1, color = "black", alpha = 0.6, position = "identity") +
  scale_fill_manual(values = c("0" = "grey", "1" = "darkred"), name = "PC1 Group") +
  geom_vline(xintercept = 1, linetype = "dashed", color = "black") +
  ggtitle("PC1 Histogram with Binary Threshold at 1") +
  xlab("PC1 Value") + ylab("Frequency") +
  theme_minimal()





# Ensure ReadCount is present
if (!"ReadCount" %in% colnames(pca_results_all)) {
  read_counts <- colSums(pseudobulk_counts_list[[1]])
  pca_results_all$ReadCount <- read_counts[as.character(pca_results_all$ID)]
}

# Make sure all grouping variables are factors
factor_vars <- c("Age", "Sex", "Injury", "Tissue", "Slide", "Batch", "ID")
pca_results_all[factor_vars] <- lapply(pca_results_all[factor_vars], function(x) factor(x, exclude = NULL))

# Define model formulas
model_formulas_pc2 <- list(
  "Age + Sex + Injury + Tissue + Batch + Slide" = PC2 ~ Age + Sex + Injury + Tissue + Batch + Slide,
  "Age + Sex + Injury" = PC2 ~ Age + Sex + Injury,
  "Batch + Slide" = PC2 ~ Batch + Slide,
  "Batch only" = PC2 ~ Batch,
  "Slide only" = PC2 ~ Slide,
  "ID only" = PC2 ~ ID,
  "ReadCount only" = PC2 ~ ReadCount
)

# Fit and print each model
for (label in names(model_formulas_pc2)) {
  formula <- model_formulas_pc2[[label]]

  # Check factor levels where relevant
  vars_in_model <- all.vars(formula)[-1]
  skip_model <- any(sapply(vars_in_model, function(var) {
    is.factor(pca_results_all[[var]]) && length(unique(pca_results_all[[var]])) < 2
  }))

  if (skip_model) {
    cat(sprintf("<details><summary><strong>Skipped Model: PC2 ~ %s</strong></summary>\n\n", label))
    cat("<em>Model skipped due to insufficient levels in one or more factor variables.</em>\n</details>\n\n")
    next
  }

  # Fit model
  model_try <- try(lm(formula, data = pca_results_all), silent = TRUE)

  if (inherits(model_try, "try-error")) {
    cat(sprintf("<details><summary><strong>Failed Model: PC2 ~ %s</strong></summary>\n\n", label))
    cat("<em>Model failed to fit due to an internal error.</em>\n</details>\n\n")
  } else {
    cat(sprintf("<details><summary><strong>Linear Model: PC2 ~ %s</strong></summary>\n\n", label))
    cat("<pre>\n")
    print(summary(model_try))
    cat("</pre>\n</details>\n\n")
  }
}








# Define model types and their formulas
per_tissue_formulas <- list(
  "PC1_binary" = list(
    "Age + Sex + Injury",
    "Age + Sex",
    "Age",
    "Sex",
    "Batch",
    "Slide",
    "Injury",
    "ReadCount"
  ),
  "PC2" = list(
    "Age + Sex + Injury",
    "Age + Sex",
    "Age",
    "Sex",
    "Batch",
    "Slide",
    "Injury",
    "ReadCount"
  )
)

# Model family per target
model_families <- list(
  "PC1_binary" = binomial,
  "PC2" = gaussian
)

# Main loop over targets and formulas
for (target in names(per_tissue_formulas)) {
  model_type <- if (target == "PC1_binary") "Logistic" else "Linear"
  family <- model_families[[target]]

  for (formula_str in per_tissue_formulas[[target]]) {
    full_formula <- as.formula(paste(target, "~", formula_str))
    header <- sprintf("<h3>%s: %s ~ %s (by Tissue)</h3>\n", model_type, target, formula_str)
    cat(header)

    by(pca_results_all, pca_results_all$Tissue, function(sub) {
      cat(sprintf("<details><summary><strong>%s</strong></summary>\n\n<pre>\n", unique(sub$Tissue)))
      model <- if (identical(family, binomial)) {
        glm(full_formula, data = sub, family = binomial)
      } else {
        lm(full_formula, data = sub)
      }
      print(summary(model))
      cat("</pre>\n</details>\n\n")
    })
  }
}







library(broom)

# Define model types, formulas, and metadata
models_to_run <- list(
  "PC1_binary_logit" = list(
    response = "PC1_binary", family = binomial,
    formulas = list(
      "Age + Sex" = "Age + Sex",
      "Batch" = "Batch",
      "Slide" = "Slide",
      "ID" = "ID",
      "ReadCount" = "ReadCount"
    )
  ),
  "PC2_lm" = list(
    response = "PC2", family = NULL,
    formulas = list(
      "Age + Sex" = "Age + Sex",
      "Batch" = "Batch",
      "Slide" = "Slide",
      "ID" = "ID",
      "ReadCount" = "ReadCount"
    )
  )
)


# Loop over each model type and formula
for (model_group in names(models_to_run)) {
  model_info <- models_to_run[[model_group]]
  response <- model_info$response
  family <- model_info$family
  formulas <- model_info$formulas
  
  for (label in names(formulas)) {
    rhs <- formulas[[label]]
    full_formula <- as.formula(paste(response, "~", rhs))
    
    model_results <- lapply(split(pca_results_all, pca_results_all$Tissue), function(df) {
      model <- if (!is.null(family)) {
        glm(full_formula, data = df, family = family)
      } else {
        lm(full_formula, data = df)
      }
      tidy(model)
    })
    
    df_results <- do.call(rbind, Map(cbind, Tissue = names(model_results), model_results))
    
    # Filter terms of interest
    term_pattern <- if (label %in% c("ID", "Slide", "Batch")) paste0("^", label) else rhs
    selected_terms <- subset(df_results, grepl(term_pattern, term))
    selected_summary <- selected_terms[, c("Tissue", "term", "estimate", "std.error", "p.value")]
    selected_summary <- selected_summary[order(selected_summary$p.value), ]
    
    # Print in collapsible format
    cat(sprintf("<details><summary><strong>%s ~ %s (%s)</strong></summary>\n\n", response, rhs, ifelse(is.null(family), "Linear", "Logistic")))
    cat(knitr::kable(selected_summary, format = "html", table.attr = "class='table table-condensed table-striped'"))
    cat("</details>\n\n")
  }
}






library(broom)
library(ggplot2)

# Define reusable model + tidy extractor
safe_model_summary <- function(formula_str, data_list, model_type = c("lm", "glm")) {
  model_type <- match.arg(model_type)
  formula <- as.formula(formula_str)

  summary_list <- lapply(data_list, function(df) {
    model <- tryCatch({
      if (model_type == "lm") lm(formula, data = df)
      else glm(formula, data = df, family = binomial)
    }, error = function(e) NULL)
    if (!is.null(model)) broom::tidy(model) else NULL
  })
  summary_list <- summary_list[!sapply(summary_list, is.null)]
  do.call(rbind, Map(cbind, Tissue = names(summary_list), summary_list))
}

# Unified plotting function
plot_sd_effect <- function(df, term_filter, title, xlab_text) {
  df_filtered <- subset(df, grepl(term_filter, term) & is.finite(std.error) & std.error < 2)
  df_filtered$direction <- ifelse(df_filtered$estimate > 0, "Positive", "Negative")

  ggplot(df_filtered, aes(x = estimate, y = reorder(Tissue, estimate), color = direction)) +
    geom_point(size = 3) +
    geom_errorbarh(aes(xmin = estimate - 1.96 * std.error,
                       xmax = estimate + 1.96 * std.error), height = 0.2) +
    geom_vline(xintercept = 0, linetype = "dashed") +
    scale_color_manual(values = c("Positive" = "firebrick", "Negative" = "steelblue")) +
    xlab(xlab_text) +
    ylab("Tissue") +
    ggtitle(title) +
    theme_minimal(base_size = 12)
}

# Prepare once
split_data <- split(pca_results_all, pca_results_all$Tissue)

# Define models and plot settings
model_specs <- list(
  list(formula = "PC1_binary ~ Age",    type = "glm", filter = "^Age",   title = "PC1_binary ~ Age (Logistic)", xlab = "Log-Odds Estimate for Age (PC1_binary)"),
  list(formula = "PC1_binary ~ Batch",  type = "glm", filter = "^Batch", title = "PC1_binary ~ Batch (Logistic)", xlab = "Log-Odds Estimate for Batch (PC1_binary)"),
  list(formula = "PC2 ~ Age",           type = "lm",  filter = "^Age",   title = "PC2 ~ Age (Linear)", xlab = "Effect of Age on PC2"),
  list(formula = "PC2 ~ Batch",         type = "lm",  filter = "^Batch", title = "PC2 ~ Batch (Linear)", xlab = "Effect of Batch on PC2")
)

# Run models and plots
for (spec in model_specs) {
  model_df <- safe_model_summary(spec$formula, split_data, model_type = spec$type)
  cat(sprintf("<details><summary><strong>%s</strong></summary>\n\n", spec$title))
  print(plot_sd_effect(model_df, spec$filter, spec$title, spec$xlab))
  cat("</details>\n\n")
}






# Try per-tissue PCA correlation

library(dplyr)

# Safe correlation test function that returns named values
safe_cor_test <- function(x, y) {
  out <- tryCatch({
    test <- suppressWarnings(cor.test(as.numeric(as.character(x)), y))
    c(estimate = as.numeric(test$estimate), p.value = test$p.value)
  }, error = function(e) c(estimate = NA_real_, p.value = NA_real_))
  names(out) <- c("estimate", "p.value")
  return(out)
}

# Initialize results
cor_list <- list(Age = list(), Batch = list(), Slide = list(), ReadCount = list())

for (tissue in unique(pca_results_all$Tissue)) {
  df <- subset(pca_results_all, Tissue == tissue)

  # Age
  age1 <- safe_cor_test(df$Age, df$PC1)
  age2 <- safe_cor_test(df$Age, df$PC2)
  cor_list$Age[[tissue]] <- data.frame(
    Tissue = tissue,
    cor_PC1_Age = age1["estimate"],
    pval_PC1_Age = age1["p.value"],
    cor_PC2_Age = age2["estimate"],
    pval_PC2_Age = age2["p.value"]
  )

  # Batch
  batch1 <- safe_cor_test(df$Batch, df$PC1)
  batch2 <- safe_cor_test(df$Batch, df$PC2)
  cor_list$Batch[[tissue]] <- data.frame(
    Tissue = tissue,
    cor_PC1_Batch = batch1["estimate"],
    pval_PC1_Batch = batch1["p.value"],
    cor_PC2_Batch = batch2["estimate"],
    pval_PC2_Batch = batch2["p.value"]
  )

  # Slide
  slide1 <- safe_cor_test(df$Slide, df$PC1)
  slide2 <- safe_cor_test(df$Slide, df$PC2)
  cor_list$Slide[[tissue]] <- data.frame(
    Tissue = tissue,
    cor_PC1_Slide = slide1["estimate"],
    pval_PC1_Slide = slide1["p.value"],
    cor_PC2_Slide = slide2["estimate"],
    pval_PC2_Slide = slide2["p.value"]
  )

  # ReadCount
  read1 <- safe_cor_test(df$ReadCount, df$PC1)
  read2 <- safe_cor_test(df$ReadCount, df$PC2)
  cor_list$ReadCount[[tissue]] <- data.frame(
    Tissue = tissue,
    cor_PC1_ReadCount = read1["estimate"],
    pval_PC1_ReadCount = read1["p.value"],
    cor_PC2_ReadCount = read2["estimate"],
    pval_PC2_ReadCount = read2["p.value"]
  )
}

# Combine and show tables
cor_age_df <- do.call(rbind, cor_list$Age)
cor_batch_df <- do.call(rbind, cor_list$Batch)
cor_slide_df <- do.call(rbind, cor_list$Slide)
cor_read_df <- do.call(rbind, cor_list$ReadCount)

cat("<details><summary><strong>Per-Tissue Correlation of PC1/PC2 with Age</strong></summary>\n\n")
cat(kable(cor_age_df, format = "html", digits = 4, table.attr = "class='table table-striped table-condensed'"))
cat("</details>\n\n")

cat("<details><summary><strong>Per-Tissue Correlation of PC1/PC2 with Batch</strong></summary>\n\n")
cat(kable(cor_batch_df, format = "html", digits = 4, table.attr = "class='table table-striped table-condensed'"))
cat("</details>\n\n")

cat("<details><summary><strong>Per-Tissue Correlation of PC1/PC2 with Slide</strong></summary>\n\n")
cat(kable(cor_slide_df, format = "html", digits = 4, table.attr = "class='table table-striped table-condensed'"))
cat("</details>\n\n")

cat("<details><summary><strong>Per-Tissue Correlation of PC1/PC2 with ReadCount</strong></summary>\n\n")
cat(kable(cor_read_df, format = "html", digits = 4, table.attr = "class='table table-striped table-condensed'"))
cat("</details>\n")













# Print summary of Gene Loadings per tissue for all samples


cat("<details><summary><strong>Top Gene Loadings for PC1 and PC2 (per Tissue)</strong></summary>\n\n")

pca_loadings_list <- list()  # Store V matrices per tissue

for (tissue in names(logCPM_list)) {
  logcpm <- logCPM_list[[tissue]]
  if (is.null(logcpm) || ncol(logcpm) < 2) next

  # Variance filtering: keep top 50% most variable genes
  gene_vars <- apply(logcpm, 1, stats::var, na.rm = TRUE)
  gene_vars <- gene_vars[gene_vars > 0]

  top_n <- floor(length(gene_vars) * 0.5)
  top_genes <- names(sort(gene_vars, decreasing = TRUE))[seq_len(top_n)]
  logcpm_sub <- logcpm[top_genes, , drop = FALSE]

  # PCA (transpose: samples as rows)
  pca_res <- prcomp(t(logcpm_sub), center = TRUE, scale. = TRUE)

  # Loadings matrix (V): genes × PCs
  V <- as.data.frame(pca_res$rotation)
  V$Gene <- rownames(V)
  pca_loadings_list[[tissue]] <- V

  # Display collapsible: tissue name
  cat(sprintf("<details><summary><strong>%s — Top 30 Genes by PC</strong></summary>\n\n", tissue))

  # Loop through each PC
  pcs <- colnames(V)[!colnames(V) %in% "Gene"]
  for (pc in pcs) {
    top_genes_pc <- V[order(abs(V[[pc]]), decreasing = TRUE), ][1:30, c("Gene", pc)]
    colnames(top_genes_pc)[2] <- "Loading"

    cat(sprintf("<details><summary>Top 30 Genes for %s</summary>\n\n", pc))
    print(knitr::kable(top_genes_pc, format = "html", table.attr = "class='table table-condensed table-striped'"))
    cat("</details>\n\n")
  }

  cat("</details>\n\n")
}


cat("</details>\n\n")






# Fit PC1 ~ ReadCount per tissue and extract tidy summaries
lm_pc1_readcount_summary <- lapply(split(pca_results_all, pca_results_all$Tissue), function(df) {
  if (!"ReadCount" %in% colnames(df)) return(NULL)
  model <- glm(PC1_binary ~ ReadCount, data = df, family = binomial)
  tidy(model)
})

# Combine into one table and filter to ReadCount term
lm_pc1_readcount_df <- do.call(rbind, Map(cbind, Tissue = names(lm_pc1_readcount_summary), lm_pc1_readcount_summary))
readcount_terms <- subset(lm_pc1_readcount_df, term == "ReadCount")

# Round for display
readcount_terms <- readcount_terms[, c("Tissue", "estimate", "std.error", "statistic", "p.value")]
readcount_terms[, 2:5] <- round(readcount_terms[, 2:5], 3)

# Sort by p-value
readcount_terms <- readcount_terms[order(readcount_terms$p.value), ]

# Clean rownames
rownames(readcount_terms) <- NULL

# Output final collapsible table
cat("<details><summary><strong>PC1 ~ ReadCount (Linear Regression Summary)</strong></summary>\n\n")
cat(knitr::kable(readcount_terms, format = "html", table.attr = "class='table table-condensed table-striped'"))
cat("</details>\n\n")





```



### 4.7.1 Downstream Analyses with Pseudobulking for PCA inspection males only


```{r PseudobulkInjuryStratified3, echo=TRUE, message=FALSE, warning=FALSE, results='asis'}

pca_results_all <- subset(pca_results_all, Sex != 1)

# Convert factors if necessary
pca_results_all$Age <- as.factor(pca_results_all$Age)
pca_results_all$Sex <- as.factor(pca_results_all$Sex)
pca_results_all$Injury <- as.factor(pca_results_all$Injury)
pca_results_all$Slide <- as.factor(pca_results_all$Slide)
pca_results_all$Batch <- as.factor(pca_results_all$Batch)
pca_results_all$ID <- as.factor(pca_results_all$ID)

# Start collapsible section
cat("<details><summary><strong>PC1 and PC2 — Histograms by Age and Batch</strong></summary>\n\n")

# Define a reusable function for histogram plot
plot_pca_histogram <- function(pc, group_var) {
  ggplot(pca_results_all, aes_string(x = pc, fill = group_var)) +
    geom_histogram(binwidth = 0.5, color = "black", alpha = 0.8, position = "identity") +
    ggtitle(sprintf("Histogram of %s by %s", pc, group_var)) +
    xlab(sprintf("%s Value", pc)) + ylab("Frequency") +
    theme_minimal()
}

# Variables to loop over
pcs <- c("PC1", "PC2")
groupings <- c("Age", "Batch")

# Loop over PC1/PC2 × Grouping
for (pc in pcs) {
  for (group in groupings) {
    print(plot_pca_histogram(pc, group))
  }
}

# Close collapsible section
cat("</details>\n\n")


cat("<details><summary><strong>PC1 and PC2 — Visualizations by Metadata</strong></summary>\n\n")

# ------------------------------
# Define variable-to-labels mapping
meta_groups <- list(
  Age = c("Young (0)", "Aged (1)"),
  Sex = c("Female (0)", "Male (1)"),
  Batch = c("Batch 0", "Batch 1")
)

# ------------------------------
# Loop over Age, Sex, Batch: Boxplots + Histograms + PC1 vs PC2 scatter
for (meta_var in names(meta_groups)) {
  labels <- meta_groups[[meta_var]]

  cat(sprintf("<h4>%s</h4>\n\n", meta_var))

  # Boxplots
  plot_box_with_summary("PC1", meta_var, labels)
  plot_box_with_summary("PC2", meta_var, labels)


  # Histograms
  print(
    ggplot(pca_results_all, aes_string(x = "PC1", fill = meta_var)) +
      geom_histogram(binwidth = 0.5, color = "black", alpha = 0.8, position = "identity") +
      ggtitle(sprintf("Histogram of PC1 by %s", meta_var)) +
      xlab("PC1 Value") + ylab("Frequency") +
      theme_minimal()
  )

  print(
    ggplot(pca_results_all, aes_string(x = "PC2", fill = meta_var)) +
      geom_histogram(binwidth = 0.5, color = "black", alpha = 0.8, position = "identity") +
      ggtitle(sprintf("Histogram of PC2 by %s", meta_var)) +
      xlab("PC2 Value") + ylab("Frequency") +
      theme_minimal()
  )

  # Scatterplot PC1 vs PC2 colored by variable
  print(
    ggplot(pca_results_all, aes_string(x = "PC1", y = "PC2", color = meta_var)) +
      geom_point(size = 2, alpha = 0.9) +
      labs(
        title = sprintf("PC1 vs PC2 colored by %s", meta_var),
        x = "PC1", y = "PC2", color = meta_var
      ) +
      theme_minimal() +
      theme(legend.title = element_text(size = 10),
            legend.text = element_text(size = 9))
  )
}

# ------------------------------
# Slide (no labels)
cat("<h4>Slide</h4>\n\n")
plot_box_no_table("PC1", "Slide")
plot_box_no_table("PC2", "Slide")

print(
  ggplot(pca_results_all, aes(x = PC1, y = PC2, color = Slide)) +
    geom_point(size = 2, alpha = 0.9) +
    labs(title = "PC1 vs PC2 colored by Slide", x = "PC1", y = "PC2", color = "Slide") +
    theme_minimal() +
    theme(legend.title = element_text(size = 10),
          legend.text = element_text(size = 9))
)

# ------------------------------
# Sample ID (ordered boxplot only)
cat("<h4>Sample ID</h4>\n\n")
plot_box_id("PC1")
plot_box_id("PC2")

cat("</details>\n\n")








# Match ReadCount using ID

total_counts <- colSums(pseudobulk_counts_list[[1]])
pca_df <- pca_results_all
pca_df$TotalReadCount <- total_counts[as.character(pca_df$ID)]

# Plot using ggplot2
ggplot(pca_df, aes(x = PC1, y = PC2, color = TotalReadCount)) +
  geom_point(size = 2, alpha = 0.9) +
  scale_color_gradient(low = "lightblue", high = "red") +
  labs(
    title = "PC1 vs PC2 (Males Only, Colored by Read Count)",
    x = "PC1", y = "PC2", color = "Read Count"
  ) +
  theme_minimal() +
  theme(
    legend.title = element_text(size = 10),
    legend.text = element_text(size = 9)
  )











# Variables to correlate with PC1 and PC2
cor_vars <- c("Age", "Sex", "Batch", "Slide", "ReadCount")

# Function to perform correlation test and return summary
cor_summary_table <- function(varname) {
  v_numeric <- as.numeric(as.character(pca_results_all[[varname]]))
  
  cor_pc1 <- cor.test(v_numeric, pca_results_all$PC1)
  cor_pc2 <- cor.test(v_numeric, pca_results_all$PC2)
  
  df <- data.frame(
    PC = c("PC1", "PC2"),
    Correlation = c(cor_pc1$estimate, cor_pc2$estimate),
    CI_lower = c(cor_pc1$conf.int[1], cor_pc2$conf.int[1]),
    CI_upper = c(cor_pc1$conf.int[2], cor_pc2$conf.int[2]),
    p_value = c(cor_pc1$p.value, cor_pc2$p.value)
  )
  
  return(df)
}

# Loop through all variables and output collapsible summary
for (var in cor_vars) {
  cor_table <- cor_summary_table(var)
  
  cat(sprintf("<details><summary><strong>Correlation: %s vs PC1 and PC2</strong></summary>\n\n", var))
  cat(knitr::kable(cor_table, format = "html", digits = 4,
                   table.attr = "class='table table-striped table-condensed'"))
  cat("</details>\n\n")
}





# Ensure binary classification for PC1
pca_results_all$PC1_binary <- ifelse(pca_results_all$PC1 > 1, 1, 0)

# Define logistic regression models for PC1_binary
pc1_logit_models <- list(
  "Age + Injury + Tissue + Batch + Slide" = PC1_binary ~ Age + Injury + Tissue + Batch + Slide,
  "Age + Injury + Tissue"                 = PC1_binary ~ Age + Injury + Tissue,
  "Age + Injury"                          = PC1_binary ~ Age + Injury,
  "Age only"                              = PC1_binary ~ Age,
  "Batch + Slide"                         = PC1_binary ~ Batch + Slide,
  "Batch only"                            = PC1_binary ~ Batch,
  "Slide only"                            = PC1_binary ~ Slide
)

# Define linear regression models for PC2
pc2_linear_models <- list(
  "Age + Injury + Tissue"                = PC2 ~ Age + Injury + Tissue,
  "Age + Injury"                         = PC2 ~ Age + Injury,
  "Age only"                             = PC2 ~ Age,
  "Batch + Slide + Tissue"               = PC2 ~ Batch + Slide + Tissue,
  "Batch + Slide"                        = PC2 ~ Batch + Slide,
  "Batch only"                           = PC2 ~ Batch,
  "Slide only"                           = PC2 ~ Slide
)

# Fit and summarize logistic models for PC1_binary
for (label in names(pc1_logit_models)) {
  formula <- pc1_logit_models[[label]]
  model <- glm(formula, data = pca_results_all, family = binomial)
  
  cat(sprintf("<details><summary><strong>Logistic Regression: PC1_binary ~ %s</strong></summary>\n\n", label))
  cat(knitr::kable(summary(model)$coefficients, format = "html", digits = 4,
                   table.attr = "class='table table-striped table-condensed'"))
  cat("</details>\n\n")
}

# Fit and summarize linear models for PC2
for (label in names(pc2_linear_models)) {
  formula <- pc2_linear_models[[label]]
  model <- lm(formula, data = pca_results_all)
  
  cat(sprintf("<details><summary><strong>Linear Model: PC2 ~ %s</strong></summary>\n\n", label))
  cat(knitr::kable(summary(model)$coefficients, format = "html", digits = 4,
                   table.attr = "class='table table-striped table-condensed'"))
  cat("</details>\n\n")
}






# Visual confirmation
ggplot(pca_results_all, aes(x = PC1, fill = factor(PC1_binary))) +
  geom_histogram(binwidth = 1, color = "black", alpha = 0.6, position = "identity") +
  scale_fill_manual(values = c("0" = "grey", "1" = "darkred"), name = "PC1 Group") +
  geom_vline(xintercept = 1, linetype = "dashed", color = "black") +
  ggtitle("PC1 Histogram with Binary Threshold at 1") +
  xlab("PC1 Value") + ylab("Frequency") +
  theme_minimal()








# Stratify by Tissue. Repeat the model separately for each tissue to see if Age is predictive within-tissue:

# Define grouped model formulas by covariate category
model_groups <- list(
  "Age / Injury models" = list(
    "PC1_binary ~ Age + Injury" = function(df) glm(PC1_binary ~ Age + Injury, data = df, family = binomial),
    "PC2 ~ Age + Injury"        = function(df) lm(PC2 ~ Age + Injury, data = df),
    "PC1_binary ~ Age"          = function(df) glm(PC1_binary ~ Age, data = df, family = binomial),
    "PC2 ~ Age"                 = function(df) lm(PC2 ~ Age, data = df)
  ),
  "Batch / Slide models" = list(
    "PC1_binary ~ Batch + Slide" = function(df) glm(PC1_binary ~ Batch + Slide, data = df, family = binomial),
    "PC2 ~ Batch + Slide"        = function(df) lm(PC2 ~ Batch + Slide, data = df),
    "PC1_binary ~ Batch"         = function(df) glm(PC1_binary ~ Batch, data = df, family = binomial),
    "PC2 ~ Batch"                = function(df) lm(PC2 ~ Batch, data = df),
    "PC1_binary ~ Slide"         = function(df) glm(PC1_binary ~ Slide, data = df, family = binomial),
    "PC2 ~ Slide"                = function(df) lm(PC2 ~ Slide, data = df)
  )
)

# Loop through model groups
for (group_name in names(model_groups)) {
  formulas <- model_groups[[group_name]]
  
  for (label in names(formulas)) {
    cat(sprintf("<details><summary><strong>%s — %s</strong></summary>\n\n", group_name, label))
    
    for (tissue in unique(pca_results_all$Tissue)) {
      sub <- subset(pca_results_all, Tissue == tissue)
      vars <- all.vars(as.formula(label))
      
      if (nrow(sub) >= 3 && all(vars %in% colnames(sub))) {
        model <- tryCatch(formulas[[label]](sub), error = function(e) NULL)
        if (!is.null(model)) {
          cat(sprintf("<h4>%s</h4>\n", tissue))
          cat(knitr::kable(summary(model)$coefficients, format = "html", digits = 4,
                           table.attr = "class='table table-striped table-condensed'"))
          cat("<br><br>\n")
        }
      }
    }
    
    cat("</details>\n\n")
  }
}







library(broom)

# Define combinations of response ~ predictor with model type
model_specs <- list(
  "PC1_binary ~ Age"   = list(formula = PC1_binary ~ Age,     method = glm, family = binomial, subset_term = "Age1"),
  "PC1_binary ~ Batch" = list(formula = PC1_binary ~ Batch,   method = glm, family = binomial, subset_term = "^Batch"),
  "PC1_binary ~ Slide" = list(formula = PC1_binary ~ Slide,   method = glm, family = binomial, subset_term = "^Slide"),
  "PC1_binary ~ ID"    = list(formula = PC1_binary ~ ID,      method = glm, family = binomial, subset_term = "^ID"),

  "PC2 ~ Age"          = list(formula = PC2 ~ Age,            method = lm,  family = NULL,    subset_term = "Age1"),
  "PC2 ~ Batch"        = list(formula = PC2 ~ Batch,          method = lm,  family = NULL,    subset_term = "^Batch"),
  "PC2 ~ Slide"        = list(formula = PC2 ~ Slide,          method = lm,  family = NULL,    subset_term = "^Slide"),
  "PC2 ~ ID"           = list(formula = PC2 ~ ID,             method = lm,  family = NULL,    subset_term = "^ID")
)

# Loop through each model spec
for (label in names(model_specs)) {
  spec <- model_specs[[label]]
  formula <- spec$formula
  method <- spec$method
  family <- spec$family
  term_pattern <- spec$subset_term

  # Fit model per tissue
  model_results <- lapply(split(pca_results_all, pca_results_all$Tissue), function(df) {
    fit <- tryCatch({
      if (!is.null(family)) {
        method(formula, data = df, family = family)
      } else {
        method(formula, data = df)
      }
    }, error = function(e) NULL)
    
    if (!is.null(fit)) tidy(fit) else NULL
  })

  # Drop nulls and combine
  model_results <- Filter(Negate(is.null), model_results)
  results_df <- do.call(rbind, Map(cbind, Tissue = names(model_results), model_results))

  # Subset to relevant terms
  is_match <- grepl(term_pattern, results_df$term) & results_df$term != "(Intercept)"
  filtered_df <- subset(results_df, is_match)

  # Format final table
  summary_df <- filtered_df[, c("Tissue", "term", "estimate", "std.error", "p.value")]
  summary_df <- summary_df[order(summary_df$p.value), ]
  
  if (label == "PC1_binary ~ Age") {
    logit_age_summary <- summary_df
  }
  if (label == "PC2 ~ Age") {
    lm_pc2_age_summary <- summary_df
  }
  if (label == "PC1_binary ~ Batch") {
    logit_batch_summary <- summary_df
  }
  if (label == "PC2 ~ Batch") {
    lm_pc2_batch_summary <- summary_df
  }


  # Collapsible output
  cat(sprintf("<details><summary><strong>Regression Summary: %s (by Tissue)</strong></summary>\n\n", label))
  cat(knitr::kable(summary_df, format = "html", digits = 4,
                   table.attr = "class='table table-striped table-condensed'"))
  cat("</details>\n\n")
}







library(ggplot2)

# Remove tissues with absurdly large standard error
logit_age_filtered <- subset(logit_age_summary, std.error < 2)

logit_age_filtered$direction <- ifelse(logit_age_filtered$estimate > 0, "Positive", "Negative")

ggplot(logit_age_filtered, aes(x = estimate, y = reorder(Tissue, estimate), color = direction)) +
  geom_point(size = 3) +
  geom_errorbarh(aes(xmin = estimate - 1.96 * std.error,
                     xmax = estimate + 1.96 * std.error), height = 0.2) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  scale_color_manual(values = c("Positive" = "firebrick", "Negative" = "steelblue")) +
  xlab("Log-Odds Estimate for Age (PC1_binary)") +
  ylab("Tissue") +
  theme_minimal()





lm_pc2_age_summary$direction <- ifelse(lm_pc2_age_summary$estimate > 0, "Positive", "Negative")

ggplot(lm_pc2_age_summary, aes(x = estimate, y = reorder(Tissue, estimate), color = direction)) +
  geom_point(size = 3) +
  geom_errorbarh(aes(xmin = estimate - 1.96 * std.error,
                     xmax = estimate + 1.96 * std.error), height = 0.2) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  scale_color_manual(values = c("Positive" = "firebrick", "Negative" = "steelblue")) +
  xlab("Effect of Age on PC2") +
  ylab("Tissue") +
  theme_minimal()





# Filter out extreme std.error values for cleaner plot
logit_batch_filtered <- subset(logit_batch_summary, std.error < 2)
logit_batch_filtered$direction <- ifelse(logit_batch_filtered$estimate > 0, "Positive", "Negative")

# Plot
ggplot(logit_batch_filtered, aes(x = estimate, y = reorder(Tissue, estimate), color = direction)) +
  geom_point(size = 3) +
  geom_errorbarh(aes(xmin = estimate - 1.96 * std.error,
                     xmax = estimate + 1.96 * std.error), height = 0.2) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  scale_color_manual(values = c("Positive" = "firebrick", "Negative" = "steelblue")) +
  xlab("Log-Odds Estimate for Batch (PC1_binary)") +
  ylab("Tissue") +
  theme_minimal()



# Filter and add direction
lm_pc2_batch_filtered <- subset(lm_pc2_batch_summary, std.error < 2)
lm_pc2_batch_filtered$direction <- ifelse(lm_pc2_batch_filtered$estimate > 0, "Positive", "Negative")

# Plot
ggplot(lm_pc2_batch_filtered, aes(x = estimate, y = reorder(Tissue, estimate), color = direction)) +
  geom_point(size = 3) +
  geom_errorbarh(aes(xmin = estimate - 1.96 * std.error,
                     xmax = estimate + 1.96 * std.error), height = 0.2) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  scale_color_manual(values = c("Positive" = "firebrick", "Negative" = "steelblue")) +
  xlab("Effect of Batch on PC2") +
  ylab("Tissue") +
  theme_minimal()





# Try per-tissue PCA correlation

library(dplyr)

# Initialize empty list
cor_summary_list <- list()

# Loop through tissues to compute correlation and p-values
for (tissue in unique(pca_results_all$Tissue)) {
  df_tissue <- subset(pca_results_all, Tissue == tissue)
  df_tissue$Age <- as.numeric(as.character(df_tissue$Age))
  
  if (length(unique(df_tissue$Age)) > 1) {
    cor1 <- cor.test(df_tissue$Age, df_tissue$PC1)
    cor2 <- cor.test(df_tissue$Age, df_tissue$PC2)

    cor_summary_list[[tissue]] <- data.frame(
      Tissue = tissue,
      cor_PC1_Age = cor1$estimate,
      pval_PC1_Age = cor1$p.value,
      cor_PC2_Age = cor2$estimate,
      pval_PC2_Age = cor2$p.value
    )
  } else {
    # Not enough variation in Age to compute correlation
    cor_summary_list[[tissue]] <- data.frame(
      Tissue = tissue,
      cor_PC1_Age = NA,
      pval_PC1_Age = NA,
      cor_PC2_Age = NA,
      pval_PC2_Age = NA
    )
  }
}

# Combine into one dataframe
cor_summary <- do.call(rbind, cor_summary_list)

# Optional: display
knitr::kable(cor_summary, digits = 4, format = "html", table.attr = "class='table table-striped'")


# Show as collapsible table
cat("<details><summary><strong>Correlation of PC1 and PC2 with Age by Tissue</strong></summary>\n\n")
cat(knitr::kable(cor_summary, format = "html", digits = 4, table.attr = "class='table table-striped table-condensed'"))
cat("</details>\n")







# Safe cor.test wrapper that always returns named output
safe_cor_test <- function(x, y) {
  out <- tryCatch({
    test <- suppressWarnings(cor.test(as.numeric(as.character(x)), y))
    c(estimate = as.numeric(test$estimate), p.value = test$p.value)
  }, error = function(e) c(estimate = NA_real_, p.value = NA_real_))
  
  # Always return a named vector
  names(out) <- c("estimate", "p.value")
  return(out)
}


# Initialize result list
cor_summary_list <- list()

# Loop through tissues
for (tissue in unique(pca_results_all$Tissue)) {
  df <- subset(pca_results_all, Tissue == tissue)

  out <- data.frame(
    Tissue = tissue,
    cor_PC1_Batch = safe_cor_test(df$Batch, df$PC1)["estimate"],
    pval_PC1_Batch = safe_cor_test(df$Batch, df$PC1)["p.value"],
    cor_PC2_Batch = safe_cor_test(df$Batch, df$PC2)["estimate"],
    pval_PC2_Batch = safe_cor_test(df$Batch, df$PC2)["p.value"],
    
    cor_PC1_Slide = safe_cor_test(df$Slide, df$PC1)["estimate"],
    pval_PC1_Slide = safe_cor_test(df$Slide, df$PC1)["p.value"],
    cor_PC2_Slide = safe_cor_test(df$Slide, df$PC2)["estimate"],
    pval_PC2_Slide = safe_cor_test(df$Slide, df$PC2)["p.value"],
    
    cor_PC1_ID = safe_cor_test(df$ID, df$PC1)["estimate"],
    pval_PC1_ID = safe_cor_test(df$ID, df$PC1)["p.value"],
    cor_PC2_ID = safe_cor_test(df$ID, df$PC2)["estimate"],
    pval_PC2_ID = safe_cor_test(df$ID, df$PC2)["p.value"]
  )
  
  cor_summary_list[[tissue]] <- out
}

# Combine results
cor_summary <- do.call(rbind, cor_summary_list)

# Output collapsible HTML table
cat("<details><summary><strong>Correlation of PC1 and PC2 with Batch, Slide, and ID by Tissue (with p-values)</strong></summary>\n\n")
cat(kable(cor_summary, format = "html", digits = 4,
          table.attr = "class='table table-striped table-condensed'"))
cat("</details>\n")








# Print summary of PC loadings for males only


# Define the variable to calculate variance safely
VAR_FUN <- stats::var

# Filter metadata to males only
male_samples <- subset(pca_results_all, Sex == 0)$ID

# Initialize storage list
pca_loadings_male_list <- list()

# Output wrapper
cat("<details><summary><strong>Top Gene Loadings for PC1 and PC2 (Males Only, per Tissue)</strong></summary>\n\n")

for (tissue in names(logCPM_list)) {
  logcpm <- logCPM_list[[tissue]]
  if (is.null(logcpm) || ncol(logcpm) < 2) next

  # Subset to male samples only
  common_samples <- intersect(colnames(logcpm), male_samples)
  if (length(common_samples) < 2) next
  logcpm_male <- logcpm[, common_samples, drop = FALSE]

  # Select top 50% most variable genes
  gene_vars <- apply(logcpm_male, 1, VAR_FUN, na.rm = TRUE)
  gene_vars <- gene_vars[gene_vars > 0]
  top_n <- floor(length(gene_vars) * 0.5)
  top_genes <- names(sort(gene_vars, decreasing = TRUE))[seq_len(top_n)]
  logcpm_sub <- logcpm_male[top_genes, , drop = FALSE]

  # PCA
  pca_res <- prcomp(t(logcpm_sub), center = TRUE, scale. = TRUE)

  # Extract full loadings
  V <- as.data.frame(pca_res$rotation)
  V$Gene <- rownames(V)
  pca_loadings_male_list[[tissue]] <- V

  # Only consider PC1 and PC2
  pcs <- intersect(c("PC1", "PC2"), colnames(V))

  # Collapsible per tissue
  cat(sprintf("<details><summary><strong>%s</strong></summary>\n\n", tissue))

  for (pc in pcs) {
    top_genes_pc <- V[order(abs(V[[pc]]), decreasing = TRUE), ][1:30, c("Gene", pc)]
    colnames(top_genes_pc)[2] <- "Loading"

    cat(sprintf("<details><summary>Top 30 Genes for %s</summary>\n\n", pc))
    print(knitr::kable(top_genes_pc, format = "html", table.attr = "class='table table-condensed table-striped'"))
    cat("</details>\n\n")
  }

  cat("</details>\n\n")
}

cat("</details>\n\n")



```



### 4.7.2 Downstream Analyses with Pseudobulking for PCA inspection males only subset by injury



```{r PseudobulkInjuryStratified4, echo=TRUE, message=FALSE, warning=FALSE, results='asis'}


library(ggplot2)
library(dplyr)
library(broom)
library(knitr)

injury_levels <- c(0, 2, 3)
pca_males <- subset(pca_results_all, Sex != 1)
pca_males$Age <- as.factor(pca_males$Age)
pca_males$Injury <- as.factor(pca_males$Injury)

# Storage
lm_pc2_list <- list()
logit_pc1_list <- list()

for (injury in injury_levels) {
  cat(sprintf("<hr><h2>\U0001F52C Analyses for Injury = %s (Males only)</h2>\n\n", injury))

  df_injury <- subset(pca_males, Injury == injury)
  df_injury$PC1_binary <- ifelse(df_injury$PC1 > 1, 1, 0)

  # Visuals
  cat("<details><summary><strong>PC Histograms & Boxplots by Age</strong></summary>\n\n")
  print(ggplot(df_injury, aes(x = PC1, fill = Age)) +
          geom_histogram(binwidth = 0.5, color = "black", alpha = 0.8) +
          ggtitle("Histogram of PC1 by Age") +
          theme_minimal())
  print(ggplot(df_injury, aes(x = PC2, fill = Age)) +
          geom_histogram(binwidth = 0.5, color = "black", alpha = 0.8) +
          ggtitle("Histogram of PC2 by Age") +
          theme_minimal())
  
  
  # Boxplot with annotation and summary for PC1 and PC2
  for (pc in c("PC1", "PC2")) {
    formula <- as.formula(paste(pc, "~ Age"))
    bp <- boxplot(formula,
                  data = df_injury,
                  main = paste(pc, "vs Age"),
                  col = c("skyblue", "orange"))

    # Annotate medians and n
    text(x = 1:2,
        y = bp$stats[3, ],
        labels = round(bp$stats[3, ], 1),
        pos = 3,
        cex = 0.9)
    text(x = 1:2,
        y = par("usr")[3] - 0.2 * diff(par("usr")[3:4]),
        labels = paste("n =", bp$n),
        xpd = TRUE)

    # Summary table
    group_labels <- levels(df_injury$Age)
    summary_table <- data.frame(
      Group = group_labels,
      N = bp$n,
      Min = round(bp$stats[1, ], 2),
      Q1 = round(bp$stats[2, ], 2),
      Median = round(bp$stats[3, ], 2),
      Q3 = round(bp$stats[4, ], 2),
      Max = round(bp$stats[5, ], 2)
    )

    # Collapsible summary table
    cat(sprintf("<details><summary><strong>Boxplot Summary Statistics (%s vs Age)</strong></summary>\n\n", pc))
    print(knitr::kable(summary_table, format = "html", table.attr = "class='table table-condensed table-striped'"))
    cat("</details>\n\n")
  }

  cat("</details>\n\n")

  # Scatterplots
  cat("<details><summary><strong>Scatterplots PC1 vs PC2 by Tissue</strong></summary>\n\n")
  print(ggplot(df_injury, aes(x = PC1, y = PC2, color = Age)) +
          geom_point(alpha = 0.7) +
          facet_wrap(~Tissue) +
          ggtitle("Scatterplot: PC1 vs PC2 by Age and Tissue") +
          theme_minimal())
  cat("</details>\n\n")

  # Correlation
  cor1 <- cor.test(as.numeric(as.character(df_injury$Age)), df_injury$PC1)
  cor2 <- cor.test(as.numeric(as.character(df_injury$Age)), df_injury$PC2)
  cor_df <- data.frame(
    PC = c("PC1", "PC2"),
    Correlation = c(cor1$estimate, cor2$estimate),
    CI_lower = c(cor1$conf.int[1], cor2$conf.int[1]),
    CI_upper = c(cor1$conf.int[2], cor2$conf.int[2]),
    p_value = c(cor1$p.value, cor2$p.value)
  )
  cat("<details><summary><strong>Correlation: Age vs PC1 and PC2</strong></summary>\n\n")
  cat(kable(cor_df, format = "html", digits = 4, table.attr = "class='table table-striped'"))
  cat("</details>\n\n")

  # Whole models
  lm_all <- lm(PC2 ~ Age + Tissue, data = df_injury)
  logit_all <- glm(PC1_binary ~ Age + Tissue, data = df_injury, family = binomial)
  cat("<details><summary><strong>Linear Model: PC2 ~ Age + Tissue</strong></summary>\n\n<pre>")
  print(summary(lm_all))
  cat("</pre></details>\n\n")
  cat("<details><summary><strong>Logistic Model: PC1_binary ~ Age + Tissue</strong></summary>\n\n<pre>")
  print(summary(logit_all))
  cat("</pre></details>\n\n")

  # Per-tissue models
  tissue_split <- split(df_injury, df_injury$Tissue)
  lm_pc2 <- lapply(tissue_split, function(df) {
    if (nlevels(df$Age) < 2 || nrow(df) < 3) return(NULL)
    tidy(lm(PC2 ~ Age, data = df))
  })
  logit_pc1 <- lapply(tissue_split, function(df) {
    if (nlevels(df$Age) < 2 || nrow(df) < 3) return(NULL)
    tidy(glm(PC1_binary ~ Age, data = df, family = binomial))
  })

  # Combine and label
  lm_pc2_df <- do.call(rbind, Map(cbind, Tissue = names(lm_pc2), Injury = injury, lm_pc2))
  logit_pc1_df <- do.call(rbind, Map(cbind, Tissue = names(logit_pc1), Injury = injury, logit_pc1))

  lm_pc2_list[[as.character(injury)]] <- lm_pc2_df
  logit_pc1_list[[as.character(injury)]] <- logit_pc1_df

  # Summaries: only Age term
  lm_pc2_age <- subset(lm_pc2_df, term == "Age1")[, c("Tissue", "Injury", "estimate", "std.error", "p.value")]
  logit_pc1_age <- subset(logit_pc1_df, term == "Age1")[, c("Tissue", "Injury", "estimate", "std.error", "p.value")]

  # SD/forest-style plot for PC2 ~ Age (linear model)
  lm_pc2_age$direction <- ifelse(lm_pc2_age$estimate > 0, "Positive", "Negative")
  cat("<details><summary><strong>Forest Plot: PC2 ~ Age (by Tissue)</strong></summary>\n\n")
  print(
    ggplot(lm_pc2_age, aes(x = estimate, y = reorder(Tissue, estimate), color = direction)) +
      geom_point(size = 3) +
      geom_errorbarh(aes(xmin = estimate - 1.96 * std.error,
                         xmax = estimate + 1.96 * std.error), height = 0.2) +
      geom_vline(xintercept = 0, linetype = "dashed") +
      scale_color_manual(values = c("Positive" = "firebrick", "Negative" = "steelblue")) +
      xlab("Effect of Age on PC2") +
      ylab("Tissue") +
      theme_minimal()
  )
  cat("</details>\n\n")

  # Forest plot for PC1_binary ~ Age (logistic model)
  logit_pc1_age$direction <- ifelse(logit_pc1_age$estimate > 0, "Positive", "Negative")
  cat("<details><summary><strong>Forest Plot: PC1_binary ~ Age (by Tissue)</strong></summary>\n\n")
  print(
    ggplot(logit_pc1_age, aes(x = estimate, y = reorder(Tissue, estimate), color = direction)) +
      geom_point(size = 3) +
      geom_errorbarh(aes(xmin = estimate - 1.96 * std.error,
                         xmax = estimate + 1.96 * std.error), height = 0.2) +
      geom_vline(xintercept = 0, linetype = "dashed") +
      scale_color_manual(values = c("Positive" = "firebrick", "Negative" = "steelblue")) +
      xlab("Log-Odds Estimate for Age (PC1_binary)") +
      ylab("Tissue") +
      theme_minimal()
  )
  cat("</details>\n\n")

  # Summary tables
  cat("<details><summary><strong>Linear Model: PC2 ~ Age (by Tissue)</strong></summary>\n\n")
  cat(kable(lm_pc2_age[order(lm_pc2_age$p.value), ], format = "html", digits = 4,
            table.attr = "class='table table-striped table-condensed'"))
  cat("</details>\n\n")

  cat("<details><summary><strong>Logistic Model: PC1_binary ~ Age (by Tissue)</strong></summary>\n\n")
  cat(kable(logit_pc1_age[order(logit_pc1_age$p.value), ], format = "html", digits = 4,
            table.attr = "class='table table-striped table-condensed'"))
  cat("</details>\n\n")

  # Full coefficient tables
  cat("<details><summary><strong>Full Coefficient Table: PC2 ~ Age (by Tissue)</strong></summary>\n\n")
  cat(kable(lm_pc2_df, format = "html", digits = 4, table.attr = "class='table table-striped table-condensed'"))
  cat("</details>\n\n")

  cat("<details><summary><strong>Full Coefficient Table: PC1_binary ~ Age (by Tissue)</strong></summary>\n\n")
  cat(kable(logit_pc1_df, format = "html", digits = 4, table.attr = "class='table table-striped table-condensed'"))
  cat("</details>\n\n")
}





library(ggplot2)
library(dplyr)
library(broom)
library(knitr)


injury_levels <- c(0, 2, 3)
pca_males <- subset(pca_results_all, Sex != 1)
pca_males$Batch <- as.factor(pca_males$Batch)
pca_males$Injury <- as.factor(pca_males$Injury)
pca_males$Slide <- as.factor(pca_males$Slide)

lm_pc2_list <- list()
logit_pc1_list <- list()

# Ensure stringi is loaded
if (!requireNamespace("stringi", quietly = TRUE)) install.packages("stringi")
library(stringi)

for (injury in injury_levels) {
  cat(sprintf("<hr><h2>\U0001F52C Analyses for Injury = %s (Males only)</h2>\n\n", injury))

  df_injury <- droplevels(subset(pca_males, Injury == injury))
  df_injury$PC1_binary <- ifelse(df_injury$PC1 > 1, 1, 0)

  cat("<details><summary><strong>PC Histograms & Boxplots by Batch</strong></summary>\n\n")
  print(ggplot(df_injury, aes(x = PC1, fill = Batch)) +
          geom_histogram(binwidth = 0.5, color = "black", alpha = 0.8) +
          ggtitle("Histogram of PC1 by Batch") + theme_minimal())
  print(ggplot(df_injury, aes(x = PC2, fill = Batch)) +
          geom_histogram(binwidth = 0.5, color = "black", alpha = 0.8) +
          ggtitle("Histogram of PC2 by Batch") + theme_minimal())

  
  # Boxplots for PC1 and PC2 with annotations and summary table
  for (pc in c("PC1", "PC2")) {
    formula <- as.formula(paste(pc, "~ Batch"))
    bp <- boxplot(formula,
                  data = df_injury,
                  main = paste(pc, "vs Batch"),
                  col = rainbow(length(unique(df_injury$Batch))),
                  las = 1)

    # Annotate medians and sample sizes
    text(x = 1:length(bp$n),
        y = bp$stats[3, ],
        labels = round(bp$stats[3, ], 1),
        pos = 3,
        cex = 0.9)
    text(x = 1:length(bp$n),
        y = par("usr")[3] - 0.2 * diff(par("usr")[3:4]),
        labels = paste("n =", bp$n),
        xpd = TRUE)

    # Summary table
    group_labels <- levels(df_injury$Batch)
    summary_table <- data.frame(
      Group = group_labels,
      N = bp$n,
      Min = round(bp$stats[1, ], 2),
      Q1 = round(bp$stats[2, ], 2),
      Median = round(bp$stats[3, ], 2),
      Q3 = round(bp$stats[4, ], 2),
      Max = round(bp$stats[5, ], 2)
    )

    # Collapsible summary table
    cat(sprintf("<details><summary><strong>Boxplot Summary Statistics (%s vs Batch)</strong></summary>\n\n", pc))
    print(knitr::kable(summary_table, format = "html", table.attr = "class='table table-condensed table-striped'"))
    cat("</details>\n\n")
  }

  
  cat("</details>\n\n")

  cat("<details><summary><strong>Scatterplot: PC1 vs PC2 by Batch and Tissue</strong></summary>\n\n")
  print(ggplot(df_injury, aes(x = PC1, y = PC2, color = Batch)) +
          geom_point(alpha = 0.7) +
          facet_wrap(~Tissue) +
          ggtitle("Scatterplot: PC1 vs PC2 by Batch and Tissue") +
          theme_minimal())
  cat("</details>\n\n")

  # Per tissue models
  tissue_split <- split(df_injury, df_injury$Tissue)

  lm_pc2 <- lapply(tissue_split, function(df) {
    df <- droplevels(df)
    if (nlevels(df$Batch) < 2 || nrow(df) < 3) return(NULL)
    broom::tidy(lm(PC2 ~ Batch, data = df))
  })

  logit_pc1 <- lapply(tissue_split, function(df) {
    df <- droplevels(df)
    if (nlevels(df$Batch) < 2 || nrow(df) < 3) return(NULL)
    broom::tidy(glm(PC1_binary ~ Batch, data = df, family = binomial))
  })

  lm_pc2_df <- do.call(rbind, Map(cbind, Tissue = names(lm_pc2), Injury = injury, lm_pc2))
  logit_pc1_df <- do.call(rbind, Map(cbind, Tissue = names(logit_pc1), Injury = injury, logit_pc1))

  lm_pc2_list[[as.character(injury)]] <- lm_pc2_df
  logit_pc1_list[[as.character(injury)]] <- logit_pc1_df

  if (!is.null(lm_pc2_df) && "term" %in% colnames(lm_pc2_df)) {
    lm_pc2_batch <- subset(lm_pc2_df, grepl("Batch", term))[, c("Tissue", "Injury", "term", "estimate", "std.error")]
    lm_pc2_batch$Direction <- ifelse(lm_pc2_batch$estimate > 0, "Positive", "Negative")

    cat("<details><summary><strong>Forest Plot: Effect of Batch on PC2 (by Tissue)</strong></summary>\n\n")
    print(ggplot(lm_pc2_batch, aes(x = estimate, y = reorder(Tissue, estimate), color = Direction)) +
            geom_point(size = 3) +
            geom_errorbarh(aes(xmin = estimate - 1.96 * std.error, xmax = estimate + 1.96 * std.error), height = 0.2) +
            geom_vline(xintercept = 0, linetype = "dashed") +
            scale_color_manual(values = c("Positive" = "firebrick", "Negative" = "steelblue")) +
            xlab("Effect of Batch on PC2") +
            ylab("Tissue") +
            theme_minimal())
    cat("</details>\n\n")
  }

  if (!is.null(logit_pc1_df) && "term" %in% colnames(logit_pc1_df)) {
    logit_pc1_batch <- subset(logit_pc1_df, grepl("Batch", term))[, c("Tissue", "Injury", "term", "estimate", "std.error")]
    logit_pc1_batch$Direction <- ifelse(logit_pc1_batch$estimate > 0, "Positive", "Negative")

    cat("<details><summary><strong>Forest Plot: Effect of Batch on PC1_binary (by Tissue)</strong></summary>\n\n")
    print(ggplot(logit_pc1_batch, aes(x = estimate, y = reorder(Tissue, estimate), color = Direction)) +
            geom_point(size = 3) +
            geom_errorbarh(aes(xmin = estimate - 1.96 * std.error, xmax = estimate + 1.96 * std.error), height = 0.2) +
            geom_vline(xintercept = 0, linetype = "dashed") +
            scale_color_manual(values = c("Positive" = "firebrick", "Negative" = "steelblue")) +
            xlab("Effect of Batch on PC1_binary") +
            ylab("Tissue") +
            theme_minimal())
    cat("</details>\n\n")
  }
}







# Ensure stringi is available
if (!requireNamespace("stringi", quietly = TRUE)) install.packages("stringi")
library(stringi)

injury_levels <- c(0, 2, 3)
pca_males <- subset(pca_results_all, Sex != 1)
pca_males$Slide <- as.factor(pca_males$Slide)
pca_males$Injury <- as.factor(pca_males$Injury)
pca_males$Batch <- as.factor(pca_males$Batch)

lm_pc2_list <- list()
logit_pc1_list <- list()

for (injury in injury_levels) {
  cat(sprintf("<hr><h2>\U0001F52C Analyses for Injury = %s (Males only)</h2>\n\n", injury))

  df_injury <- droplevels(subset(pca_males, Injury == injury))
  df_injury$PC1_binary <- ifelse(df_injury$PC1 > 1, 1, 0)

  cat("<details><summary><strong>PC Histograms & Boxplots by Slide</strong></summary>\n\n")
  print(ggplot(df_injury, aes(x = PC1, fill = Slide)) +
          geom_histogram(binwidth = 0.5, color = "black", alpha = 0.8) +
          ggtitle("Histogram of PC1 by Slide") + theme_minimal())
  print(ggplot(df_injury, aes(x = PC2, fill = Slide)) +
          geom_histogram(binwidth = 0.5, color = "black", alpha = 0.8) +
          ggtitle("Histogram of PC2 by Slide") + theme_minimal())

  for (pc in c("PC1", "PC2")) {
  formula <- as.formula(paste(pc, "~ Slide"))
  bp <- boxplot(formula,
                data = df_injury,
                main = paste(pc, "vs Slide"),
                col = rainbow(length(unique(df_injury$Slide))),
                ylim = range(df_injury[[pc]], na.rm = TRUE) * c(0.9, 1.1))

  # Annotate median and n
  text(x = 1:length(bp$n),
       y = bp$stats[3, ],
       labels = round(bp$stats[3, ], 1),
       pos = 3,
       cex = 0.9)
  text(x = 1:length(bp$n),
       y = par("usr")[3] - 0.2 * diff(par("usr")[3:4]),
       labels = paste("n =", bp$n),
       xpd = TRUE)

  # Summary table
  group_labels <- levels(df_injury$Slide)
  summary_table <- data.frame(
    Group = group_labels,
    N = bp$n,
    Min = round(bp$stats[1, ], 2),
    Q1 = round(bp$stats[2, ], 2),
    Median = round(bp$stats[3, ], 2),
    Q3 = round(bp$stats[4, ], 2),
    Max = round(bp$stats[5, ], 2)
  )

  # Collapsible summary table
  cat(sprintf("<details><summary><strong>Boxplot Summary Statistics (%s vs Slide)</strong></summary>\n\n", pc))
  print(knitr::kable(summary_table, format = "html", table.attr = "class='table table-condensed table-striped'"))
  cat("</details>\n\n")
}

  cat("</details>\n\n")

  cat("<details><summary><strong>Scatterplot: PC1 vs PC2 by Slide and Tissue</strong></summary>\n\n")
  print(ggplot(df_injury, aes(x = PC1, y = PC2, color = Slide)) +
          geom_point(alpha = 0.7) +
          facet_wrap(~Tissue) +
          ggtitle("Scatterplot: PC1 vs PC2 by Slide and Tissue") +
          theme_minimal())
  cat("</details>\n\n")

  sd_summary <- df_injury %>%
    group_by(Tissue) %>%
    summarise(SD_PC1 = sd(PC1), SE_PC1 = sd(PC1)/sqrt(n()), .groups = "drop")
  sd_summary$direction <- ifelse(sd_summary$SD_PC1 > median(sd_summary$SD_PC1, na.rm = TRUE), "Above Median", "Below Median")

  cat("<details><summary><strong>Forest Plot: SD of PC1 by Tissue</strong></summary>\n\n")
  print(
    ggplot(sd_summary, aes(x = SD_PC1, y = reorder(Tissue, SD_PC1), color = direction)) +
      geom_point(size = 3) +
      geom_errorbarh(aes(xmin = SD_PC1 - SE_PC1, xmax = SD_PC1 + SE_PC1), height = 0.2) +
      geom_vline(xintercept = median(sd_summary$SD_PC1, na.rm = TRUE), linetype = "dashed") +
      scale_color_manual(values = c("Above Median" = "firebrick", "Below Median" = "steelblue")) +
      ggtitle("Standard Deviation of PC1 across Tissues") +
      xlab("SD of PC1") + ylab("Tissue") +
      theme_minimal()
  )
  cat("</details>\n\n")

  if (nlevels(df_injury$Slide) >= 2) {
    cor1 <- cor.test(as.numeric(as.character(df_injury$Slide)), df_injury$PC1)
    cor2 <- cor.test(as.numeric(as.character(df_injury$Slide)), df_injury$PC2)
    cor_df <- data.frame(
      PC = c("PC1", "PC2"),
      Correlation = c(cor1$estimate, cor2$estimate),
      CI_lower = c(cor1$conf.int[1], cor2$conf.int[1]),
      CI_upper = c(cor1$conf.int[2], cor2$conf.int[2]),
      p_value = c(cor1$p.value, cor2$p.value)
    )
  } else {
    cor_df <- data.frame(PC = c("PC1", "PC2"), Correlation = NA, CI_lower = NA, CI_upper = NA, p_value = NA)
  }
  cat("<details><summary><strong>Correlation: Slide vs PC1 and PC2</strong></summary>\n\n")
  cat(kable(cor_df, format = "html", digits = 4, table.attr = "class='table table-striped'"))
  cat("</details>\n\n")

  if (nlevels(df_injury$Slide) >= 2 && nlevels(df_injury$Tissue) >= 2) {
    lm_all <- lm(PC2 ~ Slide + Tissue, data = df_injury)
    logit_all <- glm(PC1_binary ~ Slide + Tissue, data = df_injury, family = binomial)
    cat("<details><summary><strong>Linear Model: PC2 ~ Slide + Tissue</strong></summary>\n\n<pre>")
    print(summary(lm_all))
    cat("</pre></details>\n\n")
    cat("<details><summary><strong>Logistic Model: PC1_binary ~ Slide + Tissue</strong></summary>\n\n<pre>")
    print(summary(logit_all))
    cat("</pre></details>\n\n")
  }

  tissue_split <- split(df_injury, df_injury$Tissue)
  lm_pc2 <- lapply(tissue_split, function(df) {
    df <- droplevels(df)
    if (nlevels(df$Slide) < 2 || nrow(df) < 3) return(NULL)
    tidy(lm(PC2 ~ Slide, data = df))
  })
  logit_pc1 <- lapply(tissue_split, function(df) {
    df <- droplevels(df)
    if (nlevels(df$Slide) < 2 || nrow(df) < 3) return(NULL)
    tidy(glm(PC1_binary ~ Slide, data = df, family = binomial))
  })

  lm_pc2_df <- do.call(rbind, Map(cbind, Tissue = names(lm_pc2), Injury = injury, lm_pc2))
  logit_pc1_df <- do.call(rbind, Map(cbind, Tissue = names(logit_pc1), Injury = injury, logit_pc1))
  lm_pc2_list[[as.character(injury)]] <- lm_pc2_df
  logit_pc1_list[[as.character(injury)]] <- logit_pc1_df

  if (!is.null(lm_pc2_df) && "term" %in% colnames(lm_pc2_df)) {
    lm_pc2_slide <- subset(lm_pc2_df, grepl("Slide", term))[, c("Tissue", "Injury", "term", "estimate", "std.error", "p.value")]
    cat("<details><summary><strong>Linear Model: PC2 ~ Slide (by Tissue)</strong></summary>\n\n")
    cat(kable(lm_pc2_slide[order(lm_pc2_slide$p.value), ], format = "html", digits = 4,
              table.attr = "class='table table-striped table-condensed'"))
    cat("</details>\n\n")

    lm_pc2_slide$direction <- ifelse(lm_pc2_slide$estimate > 0, "Positive", "Negative")
    lm_pc2_slide$Label <- stringi::stri_enc_toutf8(paste(lm_pc2_slide$Tissue, lm_pc2_slide$term, sep = " | "))
    cat("<details><summary><strong>Forest Plot: Effect of Slide on PC2 (by Tissue)</strong></summary>\n\n")
    print(
      ggplot(lm_pc2_slide, aes(x = estimate, y = reorder(Label, estimate), color = direction)) +
        geom_point(size = 3) +
        geom_errorbarh(aes(xmin = estimate - 1.96 * std.error, xmax = estimate + 1.96 * std.error), height = 0.2) +
        geom_vline(xintercept = 0, linetype = "dashed") +
        scale_color_manual(values = c("Positive" = "firebrick", "Negative" = "steelblue")) +
        labs(
          title = "Effect of Slide on PC2 (Linear Model per Tissue)",
          x = "Estimate", y = "Tissue | Slide",
          color = "Direction"
        ) +
        theme_minimal()
    )
    cat("</details>\n\n")
  }

  if (!is.null(logit_pc1_df) && "term" %in% colnames(logit_pc1_df)) {
    logit_pc1_slide <- subset(logit_pc1_df, grepl("Slide", term))[, c("Tissue", "Injury", "term", "estimate", "std.error", "p.value")]
    cat("<details><summary><strong>Logistic Model: PC1_binary ~ Slide (by Tissue)</strong></summary>\n\n")
    cat(kable(logit_pc1_slide[order(logit_pc1_slide$p.value), ], format = "html", digits = 4,
              table.attr = "class='table table-striped table-condensed'"))
    cat("</details>\n\n")
  }

  cat("<details><summary><strong>Full Coefficient Table: PC2 ~ Slide (by Tissue)</strong></summary>\n\n")
  cat(kable(lm_pc2_df, format = "html", digits = 4, table.attr = "class='table table-striped table-condensed'"))
  cat("</details>\n\n")

  cat("<details><summary><strong>Full Coefficient Table: PC1_binary ~ Slide (by Tissue)</strong></summary>\n\n")
  cat(kable(logit_pc1_df, format = "html", digits = 4, table.attr = "class='table table-striped table-condensed'"))
  cat("</details>\n\n")
}








# Ensure stringi is available
if (!requireNamespace("stringi", quietly = TRUE)) install.packages("stringi")
library(stringi)

injury_levels <- c(0, 2, 3)
pca_males <- subset(pca_results_all, Sex != 1)
pca_males$ReadCount <- as.numeric(pca_males$ReadCount)
pca_males$Injury <- as.factor(pca_males$Injury)

lm_pc2_list <- list()
logit_pc1_list <- list()

for (injury in injury_levels) {
  cat(sprintf("<hr><h2>\U0001F52C Analyses for Injury = %s (Males only)</h2>\n\n", injury))

  df_injury <- droplevels(subset(pca_males, Injury == injury))
  df_injury$PC1_binary <- ifelse(df_injury$PC1 > 1, 1, 0)

  cat("<details><summary><strong>PC Histograms & Boxplots by ReadCount</strong></summary>\n\n")
  print(ggplot(df_injury, aes(x = PC1, fill = cut(ReadCount, 4))) +
          geom_histogram(binwidth = 0.5, color = "black", alpha = 0.8) +
          ggtitle("Histogram of PC1 by ReadCount bin") + theme_minimal())
  print(ggplot(df_injury, aes(x = PC2, fill = cut(ReadCount, 4))) +
          geom_histogram(binwidth = 0.5, color = "black", alpha = 0.8) +
          ggtitle("Histogram of PC2 by ReadCount bin") + theme_minimal())
  cat("</details>\n\n")

  cat("<details><summary><strong>Scatterplots and SD by Tissue</strong></summary>\n\n")
  print(ggplot(df_injury, aes(x = PC1, y = PC2, color = ReadCount)) +
          geom_point(alpha = 0.7) +
          facet_wrap(~Tissue) +
          ggtitle("PC1 vs PC2 colored by ReadCount") +
          theme_minimal())

  sd_df <- df_injury %>%
    mutate(ReadBin = cut(ReadCount, 4),
           ReadBinLabel = gsub(",", " to ", gsub("\\(|\\]", "", as.character(ReadBin))),
           GroupLabel = stringi::stri_enc_toutf8(paste(Tissue, ReadBinLabel, sep = " | "))) %>%
    group_by(GroupLabel, Tissue, ReadBin) %>%
    summarise(SD_PC1 = sd(PC1), SD_PC2 = sd(PC2), .groups = "drop")

  sd_df$direction_PC1 <- ifelse(sd_df$SD_PC1 > median(sd_df$SD_PC1, na.rm = TRUE), "Above Median", "Below Median")
  sd_df$direction_PC2 <- ifelse(sd_df$SD_PC2 > median(sd_df$SD_PC2, na.rm = TRUE), "Above Median", "Below Median")

  cat("<details><summary><strong>Forest Plot of SD: PC1 and PC2 by Tissue and ReadCount bin</strong></summary>\n\n")
  print(ggplot(sd_df, aes(x = SD_PC1, y = reorder(GroupLabel, SD_PC1), color = direction_PC1)) +
          geom_point(size = 3) +
          geom_errorbarh(aes(xmin = SD_PC1 - 0.01, xmax = SD_PC1 + 0.01), height = 0.2) +
          geom_vline(xintercept = median(sd_df$SD_PC1, na.rm = TRUE), linetype = "dashed") +
          scale_color_manual(values = c("Above Median" = "firebrick", "Below Median" = "steelblue")) +
          labs(x = "SD of PC1", y = "Tissue | ReadBin", color = "Direction") + theme_minimal())
  print(ggplot(sd_df, aes(x = SD_PC2, y = reorder(GroupLabel, SD_PC2), color = direction_PC2)) +
          geom_point(size = 3) +
          geom_errorbarh(aes(xmin = SD_PC2 - 0.01, xmax = SD_PC2 + 0.01), height = 0.2) +
          geom_vline(xintercept = median(sd_df$SD_PC2, na.rm = TRUE), linetype = "dashed") +
          scale_color_manual(values = c("Above Median" = "firebrick", "Below Median" = "steelblue")) +
          labs(x = "SD of PC2", y = "Tissue | ReadBin", color = "Direction") + theme_minimal())
  cat("</details>\n\n")

  if (var(df_injury$ReadCount, na.rm = TRUE) > 0) {
    cor1 <- cor.test(df_injury$ReadCount, df_injury$PC1)
    cor2 <- cor.test(df_injury$ReadCount, df_injury$PC2)
    cor_df <- data.frame(PC = c("PC1", "PC2"),
                         Correlation = c(cor1$estimate, cor2$estimate),
                         CI_lower = c(cor1$conf.int[1], cor2$conf.int[1]),
                         CI_upper = c(cor1$conf.int[2], cor2$conf.int[2]),
                         p_value = c(cor1$p.value, cor2$p.value))
  } else {
    cor_df <- data.frame(PC = c("PC1", "PC2"), Correlation = NA, CI_lower = NA, CI_upper = NA, p_value = NA)
  }
  cat("<details><summary><strong>Correlation: ReadCount vs PC1 and PC2</strong></summary>\n\n")
  cat(kable(cor_df, format = "html", digits = 4, table.attr = "class='table table-striped'"))
  cat("</details>\n\n")

  if (nlevels(df_injury$Tissue) >= 2) {
    lm_all <- lm(PC2 ~ ReadCount + Tissue, data = df_injury)
    logit_all <- glm(PC1_binary ~ ReadCount + Tissue, data = df_injury, family = binomial)
    cat("<details><summary><strong>Linear Model: PC2 ~ ReadCount + Tissue</strong></summary>\n\n<pre>")
    print(summary(lm_all))
    cat("</pre></details>\n\n")
    cat("<details><summary><strong>Logistic Model: PC1_binary ~ ReadCount + Tissue</strong></summary>\n\n<pre>")
    print(summary(logit_all))
    cat("</pre></details>\n\n")
  }

  tissue_split <- split(df_injury, df_injury$Tissue)
  lm_pc2 <- lapply(tissue_split, function(df) {
    if (var(df$ReadCount, na.rm = TRUE) == 0 || nrow(df) < 3) return(NULL)
    tidy(lm(PC2 ~ ReadCount, data = df))
  })
  logit_pc1 <- lapply(tissue_split, function(df) {
    if (var(df$ReadCount, na.rm = TRUE) == 0 || nrow(df) < 3) return(NULL)
    tidy(glm(PC1_binary ~ ReadCount, data = df, family = binomial))
  })

  lm_pc2_df <- do.call(rbind, Map(cbind, Tissue = names(lm_pc2), Injury = injury, lm_pc2))
  logit_pc1_df <- do.call(rbind, Map(cbind, Tissue = names(logit_pc1), Injury = injury, logit_pc1))
  lm_pc2_list[[as.character(injury)]] <- lm_pc2_df
  logit_pc1_list[[as.character(injury)]] <- logit_pc1_df

  if (!is.null(lm_pc2_df) && "term" %in% colnames(lm_pc2_df)) {
    lm_pc2_summary <- subset(lm_pc2_df, term == "ReadCount")
    cat("<details><summary><strong>Linear Model: PC2 ~ ReadCount (by Tissue)</strong></summary>\n\n")
    cat(kable(lm_pc2_summary[order(lm_pc2_summary$p.value), c("Tissue", "Injury", "term", "estimate", "std.error", "p.value")],
              format = "html", digits = 4, table.attr = "class='table table-striped table-condensed'"))
    cat("</details>\n\n")

    cat("<details><summary><strong>Forest Plot: Effect of ReadCount on PC2 (Model-Based)</strong></summary>\n\n")
    lm_pc2_summary$direction <- ifelse(lm_pc2_summary$estimate > 0, "Positive", "Negative")
    print(ggplot(lm_pc2_summary, aes(x = estimate, y = reorder(Tissue, estimate), color = direction)) +
            geom_point(size = 3) +
            geom_errorbarh(aes(xmin = estimate - 1.96 * std.error,
                               xmax = estimate + 1.96 * std.error), height = 0.2) +
            geom_vline(xintercept = 0, linetype = "dashed") +
            scale_color_manual(values = c("Positive" = "firebrick", "Negative" = "steelblue")) +
            xlab("Effect of ReadCount on PC2") +
            ylab("Tissue") +
            theme_minimal())
    cat("</details>\n\n")
  }

  if (!is.null(logit_pc1_df) && "term" %in% colnames(logit_pc1_df)) {
    logit_pc1_summary <- subset(logit_pc1_df, term == "ReadCount")[, c("Tissue", "Injury", "term", "estimate", "std.error", "p.value")]
    cat("<details><summary><strong>Logistic Model: PC1_binary ~ ReadCount (by Tissue)</strong></summary>\n\n")
    cat(kable(logit_pc1_summary[order(logit_pc1_summary$p.value), ], format = "html", digits = 4,
              table.attr = "class='table table-striped table-condensed'"))
    cat("</details>\n\n")
  }

  cat("<details><summary><strong>Full Coefficient Table: PC2 ~ ReadCount (by Tissue)</strong></summary>\n\n")
  cat(kable(lm_pc2_df, format = "html", digits = 4, table.attr = "class='table table-striped table-condensed'"))
  cat("</details>\n\n")

  cat("<details><summary><strong>Full Coefficient Table: PC1_binary ~ ReadCount (by Tissue)</strong></summary>\n\n")
  cat(kable(logit_pc1_df, format = "html", digits = 4, table.attr = "class='table table-striped table-condensed'"))
  cat("</details>\n\n")
}





# Function to safely bind a list of data frames with inconsistent columns
safe_bind_rows <- function(df_list) {
  out <- lapply(df_list, function(df) {
    if (is.null(df)) return(NULL)
    df <- as.data.frame(df)  # flatten tibbles
    df
  })

  all_cols <- unique(unlist(lapply(out, names)))

  out_aligned <- lapply(out, function(df) {
    if (is.null(df)) return(NULL)
    for (col in setdiff(all_cols, names(df))) {
      df[[col]] <- NA
    }
    df <- df[, all_cols, drop = FALSE]
    df
  })

  do.call(rbind, out_aligned)
}

# Bind all linear/logistic model results across injury levels
lm_pc2_all <- safe_bind_rows(lm_pc2_list)
logit_pc1_all <- safe_bind_rows(logit_pc1_list)

# Define variables to summarize
predictors <- c("Batch", "Slide", "Age", "ReadCount")

# Generate final summary for each predictor
for (var in predictors) {
  if (!is.null(lm_pc2_all) && all(c("Tissue", "Injury", "term") %in% colnames(lm_pc2_all))) {
    lm_pc2_summary <- subset(lm_pc2_all, grepl(var, term))[, c("Tissue", "Injury", "term", "estimate", "std.error", "p.value")]
    cat(sprintf("<details><summary><strong>Final Summary: PC2 ~ %s (Linear, All Injury Levels)</strong></summary>\n\n", var))
    cat(kable(lm_pc2_summary[order(lm_pc2_summary$p.value), ], format = "html", digits = 4,
              table.attr = "class='table table-striped table-condensed'"))
    cat("</details>\n\n")
  }

  if (!is.null(logit_pc1_all) && all(c("Tissue", "Injury", "term") %in% colnames(logit_pc1_all))) {
    logit_pc1_summary <- subset(logit_pc1_all, grepl(var, term))[, c("Tissue", "Injury", "term", "estimate", "std.error", "p.value")]
    cat(sprintf("<details><summary><strong>Final Summary: PC1_binary ~ %s (Logistic, All Injury Levels)</strong></summary>\n\n", var))
    cat(kable(logit_pc1_summary[order(logit_pc1_summary$p.value), ], format = "html", digits = 4,
              table.attr = "class='table table-striped table-condensed'"))
    cat("</details>\n\n")
  }
}






# PC loadings males only separated by injury type

VAR_FUN <- stats::var  # Ensure no conflict with objects named 'var'

cat("<details><summary><strong>Top Gene Loadings for PC1 and PC2 (Male Samples, Split by Injury)</strong></summary>\n\n")

injury_levels <- c(0, 2, 3)

# Loop through each injury level
for (injury in injury_levels) {
  cat(sprintf("<details><summary><strong>Injury = %s</strong></summary>\n\n", injury))
  
  for (tissue in names(logCPM_list)) {
    logcpm <- logCPM_list[[tissue]]
    if (is.null(logcpm) || ncol(logcpm) < 2) next

    # Get metadata for current tissue
    metadata <- gene_filtered_list[[tissue]]@meta.data
    metadata <- metadata[metadata$Sex == 0 & metadata$Injury == injury, ]
    
    # Subset logCPM to male samples with the specified injury
    common_samples <- intersect(colnames(logcpm), metadata$ID)
    logcpm_sub <- logcpm[, common_samples, drop = FALSE]
    if (ncol(logcpm_sub) < 2) next

    # Filter top 50% most variable genes
    gene_vars <- apply(logcpm_sub, 1, VAR_FUN, na.rm = TRUE)
    gene_vars <- gene_vars[gene_vars > 0]
    top_n <- floor(length(gene_vars) * 0.5)
    top_genes <- names(sort(gene_vars, decreasing = TRUE))[seq_len(top_n)]
    logcpm_filtered <- logcpm_sub[top_genes, , drop = FALSE]

    # PCA
    pca_res <- prcomp(t(logcpm_filtered), center = TRUE, scale. = TRUE)

    # Extract full loadings
    V <- as.data.frame(pca_res$rotation)
    V$Gene <- rownames(V)

    # Limit to PC1 and PC2 if they exist
    pcs <- intersect(c("PC1", "PC2"), colnames(V))

    # Display by tissue
    cat(sprintf("<details><summary><strong>%s</strong></summary>\n\n", tissue))

    for (pc in pcs) {
      top_genes_pc <- V[order(abs(V[[pc]]), decreasing = TRUE), ][1:30, c("Gene", pc)]
      colnames(top_genes_pc)[2] <- "Loading"

      cat(sprintf("<details><summary>Top 30 Genes for %s</summary>\n\n", pc))
      print(knitr::kable(top_genes_pc, format = "html", table.attr = "class='table table-condensed table-striped'"))
      cat("</details>\n\n")
    }

    cat("</details>\n\n")
  }

  cat("</details>\n\n")
}

cat("</details>\n\n")




```


# 4.8 Aging Signature of Pseudobulked data PCA without Regressing batch and injury variance

```{r Aging Signature, results='asis', message=FALSE, warning=FALSE}

# ---- Packages ----
library(edgeR)
library(dplyr)
library(tibble)
library(ggplot2)
library(knitr)

VAR_FUN <- stats::var

# ============================================
# A) Male-only, injuries combined
# ============================================
aging_signature_list <- list()
pc_model_results <- list()
result_table <- list()
skipped_tissues <- list()

for (tissue in names(gene_filtered_list)) {
  message(sprintf("▶️ %s", tissue))
  seurat_obj <- subset(gene_filtered_list[[tissue]], subset = Sex == 0)

  if (ncol(seurat_obj) < 2) { skipped_tissues[[tissue]] <- "Not enough male cells"; next }

  DefaultAssay(seurat_obj) <- "RawCounts"
  counts <- GetAssayData(seurat_obj, slot = "counts")
  metadata <- seurat_obj@meta.data
  metadata$barcode <- rownames(metadata)
  if (!"ID" %in% colnames(metadata)) { skipped_tissues[[tissue]] <- "Missing ID column"; next }

  split_cells <- split(metadata$barcode, f = metadata$ID)
  pseudobulk_matrix <- sapply(split_cells, function(cells) Matrix::rowSums(counts[, cells, drop = FALSE]))
  if (ncol(pseudobulk_matrix) < 2) { skipped_tissues[[tissue]] <- "Fewer than 2 pseudobulk samples"; next }

  dge <- edgeR::DGEList(counts = pseudobulk_matrix)
  dge <- edgeR::calcNormFactors(dge)
  logCPM <- edgeR::cpm(dge, log = TRUE, prior.count = 1)

  gene_vars <- apply(logCPM, 1, VAR_FUN)
  gene_vars <- gene_vars[gene_vars > 0]
  top_genes <- names(sort(gene_vars, decreasing = TRUE))[1:floor(0.5 * length(gene_vars))]
  logCPM_top <- logCPM[top_genes, , drop = FALSE]
  if (nrow(logCPM_top) < 2 || ncol(logCPM_top) < 2) { skipped_tissues[[tissue]] <- "Not enough variable genes or samples"; next }

  pca_res <- prcomp(t(logCPM_top), center = TRUE, scale. = TRUE)
  npcs <- min(5, ncol(pca_res$x))
  if (npcs < 1) { skipped_tissues[[tissue]] <- "PCA produced no components"; next }

  pca_scores <- as.data.frame(pca_res$x[, 1:npcs, drop = FALSE])
  pca_scores$ID <- rownames(pca_scores)

  sample_annot <- unique(metadata[, c("ID", "Age", "Injury", "Batch")])
  rownames(sample_annot) <- sample_annot$ID
  pca_scores <- dplyr::left_join(pca_scores, sample_annot, by = "ID")

  pcs_to_model <- paste0("PC", 1:npcs)
  lm_results <- lapply(pcs_to_model, function(pc) lm(as.formula(paste(pc, "~ Age + Injury + Batch")), data = pca_scores))
  names(lm_results) <- pcs_to_model

  extract_pval <- function(lmres, term) {
    s <- summary(lmres)
    if (term %in% rownames(coef(s))) coef(s)[term, "Pr(>|t|)"] else NA
  }
  age_pvals    <- sapply(lm_results, extract_pval, term = "Age")
  injury_pvals <- sapply(lm_results, extract_pval, term = "Injury")
  batch_pvals  <- sapply(lm_results, extract_pval, term = "Batch")
  if (all(is.na(age_pvals))) { skipped_tissues[[tissue]] <- "No valid Age model"; next }

  top3_pc_age     <- names(sort(age_pvals))[1:min(3, length(age_pvals))]
  top3_pvals_age  <- signif(age_pvals[top3_pc_age], 3)
  best_pc_injury  <- names(which.min(injury_pvals))
  best_pc_batch   <- names(which.min(batch_pvals))
  best_pval_injury<- min(injury_pvals, na.rm = TRUE)
  best_pval_batch <- min(batch_pvals,  na.rm = TRUE)

  pc_model_results[[tissue]] <- list(
    Age    = lapply(top3_pc_age, function(pc) summary(lm_results[[pc]])),
    Injury = summary(lm_results[[best_pc_injury]]),
    Batch  = summary(lm_results[[best_pc_batch]])
  )

  pc_loadings <- pca_res$rotation[, top3_pc_age[1]]
  up_genes   <- names(sort(pc_loadings, decreasing = TRUE))[1:25]
  down_genes <- names(sort(pc_loadings, decreasing = FALSE))[1:25]

  aging_signature_list[[tissue]] <- list(
    Top3_PC_Age    = top3_pc_age,
    P_values_Age   = age_pvals[top3_pc_age],
    Best_PC_Injury = best_pc_injury,
    P_value_Injury = best_pval_injury,
    Best_PC_Batch  = best_pc_batch,
    P_value_Batch  = best_pval_batch,
    Up_in_Aged     = up_genes,
    Down_in_Aged   = down_genes,
    Loadings       = pc_loadings
  )

  result_table[[tissue]] <- data.frame(
    Tissue          = tissue,
    Top3_PCs_Age    = paste(top3_pc_age, collapse = ", "),
    Age_Ps          = paste(top3_pvals_age, collapse = ", "),
    Best_PC_Injury  = best_pc_injury,
    Injury_P        = signif(best_pval_injury, 3),
    Best_PC_Batch   = best_pc_batch,
    Batch_P         = signif(best_pval_batch, 3),
    Top_Up_in_Aged  = paste(up_genes[1:3], collapse = ", "),
    Top_Down_in_Aged= paste(down_genes[1:3], collapse = ", "),
    stringsAsFactors = FALSE
  )
}

summary_df <- bind_rows(result_table) %>% as_tibble()

# ---- Pretty summary + per-tissue collapsibles (combined) ----
cat("<details open><summary><strong>📋 Summary — All Injuries Combined</strong></summary>\n\n")
print(
  knitr::kable(
    summary_df %>% select(Tissue, Top3_PCs_Age, Age_Ps, Best_PC_Injury, Injury_P, Best_PC_Batch, Batch_P),
    format = "html",
    table.attr = "class='table table-sm table-striped'",
    col.names = c("Tissue","Top 3 PCs (Age)","Age p's","Best PC (Injury)","Injury p","Best PC (Batch)","Batch p")
  )
)
cat("</details>\n\n")

for (tissue in names(aging_signature_list)) {
  info <- aging_signature_list[[tissue]]
  row  <- summary_df %>% filter(Tissue == tissue)

  cat(sprintf("<details><summary><strong>%s — details</strong></summary>\n\n", tissue))

  stats_tbl <- data.frame(
    `Top 3 PCs (Age)` = row$Top3_PCs_Age,
    `Age p's`         = row$Age_Ps,
    `Best PC (Injury)`= row$Best_PC_Injury,
    `Injury p`        = signif(row$Injury_P, 3),
    `Best PC (Batch)` = row$Best_PC_Batch,
    `Batch p`         = signif(row$Batch_P, 3),
    check.names = FALSE
  )
  print(knitr::kable(stats_tbl, format = "html", table.attr = "class='table table-sm table-bordered'"))

  cat("<p><strong>⬆️ Up in Aged (top 25 loadings)</strong></p>\n")
  cat("<div style='max-height:160px; overflow:auto; font-family:monospace;'>",
      paste(info$Up_in_Aged, collapse = ", "), "</div>\n")

  cat("<p><strong>⬇️ Down in Aged (bottom 25 loadings)</strong></p>\n")
  cat("<div style='max-height:160px; overflow:auto; font-family:monospace;'>",
      paste(info$Down_in_Aged, collapse = ", "), "</div>\n")

  cat("</details>\n\n")
}

# ---- Bar plot for combined section ----
ggplot(summary_df, aes(x = reorder(Tissue, as.numeric(sub(",.*", "", Age_Ps))),
                       y = as.numeric(sub(",.*", "", Age_Ps)))) +
  geom_col(fill = "steelblue") +
  coord_flip() +
  geom_hline(yintercept = 0.05, linetype = "dashed", color = "red") +
  labs(title = "Top Age-Associated PC per Tissue (Male-only)",
       y = "Top PC Age p-value", x = "Tissue") +
  theme_minimal()


# ============================================
# B) Male-only, injury-stratified (Batch adjusted where applicable)
# ============================================
injury_levels <- c(0, 2, 3)
all_results <- list()
all_skipped <- list()

for (injury_level in injury_levels) {
  message(sprintf("🔹 Injury = %s", injury_level))

  result_table <- list()
  skipped_tissues <- list()

  for (tissue in names(gene_filtered_list)) {
    message(sprintf("▶️ %s", tissue))
    seurat_obj <- subset(gene_filtered_list[[tissue]], subset = Sex == 0 & Injury == injury_level)
    if (ncol(seurat_obj) < 2) { skipped_tissues[[tissue]] <- "Not enough male cells"; next }

    DefaultAssay(seurat_obj) <- "RawCounts"
    counts <- GetAssayData(seurat_obj, slot = "counts")
    metadata <- seurat_obj@meta.data
    metadata$barcode <- rownames(metadata)
    if (!"ID" %in% colnames(metadata)) { skipped_tissues[[tissue]] <- "Missing ID column"; next }

    split_cells <- split(metadata$barcode, f = metadata$ID)
    pseudobulk_matrix <- sapply(split_cells, function(cells) Matrix::rowSums(counts[, cells, drop = FALSE]))
    if (ncol(pseudobulk_matrix) < 2) { skipped_tissues[[tissue]] <- "Fewer than 2 pseudobulk samples"; next }

    dge <- edgeR::DGEList(counts = pseudobulk_matrix)
    dge <- edgeR::calcNormFactors(dge)
    logCPM <- edgeR::cpm(dge, log = TRUE, prior.count = 1)

    gene_vars <- apply(logCPM, 1, VAR_FUN)
    gene_vars <- gene_vars[gene_vars > 0]
    top_genes <- names(sort(gene_vars, decreasing = TRUE))[1:floor(0.5 * length(gene_vars))]
    logCPM_top <- logCPM[top_genes, , drop = FALSE]
    if (nrow(logCPM_top) < 2 || ncol(logCPM_top) < 2) { skipped_tissues[[tissue]] <- "Not enough variable genes or samples"; next }

    pca_res <- prcomp(t(logCPM_top), center = TRUE, scale. = TRUE)
    if (ncol(pca_res$x) < 1) { skipped_tissues[[tissue]] <- "PCA failed: no components"; next }

    npcs <- min(5, ncol(pca_res$x))
    pcs_to_model <- paste0("PC", 1:npcs)
    pca_scores <- as.data.frame(pca_res$x[, pcs_to_model, drop = FALSE])
    pca_scores$ID <- rownames(pca_scores)

    sample_annot <- unique(metadata[, c("ID", "Age", "Batch")])
    rownames(sample_annot) <- sample_annot$ID
    pca_scores <- dplyr::left_join(pca_scores, sample_annot, by = "ID")
    if (nrow(pca_scores) < 3) { skipped_tissues[[tissue]] <- "Too few samples after merge"; next }

    model_formula <- if (injury_level %in% c(0, 2)) {
      function(pc) as.formula(paste(pc, "~ Age + Batch"))
    } else {
      function(pc) as.formula(paste(pc, "~ Age"))
    }
    lm_results <- lapply(pcs_to_model, function(pc) lm(model_formula(pc), data = pca_scores))
    names(lm_results) <- pcs_to_model

    extract_pval <- function(lmres, term) {
      s <- summary(lmres)
      if (term %in% rownames(coef(s))) coef(s)[term, "Pr(>|t|)"] else NA
    }
    age_pvals   <- sapply(lm_results, extract_pval, term = "Age")
    batch_pvals <- if (injury_level %in% c(0, 2)) sapply(lm_results, extract_pval, term = "Batch") else rep((NA_real_), length(pcs_to_model))
    if (all(is.na(age_pvals))) { skipped_tissues[[tissue]] <- "No valid Age model"; next }

    top_3_age_pcs   <- names(sort(age_pvals))[1:min(3, length(age_pvals))]
    top_3_age_pvals <- signif(age_pvals[top_3_age_pcs], 3)

    best_pc_batch   <- if (injury_level %in% c(0, 2)) names(which.min(batch_pvals)) else NA
    best_pval_batch <- if (injury_level %in% c(0, 2)) min(batch_pvals, na.rm = TRUE) else NA

    pc_loadings <- pca_res$rotation[, top_3_age_pcs[1]]
    up_genes   <- names(sort(pc_loadings, decreasing = TRUE))[1:25]
    down_genes <- names(sort(pc_loadings, decreasing = FALSE))[1:25]

    result_table[[tissue]] <- data.frame(
      Tissue          = tissue,
      Injury          = injury_level,
      Top3_PCs_Age    = paste(top_3_age_pcs, collapse = ", "),
      Age_Ps          = paste(top_3_age_pvals, collapse = ", "),
      Best_PC_Batch   = best_pc_batch,
      Batch_P         = signif(best_pval_batch, 3),
      Top_Up_in_Aged  = paste(up_genes[1:3], collapse = ", "),
      Top_Down_in_Aged= paste(down_genes[1:3], collapse = ", "),
      stringsAsFactors = FALSE
    )
  }

  all_results[[as.character(injury_level)]] <- bind_rows(result_table)
  all_skipped[[as.character(injury_level)]] <- skipped_tissues
}

# ---- Final combined output (stratified) ----
df <- bind_rows(all_results)

# Grouped summaries + per-tissue collapsibles by injury
for (inj in sort(unique(df$Injury))) {
  sub <- df %>%
    filter(Injury == inj) %>%
    select(Tissue, Top3_PCs_Age, Age_Ps, Best_PC_Batch, Batch_P,
           Top_Up_in_Aged, Top_Down_in_Aged)

  cat(sprintf("<details open><summary><strong>📋 Summary — Injury %s</strong></summary>\n\n", inj))
  print(
    knitr::kable(
      sub %>% select(Tissue, Top3_PCs_Age, Age_Ps, Best_PC_Batch, Batch_P),
      format = "html",
      table.attr = "class='table table-sm table-striped'",
      col.names = c("Tissue","Top 3 PCs (Age)","Age p's","Best PC (Batch)","Batch p")
    )
  )
  cat("</details>\n\n")

  split(sub, sub$Tissue) |> lapply(function(rw) {
    tissue <- rw$Tissue[1]
    cat(sprintf("<details><summary><strong>%s — Injury %s details</strong></summary>\n\n", tissue, inj))

    stats_tbl <- rw %>% select(Top3_PCs_Age, Age_Ps, Best_PC_Batch, Batch_P)
    print(knitr::kable(stats_tbl, format = "html",
                       table.attr = "class='table table-sm table-bordered'",
                       col.names = c("Top 3 PCs (Age)","Age p's","Best PC (Batch)","Batch p")))

    cat("<p><strong>⬆️ Up in Aged (top 3 preview)</strong></p>\n")
    cat("<div style='max-height:120px; overflow:auto; font-family:monospace;'>",
        rw$Top_Up_in_Aged[1], "</div>\n")

    cat("<p><strong>⬇️ Down in Aged (top 3 preview)</strong></p>\n")
    cat("<div style='max-height:120px; overflow:auto; font-family:monospace;'>",
        rw$Top_Down_in_Aged[1], "</div>\n")

    cat("</details>\n\n")
  })
}

# ---- Barplot of top Age p-values (stratified) ----
ggplot(df, aes(x = reorder(Tissue, as.numeric(sub(",.*", "", Age_Ps))),
               y = as.numeric(sub(",.*", "", Age_Ps)), fill = factor(Injury))) +
  geom_col(position = position_dodge()) +
  coord_flip() +
  geom_hline(yintercept = 0.05, linetype = "dashed", color = "red") +
  facet_wrap(~Injury) +
  labs(title = "Top PCs Associated with Age (by Tissue & Injury)",
       y = "Top PC Age p-value", x = "Tissue") +
  theme_minimal()


```


# 4.9 Aging Signature of Pseudobulked Data PCA (Batch & Injury Regressed)


```{r AgingSignatureRegressedversions, echo=FALSE, results='asis', message=FALSE, warning=FALSE}


# ---- Packages ----
library(edgeR)
library(limma)
library(dplyr)
library(tibble)
library(ggplot2)
library(knitr)
library(openxlsx)

VAR_FUN <- stats::var

# Small helpers
to_num01 <- function(x) {
  if (is.factor(x)) {
    xx <- suppressWarnings(as.numeric(as.character(x)))
    if (all(is.finite(xx))) return(xx)
    # fallback: try to map factor levels that look like 0/1
    lev <- levels(x)
    map <- setNames(seq_along(lev), lev)
    return(as.numeric(map[as.character(x)]) - 1)
  }
  as.numeric(x)
}

signed_loading <- function(load_vec, beta_age) {
  # Align PC loadings so positive = higher in Aged (Age==1)
  s <- ifelse(is.na(beta_age) || beta_age == 0, 1, sign(beta_age))
  load_vec * s
}

# =========================================================
# A) Male-only, Injuries Combined — Batch & Injury regressed out
# =========================================================
aging_signature_combined <- list()
pc_model_results_combined <- list()
result_table_combined <- list()
skipped_tissues_combined <- list()

for (tissue in names(gene_filtered_list)) {
  message(sprintf("▶️ %s", tissue))
  seurat_obj <- subset(gene_filtered_list[[tissue]], subset = Sex == 0)
  if (ncol(seurat_obj) < 2) { skipped_tissues_combined[[tissue]] <- "Not enough male cells"; next }

  DefaultAssay(seurat_obj) <- "RawCounts"
  counts <- GetAssayData(seurat_obj, slot = "counts")
  md <- seurat_obj@meta.data
  md$barcode <- rownames(md)
  if (!"ID" %in% colnames(md)) { skipped_tissues_combined[[tissue]] <- "Missing ID column"; next }

  # ---- Pseudobulk by ID
  split_cells <- split(md$barcode, f = md$ID)
  pb <- sapply(split_cells, function(cells) Matrix::rowSums(counts[, cells, drop = FALSE]))
  if (ncol(pb) < 2) { skipped_tissues_combined[[tissue]] <- "Fewer than 2 pseudobulk samples"; next }

  # ---- logCPM
  dge <- edgeR::DGEList(counts = pb)
  dge <- edgeR::calcNormFactors(dge)
  logCPM <- edgeR::cpm(dge, log = TRUE, prior.count = 1)

  # ---- Regress Batch & Injury (if present)
  md_unique <- unique(md[, intersect(c("ID","Batch","Injury"), colnames(md)), drop = FALSE])
  rownames(md_unique) <- md_unique$ID
  md_unique <- md_unique[colnames(logCPM), , drop = FALSE]

  batch_vec <- if ("Batch" %in% colnames(md_unique)) md_unique$Batch else NULL
  if (!is.null(batch_vec) && length(unique(batch_vec)) < 2) batch_vec <- NULL

  covar_mat <- NULL
  if ("Injury" %in% colnames(md_unique) && length(unique(md_unique$Injury)) > 1) {
    # remove intercept to avoid collinearity
    mm <- model.matrix(~ Injury, data = md_unique)
    covar_mat <- mm[, colnames(mm) != "(Intercept)", drop = FALSE]
  }

  logCPM_adj <- limma::removeBatchEffect(logCPM,
                                         batch = batch_vec,
                                         covariates = covar_mat)

  # ---- Feature selection & PCA
  vars <- apply(logCPM_adj, 1, VAR_FUN); vars <- vars[vars > 0]
  if (length(vars) < 10) { skipped_tissues_combined[[tissue]] <- "Too few variable genes"; next }
  top_genes <- names(sort(vars, decreasing = TRUE))[1:floor(0.5 * length(vars))]
  X <- t(logCPM_adj[top_genes, , drop = FALSE])
  pca <- prcomp(X, center = TRUE, scale. = TRUE)

  npcs <- min(5, ncol(pca$x))
  if (is.null(npcs) || npcs < 1) { skipped_tissues_combined[[tissue]] <- "PCA produced no components"; next }
  pcs_to_model <- paste0("PC", 1:npcs)

  # ---- Model PCs ~ Age (Age numeric 0/1)
  scores <- as.data.frame(pca$x[, pcs_to_model, drop = FALSE]); scores$ID <- rownames(scores)
  age_annot <- unique(md[, c("ID","Age")]); rownames(age_annot) <- age_annot$ID
  scores <- dplyr::left_join(scores, age_annot, by = "ID")
  scores$Age <- to_num01(scores$Age)

  lm_list <- lapply(pcs_to_model, function(pc) lm(as.formula(paste(pc, "~ Age")), data = scores))
  names(lm_list) <- pcs_to_model

  get_p <- function(fit, term) {
    s <- summary(fit)
    if (!"Age" %in% rownames(coef(s))) return(NA_real_)
    coef(s)["Age","Pr(>|t|)"]
  }
  age_p <- sapply(lm_list, get_p, term = "Age")
  if (all(is.na(age_p))) { skipped_tissues_combined[[tissue]] <- "No valid Age model"; next }

  top3 <- names(sort(age_p))[1:min(3, length(age_p))]
  top3_p <- signif(age_p[top3], 3)

  # ---- Sign-align loadings for the most Age-associated PC
  top_pc <- top3[1]
  beta_age <- coef(lm_list[[top_pc]])["Age"]
  load_raw <- pca$rotation[, top_pc]
  load_signed <- signed_loading(load_raw, beta_age)

  up_genes   <- names(sort(load_signed, decreasing = TRUE))[1:50]
  down_genes <- names(sort(load_signed, decreasing = FALSE))[1:50]

  aging_signature_combined[[tissue]] <- list(
    Top3_PC_Age   = top3,
    P_values_Age  = age_p[top3],
    Up_in_Aged    = up_genes,
    Down_in_Aged  = down_genes,
    Loadings      = load_signed,    # store signed loadings
    TopPC         = top_pc,
    Beta_Age_Top  = beta_age
  )

  result_table_combined[[tissue]] <- data.frame(
    Tissue = tissue,
    Top3_PCs_Age = paste(top3, collapse = ", "),
    Age_Ps = paste(top3_p, collapse = ", "),
    Top_Up_in_Aged = paste(up_genes[1:3], collapse = ", "),
    Top_Down_in_Aged = paste(down_genes[1:3], collapse = ", "),
    stringsAsFactors = FALSE
  )
}

summary_df_combined <- bind_rows(result_table_combined) %>% as_tibble()

# ---- Collapsibles: summary + per-tissue details (COMBINED)
cat("<details open><summary><strong>📋 Summary — All Injuries Combined (Batch & Injury regressed)</strong></summary>\n\n")
print(
  knitr::kable(
    summary_df_combined %>% select(Tissue, Top3_PCs_Age, Age_Ps),
    format = "html",
    table.attr = "class='table table-sm table-striped'",
    col.names = c("Tissue","Top 3 PCs (Age)","Age p's")
  )
)
cat("</details>\n\n")

for (tissue in names(aging_signature_combined)) {
  info <- aging_signature_combined[[tissue]]
  row  <- summary_df_combined %>% filter(Tissue == tissue)

  cat(sprintf("<details><summary><strong>%s — details</strong></summary>\n\n", tissue))

  stats_tbl <- data.frame(`Top 3 PCs (Age)` = row$Top3_PCs_Age,
                          `Age p's` = row$Age_Ps, check.names = FALSE)
  print(knitr::kable(stats_tbl, format = "html",
                     table.attr = "class='table table-sm table-bordered'"))

  cat("<p><strong>⬆️ Up in Aged (top 50 signed loadings)</strong></p>\n")
  cat("<div style='max-height:160px; overflow:auto; font-family:monospace;'>",
      paste(info$Up_in_Aged, collapse = ", "), "</div>\n")

  cat("<p><strong>⬇️ Down in Aged (bottom 50 signed loadings)</strong></p>\n")
  cat("<div style='max-height:160px; overflow:auto; font-family:monospace;'>",
      paste(info$Down_in_Aged, collapse = ", "), "</div>\n")

  cat("</details>\n\n")
}

# ---- Bar plot of top Age p-values (COMBINED)
ggplot(summary_df_combined, aes(x = reorder(Tissue, as.numeric(sub(",.*", "", Age_Ps))),
                                y = as.numeric(sub(",.*", "", Age_Ps)))) +
  geom_col(fill = "steelblue") +
  coord_flip() +
  geom_hline(yintercept = 0.05, linetype = "dashed", color = "red") +
  labs(title = "Top Age-Associated PC per Tissue (Male-only; Batch & Injury regressed)",
       y = "Top PC Age p-value", x = "Tissue") +
  theme_minimal()

# ---- Excel: genes with signed loadings (COMBINED)
aging_signature_table_combined <- do.call(rbind, lapply(names(aging_signature_combined), function(tissue) {
  sig <- aging_signature_combined[[tissue]]
  top_pc <- sig$TopPC
  pval_age <- signif(sig$P_values_Age[1], 4)
  up_df <- data.frame(Tissue=tissue, Top_PC=top_pc, P_value_Age=pval_age,
                      Direction="Up", Gene=sig$Up_in_Aged,
                      Loading=sig$Loadings[sig$Up_in_Aged], stringsAsFactors=FALSE)
  down_df <- data.frame(Tissue=tissue, Top_PC=top_pc, P_value_Age=pval_age,
                        Direction="Down", Gene=sig$Down_in_Aged,
                        Loading=sig$Loadings[sig$Down_in_Aged], stringsAsFactors=FALSE)
  rbind(up_df, down_df)
}))
openxlsx::write.xlsx(aging_signature_table_combined,
                     file = "AgingSignatureGenes_WithLoadings_COMBINED.xlsx",
                     rowNames = FALSE)
cat("✅ Saved: ", file.path(getwd(), "AgingSignatureGenes_WithLoadings_COMBINED.xlsx"), "\n\n")






######### RUN GSEA ############

library(fgsea)

# GSEA parameters
gsea_min_size <- 15
gsea_max_size <- 500
gsea_q_cutoff <- 0.20
gsea_nperm_fast <- 5000  # you can lower to 2000 for speed

gsea_results_pc <- list()

for (tissue in names(aging_signature_combined)) {
  sig <- aging_signature_combined[[tissue]]
  
  # Ranking vector: signed loadings from top Age PC
  ranked_genes <- sig$Loadings
  ranked_genes <- sort(ranked_genes, decreasing = TRUE)
  
  # Run fgsea
  set.seed(123)
  fg <- fgsea::fgsea(
    pathways = pathways_mouse,
    stats    = ranked_genes,
    minSize  = gsea_min_size,
    maxSize  = gsea_max_size,
    nperm    = gsea_nperm_fast
  )
  
  # Optional: define "DE" genes for overlap — here by top/bottom loadings
  loading_cut <- quantile(abs(ranked_genes), 0.90)  # top 10% abs loading
  de_genes <- names(ranked_genes)[abs(ranked_genes) >= loading_cut]
  
  fg$leadingEdge_count    <- vapply(fg$leadingEdge, length, integer(1))
  fg$leadingEdge_DE_count <- vapply(fg$leadingEdge, function(g) sum(g %in% de_genes), integer(1))
  fg$leadingEdge_DE_genes <- vapply(
    fg$leadingEdge, function(g) paste(intersect(g, de_genes), collapse = ", "),
    FUN.VALUE = character(1)
  )
  fg$leadingEdge <- vapply(fg$leadingEdge, paste, collapse = ", ", FUN.VALUE = character(1))
  
  fg$Tissue <- tissue
  fg$TopPC <- sig$TopPC
  fg$Age_p <- signif(sig$P_values_Age[1], 4)
  
  gsea_results_pc[[tissue]] <- fg
}

# Combine into one table
gsea_summary_pc <- do.call(rbind, gsea_results_pc)
gsea_summary_pc <- gsea_summary_pc[order(gsea_summary_pc$padj), ]

# Filter to significant
gsea_sig_pc <- subset(gsea_summary_pc, !is.na(padj) & padj < gsea_q_cutoff)

# Save to CSV
write.csv(gsea_sig_pc, "GSEA_PC_Loadings_Significant.csv", row.names = FALSE)
cat("✅ Saved:", file.path(getwd(), "GSEA_PC_Loadings_Significant.csv"), "\n")






# =========================================================
# B) Male-only, Injury-Stratified — Batch regressed (within injury)
# =========================================================
injury_levels <- c(0, 2, 3)
all_results_byinjury <- list()
all_skipped_byinjury <- list()
byinjury_signature <- list()  # store signed results for export

for (inj in injury_levels) {
  message(sprintf("🔹 Injury = %s", inj))

  result_table <- list()
  skipped_tissues <- list()
  byinjury_signature[[as.character(inj)]] <- list()

  for (tissue in names(gene_filtered_list)) {
    message(sprintf("▶️ %s", tissue))
    seurat_obj <- subset(gene_filtered_list[[tissue]], subset = Sex == 0 & Injury == inj)
    if (ncol(seurat_obj) < 2) { skipped_tissues[[tissue]] <- "Not enough male cells"; next }

    DefaultAssay(seurat_obj) <- "RawCounts"
    counts <- GetAssayData(seurat_obj, slot = "counts")
    md <- seurat_obj@meta.data
    md$barcode <- rownames(md)
    if (!"ID" %in% colnames(md)) { skipped_tissues[[tissue]] <- "Missing ID column"; next }

    # ---- Pseudobulk by ID
    split_cells <- split(md$barcode, f = md$ID)
    pb <- sapply(split_cells, function(cells) Matrix::rowSums(counts[, cells, drop = FALSE]))
    if (ncol(pb) < 2) { skipped_tissues[[tissue]] <- "Fewer than 2 pseudobulk samples"; next }

    # ---- logCPM
    dge <- edgeR::DGEList(counts = pb)
    dge <- edgeR::calcNormFactors(dge)
    logCPM <- edgeR::cpm(dge, log = TRUE, prior.count = 1)

    # ---- Regress Batch (within this injury) if >1 level
    md_u <- unique(md[, intersect(c("ID","Batch"), colnames(md)), drop = FALSE])
    rownames(md_u) <- md_u$ID
    md_u <- md_u[colnames(logCPM), , drop = FALSE]
    batch_vec <- if ("Batch" %in% colnames(md_u)) md_u$Batch else NULL
    if (!is.null(batch_vec) && length(unique(batch_vec)) > 1) {
      logCPM_adj <- limma::removeBatchEffect(logCPM, batch = batch_vec)
    } else {
      logCPM_adj <- logCPM
    }

    # ---- PCA
    vars <- apply(logCPM_adj, 1, VAR_FUN); vars <- vars[vars > 0]
    if (length(vars) < 10) { skipped_tissues[[tissue]] <- "Too few variable genes"; next }
    top_genes <- names(sort(vars, decreasing = TRUE))[1:floor(0.5 * length(vars))]
    X <- t(logCPM_adj[top_genes, , drop = FALSE])
    pca <- prcomp(X, center = TRUE, scale. = TRUE)

    npcs <- min(5, ncol(pca$x))
    if (is.null(npcs) || npcs < 1) { skipped_tissues[[tissue]] <- "PCA produced no components"; next }
    pcs_to_model <- paste0("PC", 1:npcs)

    # ---- Model PCs ~ Age (Age numeric 0/1)
    scores <- as.data.frame(pca$x[, pcs_to_model, drop = FALSE]); scores$ID <- rownames(scores)
    age_annot <- unique(md[, c("ID","Age")]); rownames(age_annot) <- age_annot$ID
    scores <- dplyr::left_join(scores, age_annot, by = "ID")
    if (nrow(scores) < 3) { skipped_tissues[[tissue]] <- "Too few samples after merge"; next }
    scores$Age <- to_num01(scores$Age)

    lm_list <- lapply(pcs_to_model, function(pc) lm(as.formula(paste(pc, "~ Age")), data = scores))
    names(lm_list) <- pcs_to_model

    get_p <- function(fit, term) {
      s <- summary(fit)
      if (!"Age" %in% rownames(coef(s))) return(NA_real_)
      coef(s)["Age","Pr(>|t|)"]
    }
    age_p <- sapply(lm_list, get_p, term = "Age")
    if (all(is.na(age_p))) { skipped_tissues[[tissue]] <- "No valid Age model"; next }

    top3 <- names(sort(age_p))[1:min(3, length(age_p))]
    top3_p <- signif(age_p[top3], 3)

    # ---- Sign-align loadings for the most Age-associated PC
    top_pc <- top3[1]
    beta_age <- coef(lm_list[[top_pc]])["Age"]
    load_raw <- pca$rotation[, top_pc]
    load_signed <- signed_loading(load_raw, beta_age)

    up_genes   <- names(sort(load_signed, decreasing = TRUE))[1:50]
    down_genes <- names(sort(load_signed, decreasing = FALSE))[1:50]

    # store for summary
    result_table[[tissue]] <- data.frame(
      Tissue = tissue, Injury = inj,
      Top3_PCs_Age = paste(top3, collapse = ", "),
      Age_Ps = paste(top3_p, collapse = ", "),
      Top_Up_in_Aged = paste(up_genes[1:50], collapse = ", "),
      Top_Down_in_Aged = paste(down_genes[1:50], collapse = ", "),
      stringsAsFactors = FALSE
    )

    # store full signed results for export
    byinjury_signature[[as.character(inj)]][[tissue]] <- list(
      Top3_PC_Age   = top3,
      P_values_Age  = age_p[top3],
      Up_in_Aged    = up_genes,
      Down_in_Aged  = down_genes,
      Loadings      = load_signed,   # signed
      TopPC         = top_pc,
      Beta_Age_Top  = beta_age
    )
  }

  all_results_byinjury[[as.character(inj)]] <- bind_rows(result_table)
  all_skipped_byinjury[[as.character(inj)]] <- skipped_tissues
}

df_byinjury <- bind_rows(all_results_byinjury)

# ---- Collapsibles: by-injury summaries + per-tissue details
for (inj in sort(unique(df_byinjury$Injury))) {
  sub <- df_byinjury %>% filter(Injury == inj) %>%
    select(Tissue, Top3_PCs_Age, Age_Ps, Top_Up_in_Aged, Top_Down_in_Aged)

  cat(sprintf("<details open><summary><strong>📋 Summary — Injury %s (Batch regressed)</strong></summary>\n\n", inj))
  print(
    knitr::kable(
      sub %>% select(Tissue, Top3_PCs_Age, Age_Ps),
      format = "html",
      table.attr = "class='table table-sm table-striped'",
      col.names = c("Tissue","Top 3 PCs (Age)","Age p's")
    )
  )
  cat("</details>\n\n")

  split(sub, sub$Tissue) |> lapply(function(rw) {
    tissue <- rw$Tissue[1]
    cat(sprintf("<details><summary><strong>%s — Injury %s details</strong></summary>\n\n", tissue, inj))

    stats_tbl <- rw %>% select(Top3_PCs_Age, Age_Ps)
    print(knitr::kable(stats_tbl, format = "html",
                       table.attr = "class='table table-sm table-bordered'",
                       col.names = c("Top 3 PCs (Age)","Age p's")))

    cat("<p><strong>⬆️ Up in Aged (top 50 signed loadings)</strong></p>\n")
    cat("<div style='max-height:120px; overflow:auto; font-family:monospace;'>",
        rw$Top_Up_in_Aged[1], "</div>\n")

    cat("<p><strong>⬇️ Down in Aged (bottom 50 signed loadings)</strong></p>\n")
    cat("<div style='max-height:120px; overflow:auto; font-family:monospace;'>",
        rw$Top_Down_in_Aged[1], "</div>\n")

    cat("</details>\n\n")
  })
}

# ---- Bar plot of top Age p-values (STRATIFIED)
ggplot(df_byinjury, aes(x = reorder(Tissue, as.numeric(sub(",.*", "", Age_Ps))),
                        y = as.numeric(sub(",.*", "", Age_Ps)), fill = factor(Injury))) +
  geom_col(position = position_dodge()) +
  coord_flip() +
  geom_hline(yintercept = 0.05, linetype = "dashed", color = "red") +
  facet_wrap(~Injury) +
  labs(title = "Top PCs Associated with Age (by Tissue & Injury; Batch regressed)",
       y = "Top PC Age p-value", x = "Tissue") +
  theme_minimal()

# ---- Excel: PC loadings by tissue × injury (STRATIFIED; signed)
# Build workbook using stored signed loadings
wb_list <- list()
for (inj in names(byinjury_signature)) {
  sig_by_tissue <- byinjury_signature[[inj]]
  if (length(sig_by_tissue) == 0) next

  for (tissue in names(sig_by_tissue)) {
    sig <- sig_by_tissue[[tissue]]
    ld <- data.frame(
      Gene    = names(sig$Loadings),
      Loading = as.numeric(sig$Loadings),
      stringsAsFactors = FALSE
    ) %>%
      arrange(desc(abs(Loading)))

    sheet <- paste0(substr(tissue, 1, 15), "_Inj", inj)
    wb_list[[sheet]] <- ld
  }
}
if (length(wb_list) > 0) {
  openxlsx::write.xlsx(wb_list,
                       file = "AgingSignature_PC_Loadings_BYINJURY.xlsx",
                       rowNames = FALSE)
  cat("✅ Saved: ", file.path(getwd(), "AgingSignature_PC_Loadings_BYINJURY.xlsx"), "\n")
} else {
  cat("<p><em>No injury-stratified results to export.</em></p>\n")
}



```





# 5 Normalization by Batch checked if needed

## 5.1 Visualizing Colored UMAPs



```{r UMAP, echo=TRUE, results='asis', message=FALSE, warning=FALSE}


if (!requireNamespace("vegan", quietly = TRUE)) {
  install.packages("vegan", repos = "https://cloud.r-project.org")
}

if (!requireNamespace("cluster", quietly = TRUE)) {
  install.packages("cluster", repos = "https://cloud.r-project.org")
}

library(Seurat)
library(ggplot2)
library(patchwork)
library(cluster)
library(vegan)
library(knitr)
library(dplyr)


# Create an empty table to collect the results
pca_stats_table <- data.frame(
  Tissue = character(),
  Variable = character(),
  Silhouette = numeric(),
  R2 = numeric(),
  PValue = numeric(),
  Normalize = character(),
  stringsAsFactors = FALSE
)

for (tissue in names(gene_filtered_list)) {
  obj <- gene_filtered_list[[tissue]]
  DefaultAssay(obj) <- "RawCounts"

  # Normalize and scale
  obj <- NormalizeData(obj, verbose = FALSE)
  obj <- FindVariableFeatures(obj, selection.method = "vst", nfeatures = 2000, verbose = FALSE)
  obj <- ScaleData(obj, verbose = FALSE)
  obj <- RunPCA(obj, verbose = FALSE)
  obj <- RunUMAP(obj, dims = 1:20, reduction.name = "umap_raw", reduction.key = "UMAPraw_")

  cat(sprintf("<details><summary><strong>%s</strong></summary>\n\n", tissue))

  # --- PCA coordinates for silhouette and PERMANOVA ---
  pca_coords <- Embeddings(obj, reduction = "pca")[, 1:20]

  # --- Plot PCA ---
  cat("<p><strong>PCA Colored by Metadata:</strong></p>\n")
  for (meta_var in c("Batch", "Age", "Sex", "Injury")) {
    if (meta_var %in% colnames(obj@meta.data)) {
      p <- DimPlot(obj, reduction = "pca", group.by = meta_var) +
        ggtitle(paste0(tissue, " - PCA by ", meta_var)) +
        theme_minimal()
      print(p)
    }
  }

  # --- Now Silhouette + PERMANOVA based on PCA ---
  for (meta_var in c("Batch", "Age", "Sex", "Injury")) {
    if (meta_var %in% colnames(obj@meta.data)) {
      
      labels <- obj@meta.data[[meta_var]]
      if (length(unique(labels)) < 2) {
        cat(sprintf("<p><em>%s has <2 levels for %s, skipping stats.</em></p>\n", tissue, meta_var))
        next
      }

      # Downsample if too many barcodes (>500) for silhouette
      if (nrow(pca_coords) > 500) {  # smaller for speed!
        set.seed(123)  # reproducible
        keep_cells <- sample(rownames(pca_coords), 500)
        pca_coords_sub <- pca_coords[keep_cells, ]
        labels_sub <- labels[match(keep_cells, rownames(obj@meta.data))]
      } else {
        pca_coords_sub <- pca_coords
        labels_sub <- labels
      }

      # Precompute distance matrix ONCE
      dists <- dist(pca_coords_sub)

      # Silhouette Score
      sil <- silhouette(as.integer(factor(labels_sub)), dists)
      avg_sil <- mean(sil[, 3])

      # PERMANOVA
      meta_df <- data.frame(group = labels_sub)
      perm_result <- adonis2(pca_coords_sub ~ group, data = meta_df, permutations = 199, method = "euclidean")
      r2 <- perm_result$R2[1]
      pval <- perm_result$`Pr(>F)`[1]

      # Print stats inline
      cat(sprintf(
        "<p><strong>%s — Stats based on PCA for %s:</strong> Silhouette = <code>%.3f</code>, PERMANOVA R² = <code>%.3f</code>, p = <code>%.4f</code></p>\n",
        tissue, meta_var, avg_sil, r2, pval
      ))

      # Save stats into pca_stats_table
      normalize_flag <- if (r2 > 0.01 & pval < 0.05) {
        "❗ Yes"
      } else {
        "⬜ Maybe / No"
      }

      pca_stats_table <- rbind(pca_stats_table, data.frame(
        Tissue = tissue,
        Variable = meta_var,
        Silhouette = round(avg_sil, 3),
        R2 = round(r2, 3),
        PValue = signif(pval, 4),
        Normalize = normalize_flag,
        stringsAsFactors = FALSE
      ))
    }
  }

  # --- UMAP visualization ---
  umap_coords <- Embeddings(obj, reduction = "umap_raw")
  
  cat("<p><strong>UMAP Colored by Metadata:</strong></p>\n")
  for (meta_var in c("Batch", "Age", "Sex", "Injury")) {
    if (meta_var %in% colnames(obj@meta.data)) {
      p <- DimPlot(obj, reduction = "umap_raw", group.by = meta_var) +
        ggtitle(paste0(tissue, " - UMAP by ", meta_var)) +
        theme_minimal()
      print(p)
    }
  }

  cat("</details>\n\n")
}

# --- After the loop: print collected pca_stats_table nicely ---
cat('<details><summary><strong>Final PCA Statistics Summary Table</strong></summary>\n\n')
cat("<p>Summary table of PCA separation (Silhouette, PERMANOVA R², p-values, normalization suggestion):</p>\n\n")
cat(kable(pca_stats_table, format = "html", table.attr = "class='table table-bordered table-condensed'"))
cat('\n</details>\n')












library(ggplot2)
library(Seurat)
library(patchwork)

# ✅ Define the non-redundant QC variables
qc_vars <- c(
  "nFeature_RNA", 
  "nCount_RNA", 
  "percent.mt", 
  "complexity_score", 
  "top50_frac", 
  "gene_counts_per_barcode", 
  "total_counts_per_barcode"
)

# ✅ UMAP coordinate ranges for "snake-like" regions per tissue
snake_coords <- list(
  CartilageFemur   = list(x = c(10, 15),   y = c(0, 5)),
  CartilageTibia   = list(x = c(-30, 15),  y = c(-35, -20)),
  SubchondralFemur = list(x = c(12, 25),   y = c(-25, -12)),
  SubchondralTibia = list(x = c(-12, 12),  y = c(-25, -12)),
  Synovium         = list(x = c(-25, -5),  y = c(-13, 5)),
  IPFP             = list(x = c(8, 20),    y = c(-13, 3)),
  Meniscus         = list(x = c(8, 25),    y = c(-5, 13)),
  GrowthPlateFemur = list(x = c(-30, -19), y = c(-15, 0)),
  GrowthPlateTibia = list(x = c(20, 30),   y = c(-10, 0)),
  BoneMarrowFemur  = list(x = c(-30, -11), y = c(-15, 15)),
  BoneMarrowTibia  = list(x = c(10, 25),   y = c(-10, 15))
)

# 🔁 Loop over tissues
for (tissue in names(snake_coords)) {
  cat(sprintf("<details><summary><strong>%s</strong></summary>\n\n", tissue))
  
  obj <- gene_filtered_list[[tissue]]
  DefaultAssay(obj) <- "RawCounts"

  # Run PCA + UMAP if not already present
  if (is.null(Reductions(obj)$umap_raw)) {
    obj <- NormalizeData(obj, verbose = FALSE)
    obj <- FindVariableFeatures(obj, verbose = FALSE)
    obj <- ScaleData(obj, verbose = FALSE)
    obj <- RunPCA(obj, verbose = FALSE)
    obj <- RunUMAP(obj, dims = 1:20, reduction.name = "umap_raw", reduction.key = "UMAPraw_")
  }

  umap_coords <- Embeddings(obj, "umap_raw")
  coord_x <- snake_coords[[tissue]]$x
  coord_y <- snake_coords[[tissue]]$y

  # Identify snake cells based on UMAP region
  snake_cells <- rownames(umap_coords)[
    umap_coords[, 1] >= coord_x[1] & umap_coords[, 1] <= coord_x[2] &
    umap_coords[, 2] >= coord_y[1] & umap_coords[, 2] <= coord_y[2]
  ]

  # Assign identity group
  obj$Group <- ifelse(Cells(obj) %in% snake_cells, "Snake", "Other")

  # Extract metadata
  meta_df <- obj@meta.data

  # 🔬 Violin plots for each QC variable
  for (var in qc_vars) {
    if (var %in% colnames(meta_df)) {
      p <- ggplot(meta_df, aes(x = Group, y = .data[[var]], fill = Group)) +
        geom_violin(trim = FALSE) +
        geom_boxplot(width = 0.1, outlier.size = 0.5) +
        scale_fill_manual(values = c("Snake" = "firebrick", "Other" = "gray")) +
        ggtitle(sprintf("%s — %s: Snake vs Other", tissue, var)) +
        ylab(var) +
        theme_minimal()
      print(p)
    }
  }

  cat("</details>\n\n")
}





```


## 5.2 Visualizing Percentage Mitochondrial Genes along Variables

```{r mitoGeneDistribution, echo=TRUE, results='asis', message=FALSE, warning=FALSE}


library(ggplot2)
library(patchwork)  # optional, to combine plots

library(dplyr)
library(knitr)

for (tissue in names(merged_by_tissue)) {
  obj <- merged_by_tissue[[tissue]]
  md  <- obj@meta.data
  
  cat(sprintf('<details><summary><strong>%s: Percent Mito by Metadata</strong></summary>\n\n', tissue))
  
  for (var in c("Batch", "Sex", "Age", "Injury")) {
    if (var %in% colnames(md)) {
      # Plot
      p <- ggplot(md, aes_string(x = var, y = "percent.mt")) +
        geom_violin(trim = FALSE, fill = "skyblue", color = "gray30") +
        geom_jitter(width = 0.2, alpha = 0.3, size = 0.7) +
        theme_minimal() +
        ylab("Percent Mitochondrial") +
        xlab(var) +
        ggtitle(sprintf("%s: Percent Mito by %s", tissue, var)) +
        theme(
          plot.title = element_text(size = 12, face = "bold"),
          axis.text.x = element_text(angle = 30, hjust = 1)
        )
      print(p)

      # Numerical summary per group
      summary_df <- md %>%
        group_by(.data[[var]]) %>%
        summarise(
          n           = n(),
          Min         = round(min(percent.mt, na.rm = TRUE), 2),
          Q1          = round(quantile(percent.mt, 0.25, na.rm = TRUE), 2),
          Median      = round(median(percent.mt, na.rm = TRUE), 2),
          Mean        = round(mean(percent.mt, na.rm = TRUE), 2),
          Q3          = round(quantile(percent.mt, 0.75, na.rm = TRUE), 2),
          Max         = round(max(percent.mt, na.rm = TRUE), 2),
          .groups     = "drop"
        )
      
      cat(sprintf("<p><strong>%s: Summary of percent.mt by %s</strong></p>", tissue, var))
      cat(kable(
        summary_df,
        format     = "html",
        table.attr = "class='table table-striped table-bordered'",
        caption    = sprintf("Summary of Percent Mitochondrial by %s", var)
      ), "\n\n")
    }
  }
  
  cat('</details>\n\n')
}




```




## 5.3 SCTransform Normalization Before Downstream Analyses 

```{r SCTransfrom, echo=TRUE, results='asis', message=FALSE, warning=FALSE}


library(Seurat)
library(Matrix)
library(dplyr)
library(knitr)

tissues_to_check <- names(gene_filtered_list)

for (tissue in tissues_to_check) {
  cat(sprintf("\n--- Tissue: %s ---\n", tissue))
  obj <- gene_filtered_list[[tissue]]
  
  if (!inherits(obj[["RNA"]], "Assay5")) {
    cat("❌ RNA assay is not of type Assay5. Skipping.\n")
    next
  }
  
  layers <- obj[["RNA"]]@layers
  cat("Number of layers:", length(layers), "\n")
  cat("Layer names:\n")
  print(names(layers))
}


for (tissue in names(gene_filtered_list)) {
  obj <- gene_filtered_list[[tissue]]
  rc <- GetAssayData(obj[["RawCounts"]], slot = "counts")
  rna <- GetAssayData(obj[["RNA"]], slot = "counts")
  cat(sprintf("%s: identical = %s\n", tissue, identical(rc, rna)))
}


# ✅ Check zero-UMI barcodes
meta <- obj@meta.data
if (!"ID" %in% colnames(meta)) meta$ID <- "UnknownID"

# Sample-level zero-UMI summary
sample_stats <- meta %>%
  group_by(ID) %>%
  summarize(
    Zero_Count_Barcodes = sum(nCount_RawCounts == 0),
    Total_Barcodes = n(),
    Percent_Zero = round(100 * sum(nCount_RawCounts == 0) / n(), 2)
  ) %>%
  mutate(Tissue = tissue) %>%
  select(Tissue, Sample = ID, Zero_Count_Barcodes, Total_Barcodes, Percent_Zero)

# Tissue-wide summary
all_zero <- sum(meta$nCount_RawCounts == 0)
all_total <- nrow(meta)
all_percent <- round(100 * all_zero / all_total, 2)

all_row <- data.frame(
  Tissue = tissue,
  Sample = "ALL",
  Zero_Count_Barcodes = all_zero,
  Total_Barcodes = all_total,
  Percent_Zero = all_percent,
  stringsAsFactors = FALSE
)

zero_umi_summary <- rbind(sample_stats, all_row)

# Render collapsible Zero-UMI summary table
cat("<details><summary><strong>Zero-UMI Summary by Sample and Tissue</strong></summary>\n\n")
cat(kable(
  zero_umi_summary,
  format = "html",
  table.attr = "class='table table-striped table-bordered'",
  caption = "Barcodes with zero RawCounts UMIs per sample"
))
cat("\n</details>\n\n")



# ✅ 1. Run the filtering loop with tracking

filtering_summaries <- list()

for (tissue in names(gene_filtered_list)) {
  obj <- gene_filtered_list[[tissue]]
  DefaultAssay(obj) <- "RNA"

  original_ncells <- ncol(obj)
  obj <- subset(obj, subset = nCount_RNA > 0)
  filtered_ncells <- ncol(obj)
  removed_ncells <- original_ncells - filtered_ncells

  cat(sprintf("🧹 %s: Removed %d zero-UMI barcodes\n", tissue, removed_ncells))

  # Save back the cleaned object
  gene_filtered_list[[tissue]] <- obj

  filtering_summaries[[tissue]] <- data.frame(
    Tissue = tissue,
    Original = original_ncells,
    Filtered = filtered_ncells,
    Removed = removed_ncells,
    stringsAsFactors = FALSE
  )
}

# ✅ 2. Combine into a final tracking table



filtering_summary_df <- do.call(rbind, filtering_summaries)

# Show table in HTML (for RMarkdown/Quarto/etc.)
cat(kable(
  filtering_summary_df,
  format = "html",
  table.attr = "class='table table-striped table-bordered'",
  caption = "Summary of zero-UMI barcode removal per tissue"
))



# ✅ 3. (Optional) Confirm no nCount_RNA == 0 left


for (tissue in names(gene_filtered_list)) {
  obj <- gene_filtered_list[[tissue]]
  num_zero <- sum(obj$nCount_RNA == 0)
  cat(sprintf("🔎 %s: %d barcodes with nCount_RNA == 0\n", tissue, num_zero))
}




# ✅ 4 SCTranform

rm(normalized_list)


# ✅ SCTransform across all gene-filtered tissues
normalized_list <- list()

for (tissue in names(gene_filtered_list)) {
  obj <- gene_filtered_list[[tissue]]
  DefaultAssay(obj) <- "RNA"

  # ✅ Run SCTransform using RNA assay
  if ("Batch" %in% colnames(obj@meta.data)) {
    obj <- SCTransform(obj,
                       assay = "RNA",
                       new.assay.name = "SCT",
                       vars.to.regress = "Batch",
                       verbose = FALSE)
  } else {
    warning(paste("No 'Batch' column in", tissue, "- SCTransform without regression"))
    obj <- SCTransform(obj,
                       assay = "RNA",
                       new.assay.name = "SCT",
                       verbose = FALSE)
  }
  DefaultAssay(obj) <- "SCT"
  obj <- RunPCA(obj, verbose = FALSE)
  obj <- RunUMAP(obj, dims = 1:20, verbose = FALSE)

  # ✅ Save normalized object
  normalized_list[[tissue]] <- obj

  # ✅ Check assays
  cat(sprintf("✅ %s: Assays present → %s\n", tissue, paste(names(obj@assays), collapse = ", ")))
}

# --- 📋 Output summaries
cat('<details><summary><strong>📊 Barcode Filtering Summary Before SCTransform</strong></summary>\n\n')
cat("<p>Summary of how many barcodes were kept or removed during filtering before SCTransform:</p>\n\n")
cat(kable(filtering_summary_df, format = "html", table.attr = "class='table table-bordered table-condensed'"))
cat('\n</details>\n\n')

cat('<details><summary><strong>📊 Zero-UMI Barcodes Summary by Sample (before filtering)</strong></summary>\n\n')
cat("<p>Detailed summary of zero-UMI barcodes per sample and tissue before filtering:</p>\n\n")
cat(kable(zero_umi_summary, format = "html", table.attr = "class='table table-bordered table-condensed'"))
cat('\n</details>\n\n')



```


## 5.4 Normalization Check


```{r normCheck, echo=TRUE, results='asis', message=FALSE, warning=FALSE}



cat('<details><summary><strong>QC and PCA by Batch Number after SCTransform</strong></summary>\n\n')

library(ggplot2)
library(knitr)
library(patchwork)
library(Seurat)
library(sctransform)

for (tissue in names(normalized_list)) {
  obj <- normalized_list[[tissue]]
  if (!"Batch" %in% colnames(obj@meta.data)) next

  cat(sprintf('<details><summary><strong>%s</strong></summary>\n\n', tissue))

  # 1. Violin plot of percent.mt by Batch Number
  vln_mt <- ggplot(obj@meta.data, aes(x = Batch, y = percent.mt)) +
    geom_violin(trim = FALSE, fill = "lightblue") +
    geom_jitter(width = 0.2, alpha = 0.3) +
    theme_minimal() +
    ylab("Percent Mitochondrial") +
    xlab("Batch") +
    ggtitle("Mito % by Batch")

  # 2. PCA plot by Batch
  DefaultAssay(obj) <- "SCT"
  obj <- RunPCA(obj, verbose = FALSE)

  pca_df <- as.data.frame(Embeddings(obj, "pca")[, 1:2])
  pca_df$Batch <- obj@meta.data$Batch

  pca_plot <- ggplot(pca_df, aes(x = PC_1, y = PC_2, color = Batch)) +
    geom_point(alpha = 0.4, size = 0.8) +
    theme_minimal() +
    ggtitle("PCA by Batch Number (SCT normalized)")

  print(vln_mt + pca_plot)

  # 3. Table: Barcodes per Batch 
  run_summary <- as.data.frame(table(obj@meta.data$Batch))
  colnames(run_summary) <- c("Batch", "Barcode_Count")
  cat("<p><strong>Number of Barcodes per Batch:</strong></p>")
  cat(kable(run_summary, format = "html", table.attr = "class='table table-bordered table-striped'"))

  # 4. Residuals summary
  residual_mat <- GetAssayData(obj, assay = "SCT", slot = "scale.data")
  residual_summary <- data.frame(
    Mean = round(mean(residual_mat), 3),
    SD   = round(sd(residual_mat),   3),
    Min  = round(min(residual_mat),  3),
    Max  = round(max(residual_mat),  3)
  )
  cat("<p><strong>Residuals from SCT normalization (scale.data summary):</strong></p>")
  cat(kable(residual_summary, format = "html", table.attr = "class='table table-bordered table-condensed'"))

  # 5. HVGs
  hvgs <- VariableFeatures(obj)
  cat(sprintf("<p><strong># Highly Variable Genes (HVGs):</strong> %d</p>", length(hvgs)))

  # 6. PCA Variance Explained
  eigvals <- obj[["pca"]]@stdev^2
  variance_df <- data.frame(
    PC = paste0("PC", 1:5),
    Variance_Explained = round(100 * eigvals[1:5] / sum(eigvals), 2)
  )
  cat("<p><strong>Top 5 PCs: Variance Explained (%):</strong></p>")
  cat(kable(variance_df, format = "html", table.attr = "class='table table-striped table-bordered'"))

  # 7. Histogram of SCT residuals
  residual_values <- as.vector(residual_mat)
  p_resid <- ggplot(data.frame(Value = residual_values), aes(x = Value)) +
    geom_histogram(bins = 100, fill = "darkorange", alpha = 0.7) +
    theme_minimal() +
    xlab("Residual (SCT normalized)") +
    ylab("Frequency") +
    ggtitle("Distribution of SCT Residuals")
  print(p_resid)

  # 8. HVG plot using manual vst()
  DefaultAssay(obj) <- "RNA"
  counts <- GetAssayData(obj, slot = "counts")
  vst_out <- vst(counts, return_gene_attr = TRUE, return_cell_attr = TRUE, show_progress = FALSE)
  gene_stats <- vst_out$gene_attr
  gene_stats$HVG <- ifelse(rownames(gene_stats) %in% hvgs, "HVG", "Not HVG")

  p_hvg <- ggplot(gene_stats, aes(x = log10(amean + 1e-5), y = residual_variance, color = HVG)) +
    geom_point(alpha = 0.5, size = 0.6) +
    scale_color_manual(values = c("HVG" = "red", "Not HVG" = "gray70")) +
    theme_minimal() +
    xlab("log10(Mean Expression + ε)") +
    ylab("Residual Variance") +
    ggtitle("Highly Variable Gene (HVG) Selection")
  print(p_hvg)

  # 9. Show top HVGs
  top_hvgs <- gene_stats[order(-gene_stats$residual_variance), ]
  top_table <- head(top_hvgs[, c("amean", "variance", "residual_variance", "HVG")], 10)
  cat("<p><strong>Top HVGs by Residual Variance:</strong></p>")
  cat(kable(top_table, format = "html", table.attr = "class='table table-bordered table-condensed'"))

  cat('</details>\n\n')
}

cat('</details>\n')




cat("<strong>Summary of normalized_list contents:</strong>\n\n")

summary_df <- data.frame(
  Tissue = character(),
  Num_Barcodes = numeric(),
  Num_Genes = numeric(),
  Assays = character(),
  Reductions = character(),
  stringsAsFactors = FALSE
)

for (tissue in names(normalized_list)) {
  obj <- normalized_list[[tissue]]
  
  summary_df <- rbind(summary_df, data.frame(
    Tissue = tissue,
    Num_Barcodes = ncol(obj),
    Num_Genes = nrow(obj),
    Assays = paste(names(obj@assays), collapse = ", "),
    Reductions = paste(names(obj@reductions), collapse = ", "),
    stringsAsFactors = FALSE
  ))
}

# Render the summary_df as a collapsible HTML table
cat("<details><summary><strong>Summary of normalized_list Contents</strong></summary>\n\n")
cat(kable(
  summary_df,
  format = "html",
  table.attr = "class='table table-striped table-bordered'",
  caption = "Overview of barcodes, genes, assays, and reductions per tissue"
))
cat("\n</details>\n\n")


cat("<details><summary><strong>🧪 Assays Available After Normalization</strong></summary>\n\n")

for (t in names(normalized_list)) {
  cat(sprintf("<p><strong>%s</strong>: %s</p>\n",
              t,
              paste(names(Assays(normalized_list[[t]])), collapse = ", ")))
}
cat("</details>\n\n")



```



# 6. Downstream Analyses of all tissue data combined

```{r CombinedTissues_SCT, echo=TRUE, results='asis', message=FALSE, warning=FALSE}


library(Seurat)
library(ggplot2)
library(patchwork)
library(knitr)       # For kable()
library(cluster)     # For silhouette()
library(vegan)       # For adonis2()


for (t in names(normalized_list)) {
  cat(paste0("Tissue: ", t, " - Assays: ", paste0(names(Assays(normalized_list[[t]])), collapse = ", "), "\n"))
}



# ✅ Check basic structure of SCT assays before integration
cat("<details><summary><strong>📋 SCT Assay Diagnostics Before Integration</strong></summary>\n\n")

sct_summary <- do.call(rbind, lapply(names(normalized_list), function(t) {
  obj <- normalized_list[[t]]
  DefaultAssay(obj) <- "SCT"
  assay_data <- GetAssayData(obj, slot = "data")
  
  data.frame(
    Tissue = t,
    Barcodess = ncol(assay_data),
    Genes = nrow(assay_data),
    stringsAsFactors = FALSE
  )
}))

cat("<p><strong>Dimensions of SCT assays:</strong></p>\n")
cat(kable(sct_summary, format = "html", table.attr = "class='table table-striped table-bordered'"))
cat("\n\n</details>\n\n")


# 1) Quick check: assays available
for (t in names(normalized_list)) {
  cat(sprintf("\nTissue: %s\n", t))
  print(names(Assays(normalized_list[[t]])))
}

# 2) Add Tissue label
for (t in names(normalized_list)) {
  normalized_list[[t]]$Tissue <- t
}

# 3) Force DefaultAssay to SCT (already created!)
for (t in names(normalized_list)) {
  if (!"SCT" %in% names(normalized_list[[t]]@assays)) {
    stop(paste0("❌ No SCT assay found in ", t))
  }
  DefaultAssay(normalized_list[[t]]) <- "SCT"
}


# 4) Select integration features
features <- SelectIntegrationFeatures(object.list = normalized_list, nfeatures = 3000)

# 5) Prep for SCT integration
normalized_list <- PrepSCTIntegration(object.list = normalized_list, anchor.features = features)

# 6) Find integration anchors
anchors <- FindIntegrationAnchors(object.list = normalized_list, normalization.method = "SCT", anchor.features = features)

# 7) Integrate
merged_all_tissues <- IntegrateData(anchorset = anchors, normalization.method = "SCT")

# 8) ⚡ From here, switch DefaultAssay to "integrated"
DefaultAssay(merged_all_tissues) <- "integrated"

# 9) Run downstream analysis
merged_all_tissues <- RunPCA(merged_all_tissues, verbose = FALSE)
merged_all_tissues <- RunUMAP(merged_all_tissues, dims = 1:20, verbose = FALSE)


umap_coords <- Embeddings(merged_all_tissues, "umap")

# Identify outlier barcodes
outlier_cells <- rownames(umap_coords)[
  umap_coords[, "umap_2"] > 15 |
  umap_coords[, "umap_2"] < -18 |
  umap_coords[, "umap_1"] > 11 |
  umap_coords[, "umap_1"] < -10
]

# Subset object to remove outliers
merged_all_tissues <- subset(merged_all_tissues, cells = setdiff(Cells(merged_all_tissues), outlier_cells))

# 🚀 Re-run cleaned downstream analysis
merged_all_tissues <- RunPCA(merged_all_tissues, verbose = FALSE)
merged_all_tissues <- FindNeighbors(merged_all_tissues, dims = 1:20, verbose = FALSE)
merged_all_tissues <- FindClusters(merged_all_tissues, resolution = 0.5, verbose = FALSE)
merged_all_tissues <- RunUMAP(merged_all_tissues, dims = 1:20, verbose = FALSE)


# 👇 INSERT SECOND ROUND OF FILTERING HERE
umap_coords <- Embeddings(merged_all_tissues, reduction = "umap")
outlier_cells_2 <- rownames(umap_coords)[umap_coords[, "umap_1"] > 12]
merged_all_tissues <- subset(merged_all_tissues, cells = setdiff(Cells(merged_all_tissues), outlier_cells_2))
merged_all_tissues <- RunPCA(merged_all_tissues, verbose = FALSE)
merged_all_tissues <- FindNeighbors(merged_all_tissues, dims = 1:20, verbose = FALSE)
merged_all_tissues <- FindClusters(merged_all_tissues, resolution = 0.5, verbose = FALSE)
merged_all_tissues <- RunUMAP(merged_all_tissues, dims = 1:20, verbose = FALSE)


# 10) Plot UMAPs
p_tissue <- DimPlot(merged_all_tissues, reduction = "umap", group.by = "Tissue") +
  ggtitle("UMAP Colored by Tissue")
print(p_tissue)

for (meta in c("Batch", "Age", "Sex", "Injury")) {
  if (meta %in% colnames(merged_all_tissues@meta.data)) {
    p_meta <- DimPlot(merged_all_tissues, reduction = "umap", group.by = meta) +
      ggtitle(paste("UMAP Colored by", meta))
    print(p_meta)
  }
}

# 11) 📊 Full statistics
cat('<details><summary><strong>📊 Summary Statistics After Merging Tissues</strong></summary>\n\n')

# 11.1 Cluster composition
cat("<p><strong>Cluster composition by Tissue:</strong></p>\n")
cluster_table <- table(merged_all_tissues$Tissue, Idents(merged_all_tissues))
cat(kable(cluster_table, format = "html", table.attr = "class='table table-bordered table-condensed'"))
cat("\n<br>\n")

# 11.2 Barcode counts per tissue
cat("<p><strong>Barcode counts per Tissue:</strong></p>\n")
cell_counts <- table(merged_all_tissues$Tissue)
cat(kable(as.data.frame(cell_counts), format = "html", table.attr = "class='table table-bordered table-condensed'"))
cat("\n<br>\n")

# 11.3 UMAP coordinate summaries
cat("<p><strong>UMAP coordinate means by Tissue:</strong></p>\n")
umap_coords <- Embeddings(merged_all_tissues, reduction = "umap")
umap_summary <- aggregate(umap_coords, by = list(Tissue = merged_all_tissues$Tissue), FUN = mean)
cat(kable(umap_summary, format = "html", table.attr = "class='table table-bordered table-condensed'"))
cat("\n<br>\n")

# 11.4 PCA Variance explained
cat("<p><strong>Variance explained by first 10 PCs:</strong></p>\n")
stdev <- merged_all_tissues@reductions$pca@stdev
var_explained <- (stdev^2) / sum(stdev^2)
var_explained_df <- data.frame(
  PC = paste0("PC", seq_along(var_explained)),
  Variance_Explained = var_explained
)
cat(kable(head(var_explained_df, 10), format = "html", table.attr = "class='table table-bordered table-condensed'"))
cat("\n<br>\n")

# 11.5 Silhouette score
cat("<p><strong>Silhouette Summary:</strong></p>\n")
if (nrow(umap_coords) > 1000) {
  set.seed(123)
  sampled_cells <- sample(rownames(umap_coords), 1000)
  umap_coords_sub <- umap_coords[sampled_cells, ]
  clusters_sub <- Idents(merged_all_tissues)[sampled_cells]
} else {
  umap_coords_sub <- umap_coords
  clusters_sub <- Idents(merged_all_tissues)
}
dists <- dist(umap_coords_sub)
sil <- silhouette(as.integer(clusters_sub), dists)
sil_summary <- summary(sil)
cat("<p><strong>Mean Silhouette Width:</strong> ", round(sil_summary$avg.width, 3), "</p>\n")
cat("<p><strong>Cluster Silhouette Widths:</strong></p>\n")
sil_df <- data.frame(
  Cluster = names(sil_summary$clus.avg.widths),
  Avg_Silhouette_Width = as.numeric(sil_summary$clus.avg.widths)
)
cat(kable(sil_df, format = "html", table.attr = "class='table table-bordered table-condensed'"))
cat("\n<br>\n")

# 11.6 PERMANOVA
cat("<p><strong>PERMANOVA (Tissue differences in UMAP space):</strong></p>\n")
if (nrow(umap_coords) > 1000) {
  set.seed(123)
  sampled_cells <- sample(rownames(umap_coords), 1000)
  umap_coords_sub <- umap_coords[sampled_cells, ]
  tissues_sub <- merged_all_tissues$Tissue[sampled_cells]
} else {
  umap_coords_sub <- umap_coords
  tissues_sub <- merged_all_tissues$Tissue
}
perm_result <- adonis2(umap_coords_sub ~ tissues_sub, permutations = 999, method = "euclidean")
perm_result_df <- as.data.frame(perm_result)
cat(kable(perm_result_df, format = "html", table.attr = "class='table table-bordered table-condensed'"))
cat('\n</details>\n\n')



```


```{r DownstreamAnalyses_MergedAllTissues, echo=TRUE, results='asis', message=FALSE, warning=FALSE}

library(Seurat)
library(ggplot2)
library(dplyr)
library(knitr)
library(EnhancedVolcano)

merged_results <- list()

cat("<details><summary><strong>🧬 DE Analysis for All Merged Tissues</strong></summary>\n\n")

DefaultAssay(merged_all_tissues) <- "integrated"

# Ensure PCA/UMAP/Clusters are available
if (!"pca" %in% names(merged_all_tissues@reductions)) merged_all_tissues <- RunPCA(merged_all_tissues, verbose = FALSE)
if (length(merged_all_tissues@graphs) == 0) {
  merged_all_tissues <- FindNeighbors(merged_all_tissues, dims = 1:20, verbose = FALSE)
  merged_all_tissues <- FindClusters(merged_all_tissues, resolution = 0.5, verbose = FALSE)
}
if (!"umap" %in% names(merged_all_tissues@reductions)) merged_all_tissues <- RunUMAP(merged_all_tissues, dims = 1:20, verbose = FALSE)

# Variables to analyze
group_vars <- c("seurat_clusters", "Tissue", "Batch", "Age", "Sex", "Injury")

get_top_markers <- function(df, n = 3) {
  up   <- df %>% filter(avg_log2FC > 0) %>% group_by(cluster) %>% top_n(n, avg_log2FC)
  down <- df %>% filter(avg_log2FC < 0) %>% group_by(cluster) %>% top_n(n, -avg_log2FC)
  bind_rows(up, down)
}

for (group_var in group_vars) {
  if (!group_var %in% colnames(merged_all_tissues@meta.data)) next

  Idents(merged_all_tissues) <- merged_all_tissues[[group_var]][,1]
  levels_here <- unique(Idents(merged_all_tissues))

  if (length(levels_here) < 2) {
    cat(sprintf("<p><em>⚠️ %s has fewer than 2 levels, skipping.</em></p>\n", group_var))
    next
  }

  cat(sprintf("<details><summary><strong>DE by %s</strong></summary>\n\n", group_var))

  markers <- FindAllMarkers(
    merged_all_tissues,
    assay = "integrated",
    group.by = group_var,
    test.use = "wilcox",
    only.pos = FALSE,
    min.pct = 0.01,
    logfc.threshold = 0
  ) %>% mutate(gene = rownames(.), group_var = group_var)

  merged_results[[group_var]] <- list(markers = markers)

  top_markers <- get_top_markers(markers)
  top_genes <- unique(top_markers$gene)
  top_genes <- top_genes[top_genes %in% rownames(merged_all_tissues)]

  # Scale for plotting if needed (use original SCT assay for this)
  DefaultAssay(merged_all_tissues) <- "SCT"
  if (length(top_genes) > 0) {
    merged_all_tissues <- ScaleData(merged_all_tissues, features = top_genes, verbose = FALSE)
  }

  # DotPlot
  print(DotPlot(merged_all_tissues, features = top_genes) +
          RotatedAxis() +
          ggtitle(paste("DotPlot -", group_var)) +
          theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 6),
                axis.text.y = element_text(size = 6)))

  # Heatmap
  if (length(top_genes) > 0) {
    print(DoHeatmap(merged_all_tissues, features = top_genes, size = 3) +
            ggtitle(paste("Heatmap -", group_var)) +
            theme(axis.text.x = element_blank(),
                  axis.ticks.x = element_blank(),
                  axis.text.y = element_text(size = 6)))
  } else {
    cat("<p><em>No genes available for heatmap.</em></p>\n")
  }

  # Volcano plot for most abundant level
  most_common <- names(sort(table(Idents(merged_all_tissues)), decreasing = TRUE))[1]
  cluster_df <- markers %>% filter(cluster == most_common)

  if (nrow(cluster_df) > 0) {
    top_genes_df <- bind_rows(
      cluster_df %>% filter(avg_log2FC > 0) %>% arrange(p_val_adj, desc(avg_log2FC)) %>% head(10),
      cluster_df %>% filter(avg_log2FC < 0) %>% arrange(p_val_adj, avg_log2FC) %>% head(10)
    )

    print(EnhancedVolcano(
      cluster_df,
      lab = cluster_df$gene,
      selectLab = top_genes_df$gene,
      x = 'avg_log2FC',
      y = 'p_val_adj',
      title = paste("Merged -", group_var, "-", most_common, "Volcano"),
      pCutoff = 0.05,
      FCcutoff = 0.5,
      pointSize = 2.0,
      labSize = 3.0
    ))

    cat(sprintf("<p><strong>Top 20 DE genes (%s = %s):</strong></p>", group_var, most_common))
    cat(kable(top_genes_df, format = "html", table.attr = "class='table table-bordered table-condensed'"))
  }

  cluster_table <- get_top_markers(markers)
  cat("<p><strong>Top Up/Down Markers per Group Level:</strong></p>")
  cat(kable(cluster_table, format = "html", table.attr = "class='table table-bordered table-condensed'"))

  cat("</details>\n\n")

  # Reset to integrated for next group
  DefaultAssay(merged_all_tissues) <- "integrated"
}

cat("</details>\n")

```








```{r CombinedTissues_SCT_byMetadata, echo=TRUE, results='asis', message=FALSE, warning=FALSE}

# Step 1: Subset by Metadata Groups

# Subset by Age
young_cells <- WhichCells(merged_all_tissues, expression = Age == 0)
aged_cells  <- WhichCells(merged_all_tissues, expression = Age == 1)

merged_young <- subset(merged_all_tissues, cells = young_cells)
merged_aged  <- subset(merged_all_tissues, cells = aged_cells)

# Subset by Sex
male_cells   <- WhichCells(merged_all_tissues, expression = Sex == 0)
female_cells <- WhichCells(merged_all_tissues, expression = Sex == 1)

merged_male <- subset(merged_all_tissues, cells = male_cells)

if (length(female_cells) > 0) {
  merged_female <- subset(merged_all_tissues, cells = female_cells)
} else {
  message("⚠️ No female cells found yet — skipping female subset.")
}

# Subset by Injury groups (0 = Naive, 2 = Sham, 3 = DMM)
naive_cells <- WhichCells(merged_all_tissues, expression = Injury == 0)
sham_cells  <- WhichCells(merged_all_tissues, expression = Injury == 2)
dmm_cells   <- WhichCells(merged_all_tissues, expression = Injury == 3)

merged_naive <- subset(merged_all_tissues, cells = naive_cells)
merged_sham  <- subset(merged_all_tissues, cells = sham_cells)
merged_dmm   <- subset(merged_all_tissues, cells = dmm_cells)

# Step 2: Create a function to repeat downstream analysis + DE

run_analysis_summary <- function(seurat_obj, title_prefix = "Subset") {
  library(Seurat)
  library(ggplot2)
  library(patchwork)
  library(cluster)
  library(vegan)
  library(knitr)
  library(dplyr)
  library(EnhancedVolcano)

  DefaultAssay(seurat_obj) <- "integrated"

  seurat_obj <- RunPCA(seurat_obj, verbose = FALSE)
  seurat_obj <- FindNeighbors(seurat_obj, dims = 1:20, verbose = FALSE)
  seurat_obj <- FindClusters(seurat_obj, resolution = 0.5, verbose = FALSE)
  seurat_obj <- RunUMAP(seurat_obj, dims = 1:20, verbose = FALSE)

  umap_coords <- Embeddings(seurat_obj, reduction = "umap")

  cat(sprintf("<details><summary><strong>📊 %s: UMAP + Statistics</strong></summary>\n\n", title_prefix))

  print(DimPlot(seurat_obj, reduction = "umap", group.by = "Tissue") + ggtitle(paste(title_prefix, "- by Tissue")))

  for (meta in c("Batch", "Age", "Sex", "Injury")) {
    if (meta %in% colnames(seurat_obj@meta.data)) {
      print(DimPlot(seurat_obj, reduction = "umap", group.by = meta) + ggtitle(paste(title_prefix, "- by", meta)))
    }
  }

  cat("<p><strong>Cluster composition by Tissue:</strong></p>\n")
  cluster_table <- table(seurat_obj$Tissue, Idents(seurat_obj))
  cat(kable(cluster_table, format = "html", table.attr = "class='table table-bordered table-condensed'"))

  cat("<p><strong>Cell counts per Tissue:</strong></p>\n")
  cell_counts <- table(seurat_obj$Tissue)
  cat(kable(as.data.frame(cell_counts), format = "html", table.attr = "class='table table-bordered table-condensed'"))

  cat("<p><strong>UMAP coordinate means by Tissue:</strong></p>\n")
  umap_summary <- aggregate(umap_coords, by = list(Tissue = seurat_obj$Tissue), FUN = mean)
  cat(kable(umap_summary, format = "html", table.attr = "class='table table-bordered table-condensed'"))

  cat("<p><strong>Variance explained by first 10 PCs:</strong></p>\n")
  stdev <- seurat_obj@reductions$pca@stdev
  var_explained <- (stdev^2) / sum(stdev^2)
  var_explained_df <- data.frame(
    PC = paste0("PC", seq_along(var_explained)),
    Variance_Explained = var_explained
  )
  cat(kable(head(var_explained_df, 10), format = "html", table.attr = "class='table table-bordered table-condensed'"))

  cat("<p><strong>Silhouette Summary:</strong></p>\n")
  if (nrow(umap_coords) > 1000) {
    set.seed(123)
    sampled_cells <- sample(rownames(umap_coords), 1000)
    umap_coords_sub <- umap_coords[sampled_cells, ]
    clusters_sub <- Idents(seurat_obj)[sampled_cells]
  } else {
    umap_coords_sub <- umap_coords
    clusters_sub <- Idents(seurat_obj)
  }
  dists <- dist(umap_coords_sub)
  sil <- silhouette(as.integer(clusters_sub), dists)
  sil_summary <- summary(sil)
  cat("<p><strong>Mean Silhouette Width:</strong> ", round(sil_summary$avg.width, 3), "</p>\n")
  sil_df <- data.frame(
    Cluster = names(sil_summary$clus.avg.widths),
    Avg_Silhouette_Width = as.numeric(sil_summary$clus.avg.widths)
  )
  cat(kable(sil_df, format = "html", table.attr = "class='table table-bordered table-condensed'"))

  cat("<p><strong>PERMANOVA (Tissue differences in UMAP space):</strong></p>\n")
  if (nrow(umap_coords) > 1000) {
    set.seed(123)
    sampled_cells <- sample(rownames(umap_coords), 1000)
    umap_coords_sub <- umap_coords[sampled_cells, ]
    tissues_sub <- seurat_obj$Tissue[sampled_cells]
  } else {
    umap_coords_sub <- umap_coords
    tissues_sub <- seurat_obj$Tissue
  }
  perm_result <- adonis2(umap_coords_sub ~ tissues_sub, permutations = 999, method = "euclidean")
  cat(kable(as.data.frame(perm_result), format = "html", table.attr = "class='table table-bordered table-condensed'"))

  # ===================
  # DE Analysis
  # ===================
  group_vars <- c("seurat_clusters", "Tissue")

  get_top_markers <- function(df, n = 3) {
    up   <- df %>% filter(avg_log2FC > 0) %>% group_by(cluster) %>% top_n(n, avg_log2FC)
    down <- df %>% filter(avg_log2FC < 0) %>% group_by(cluster) %>% top_n(n, -avg_log2FC)
    bind_rows(up, down)
  }

  for (group_var in group_vars) {
    if (!group_var %in% colnames(seurat_obj@meta.data)) next

    Idents(seurat_obj) <- seurat_obj[[group_var]][,1]
    levels_here <- unique(Idents(seurat_obj))
    if (length(levels_here) < 2) next

    cat(sprintf("<details><summary><strong>DE by %s</strong></summary>\n\n", group_var))

    markers <- FindAllMarkers(
      seurat_obj,
      assay = "integrated",
      group.by = group_var,
      test.use = "wilcox",
      only.pos = FALSE,
      min.pct = 0.01,
      logfc.threshold = 0
    ) %>% mutate(gene = rownames(.), group_var = group_var)

    top_markers <- get_top_markers(markers)
    top_genes <- unique(top_markers$gene)
    top_genes <- top_genes[top_genes %in% rownames(seurat_obj)]

    DefaultAssay(seurat_obj) <- "SCT"
    if (length(top_genes) > 0) {
      seurat_obj <- ScaleData(seurat_obj, features = top_genes, verbose = FALSE)
    }

    print(DotPlot(seurat_obj, features = top_genes) +
            RotatedAxis() +
            ggtitle(paste("DotPlot -", group_var)) +
            theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 6),
                  axis.text.y = element_text(size = 6)))

    print(DoHeatmap(seurat_obj, features = top_genes, size = 3) +
            ggtitle(paste("Heatmap -", group_var)) +
            theme(axis.text.x = element_blank(),
                  axis.ticks.x = element_blank(),
                  axis.text.y = element_text(size = 6)))

    most_common <- names(sort(table(Idents(seurat_obj)), decreasing = TRUE))[1]
    cluster_df <- markers %>% filter(cluster == most_common)

    if (nrow(cluster_df) > 0) {
      top_genes_df <- bind_rows(
        cluster_df %>% filter(avg_log2FC > 0) %>% arrange(p_val_adj, desc(avg_log2FC)) %>% head(10),
        cluster_df %>% filter(avg_log2FC < 0) %>% arrange(p_val_adj, avg_log2FC) %>% head(10)
      )

      print(EnhancedVolcano(
        cluster_df,
        lab = cluster_df$gene,
        selectLab = top_genes_df$gene,
        x = 'avg_log2FC',
        y = 'p_val_adj',
        title = paste(title_prefix, "-", group_var, "-", most_common, "Volcano"),
        pCutoff = 0.05,
        FCcutoff = 0.5,
        pointSize = 2.0,
        labSize = 3.0
      ))

      cat(sprintf("<p><strong>Top 20 DE genes (%s = %s):</strong></p>", group_var, most_common))
      cat(kable(top_genes_df, format = "html", table.attr = "class='table table-bordered table-condensed'"))
    }

    cat("</details>\n\n")
  }

  cat("</details>\n\n")
}

# Step 3: Run for all Subsets

cat('<details><summary><strong>📊 Analyses by Age, Injury, and Sex</strong></summary>\n\n')

# Age
run_analysis_summary(merged_young, "Age: Young")
run_analysis_summary(merged_aged,  "Age: Aged")

# Sex
if (exists("merged_female")) {
  run_analysis_summary(merged_female, "Sex: Female")
} else {
  message("⚠️ Skipping analysis for Sex: Female — no cells available.")
}
run_analysis_summary(merged_male,   "Sex: Male")

# Injury
run_analysis_summary(merged_naive, "Injury: Naive (0)")
run_analysis_summary(merged_sham,  "Injury: Sham (2)")
run_analysis_summary(merged_dmm,   "Injury: DMM (3)")

cat('</details>\n\n')




```



# 7. Downstream Analyses: Cluster-Level Marker Discovery (Unadjusted)

```{r DownstreamAnalyses_SCT, echo=TRUE, results='asis', message=FALSE, warning=FALSE}


# This section performs cluster-level DE (FindAllMarkers by seurat_clusters).
# It is NOT adjusted for metadata (Age, Injury, Batch) and is NOT filtered by Sex.
# Use for understanding cluster identities, not metadata-driven DE.


library(Seurat)
library(ggplot2)
library(knitr)
library(patchwork)
library(dplyr)
library(EnhancedVolcano)
library(cluster)  # for silhouette if needed

results_list <- list()

cat("<details><summary><strong>DE Analysis per Tissue</strong></summary>\n\n")

# Define the function for one tissue
analyze_tissue <- function(tissue_name) {
  
  cat(sprintf("<details><summary><strong>%s</strong></summary>\n\n", tissue_name))
  
  if (!tissue_name %in% names(normalized_list)) {
    cat("<p><em>❌ Tissue not found in normalized_list.</em></p>\n")
    cat("</details>\n\n")
    return(NULL)
  }

  obj <- normalized_list[[tissue_name]]  # ✅ Already SCT-normalized
  DefaultAssay(obj) <- "SCT"

  # Defensive: skip if too few cells
  if (ncol(obj) < 50) {
    cat("<p><em>⚠️ Not enough cells for clustering.</em></p>\n")
    cat("</details>\n\n")
    return(NULL)
  }

  # Preprocessing (only if needed)
  if (!"pca" %in% names(obj@reductions)) {
    obj <- RunPCA(obj, verbose = FALSE)
  }
  if (length(obj@graphs) == 0) {
    obj <- FindNeighbors(obj, dims = 1:20, verbose = FALSE)
    obj <- FindClusters(obj, resolution = 0.5, verbose = FALSE)
  }
  if (!"umap" %in% names(obj@reductions)) {
    obj <- RunUMAP(obj, dims = 1:20, verbose = FALSE)
  }

  # Find markers (DE genes)
  markers <- FindAllMarkers(
    obj,
    assay = "SCT",
    group.by = "seurat_clusters",
    test.use = "wilcox",
    only.pos = FALSE,
    min.pct = 0.01,
    logfc.threshold = 0
  ) %>% mutate(gene = rownames(.))

  results_list[[tissue_name]] <<- list(seurat = obj, markers = markers)

  # UMAP by cluster
  print(
    DimPlot(obj, reduction = "umap", group.by = "seurat_clusters", pt.size = 0.5) +
      ggtitle(paste0(tissue_name, " - UMAP by Cluster")) +
      theme(axis.text = element_text(size = 8), axis.title = element_text(size = 10))
  )

  # UMAPs by metadata
  for (meta_var in c("Batch", "Age", "Sex", "Injury")) {
    if (meta_var %in% colnames(obj@meta.data)) {
      print(
        DimPlot(obj, reduction = "umap", group.by = meta_var, pt.size = 0.5) +
          ggtitle(paste0(tissue_name, " - UMAP by ", meta_var)) +
          theme(axis.text = element_text(size = 8), axis.title = element_text(size = 10))
      )
    }
  }

  if (nrow(markers) > 0) {
    top_markers <- markers %>% group_by(cluster) %>% top_n(3, avg_log2FC)

    print(
      DotPlot(obj, features = unique(top_markers$gene)) +
        RotatedAxis() +
        theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 6),
              axis.text.y = element_text(size = 6),
              axis.title = element_text(size = 10),
              legend.title = element_text(size = 9),
              legend.text = element_text(size = 8))
    )

    print(
      DoHeatmap(obj, features = unique(top_markers$gene), size = 3) +
        ggtitle("Top Markers Heatmap") +
        theme(axis.text.x = element_blank(),
              axis.ticks.x = element_blank(),
              axis.text.y = element_text(size = 6),
              plot.title = element_text(size = 10))
    )

    # Volcano plot for the most abundant cluster (or cluster 0 if available)
    cluster_to_plot <- if (0 %in% unique(markers$cluster)) 0 else {
      cluster_counts <- table(Idents(obj))
      as.integer(names(which.max(cluster_counts)))
    }

    cluster_df <- markers %>% filter(cluster == cluster_to_plot)

    if (nrow(cluster_df) > 0) {
      volcano_data <- cluster_df
      top_genes_df <- volcano_data %>% arrange(p_val_adj, desc(abs(avg_log2FC))) %>%
        head(20) %>% select(gene, avg_log2FC, p_val_adj)

      print(
        EnhancedVolcano(volcano_data,
                        lab = volcano_data$gene,
                        selectLab = top_genes_df$gene,
                        x = 'avg_log2FC',
                        y = 'p_val_adj',
                        title = paste(tissue_name, "Cluster", cluster_to_plot, "Marker Volcano"),
                        pCutoff = 0.05,
                        FCcutoff = 0.5,
                        pointSize = 2.0,
                        labSize = 3.0)
      )

      cat(sprintf("<p><strong>Top 20 DE genes (Cluster %s):</strong></p>", cluster_to_plot))
      cat(kable(top_genes_df, format = "html", table.attr = "class='table table-bordered table-condensed'"))
    }

    cluster_table <- markers %>% group_by(cluster) %>% top_n(3, avg_log2FC)
    cat("<p><strong>Top Markers per Cluster:</strong></p>")
    cat(kable(cluster_table, format = "html", table.attr = "class='table table-bordered table-condensed'"))

  } else {
    cat("<p><em>No DE markers found for this tissue.</em></p>")
  }

  cat("</details>\n\n")
}

# Run per-tissue analysis
tissues_to_run <- c(
  "CartilageFemur",
  "CartilageTibia",
  "SubchondralFemur",
  "SubchondralTibia",
  "Synovium",
  "IPFP",
  "Meniscus", 
  "BoneMarrowFemur", 
  "BoneMarrowTibia", 
  "GrowthPlateTibia", 
  "GrowthPlateFemur"
)

# Defensive filtering in case some names are missing
tissues_to_run <- intersect(tissues_to_run, names(normalized_list))

lapply(tissues_to_run, analyze_tissue)

cat("</details>\n")



```



# 8. Downstream DE Analyses (Males Only, Adjusted) Use only for UMAPs done with SCTransformed data, not for DE as Wilcoxon does not allow adjustment of covariates


```{r DownstreamAnalyses_MalesAdjusted, echo=TRUE, results='asis', message=FALSE, warning=FALSE}

library(Seurat)
library(ggplot2)
library(knitr)
library(dplyr)
library(EnhancedVolcano)
library(viridis)
library(patchwork)

results_list <- list()

cat("<details><summary><strong>DE Analysis per Tissue (Males Only)</strong></summary>\n\n")

analyze_tissue <- function(tissue_name) {
  cat(sprintf("<details><summary><strong>%s</strong></summary>\n\n", tissue_name))

  if (!tissue_name %in% names(normalized_list)) {
    cat("<p><em>❌ Tissue not found in normalized_list.</em></p>\n</details>\n\n")
    return(NULL)
  }

  obj <- normalized_list[[tissue_name]]
  DefaultAssay(obj) <- "SCT"
  obj <- subset(obj, subset = Sex == 0)

  if (ncol(obj) < 50 || length(unique(obj$Age)) < 2 || length(unique(obj$Injury)) < 2) {
    cat("<p><em>⚠️ Not enough data for DE comparisons (check Age/Injury groups).</em></p>\n</details>\n\n")
    return(NULL)
  }

  if (!"pca" %in% names(obj@reductions)) obj <- RunPCA(obj, verbose = FALSE)
  if (length(obj@graphs) == 0) {
    obj <- FindNeighbors(obj, dims = 1:20, verbose = FALSE)
    obj <- FindClusters(obj, resolution = 0.5, verbose = FALSE)
  }
  if (!"umap" %in% names(obj@reductions)) obj <- RunUMAP(obj, dims = 1:20, verbose = FALSE)

  print(DimPlot(obj, reduction = "umap", group.by = "seurat_clusters") + ggtitle(paste(tissue_name, "UMAP - Clusters")))
  print(DimPlot(obj, reduction = "umap", group.by = "Age") + ggtitle(paste(tissue_name, "UMAP - Age")))
  print(DimPlot(obj, reduction = "umap", group.by = "Injury") + ggtitle(paste(tissue_name, "UMAP - Injury")))
  print(DimPlot(obj, reduction = "pca", group.by = "seurat_clusters") + ggtitle(paste(tissue_name, "PCA - Clusters")))

  # --- Aged vs Young (adjusted) ---
  cat("<details><summary><strong>Aged vs Young (adjusted)</strong></summary>\n\n")

  age_markers <- FindMarkers(
    obj,
    group.by = "Age",
    ident.1 = 1,
    ident.2 = 0,
    assay = "SCT",
    test.use = "wilcox",
    only.pos = FALSE,
    latent.vars = c("Batch", "Injury")
  ) %>% mutate(gene = rownames(.)) %>% filter(p_val_adj < 0.2)

  results_list[[tissue_name]]$Age_DE <<- age_markers

  if (nrow(age_markers) > 0) {
    top_genes <- age_markers %>% arrange(p_val_adj, desc(abs(avg_log2FC))) %>% head(20)

    print(EnhancedVolcano(
      age_markers,
      lab = age_markers$gene,
      selectLab = top_genes$gene,
      x = 'avg_log2FC',
      y = 'p_val_adj',
      title = paste(tissue_name, "Aged vs Young (Adjusted)"),
      pCutoff = 0.2,
      FCcutoff = 0.5,
      pointSize = 2.0,
      labSize = 3.0,
      col = viridis(4)
    ))

    obj <- ScaleData(obj, features = top_genes$gene, verbose = FALSE)

    print(DotPlot(obj, features = top_genes$gene) + RotatedAxis() +
            ggtitle("DotPlot - Age") +
            theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 6),
                  axis.text.y = element_text(size = 6)))

    print(DoHeatmap(obj, features = top_genes$gene, size = 3) +
            ggtitle("Heatmap - Age") +
            theme(axis.text.x = element_blank(),
                  axis.ticks.x = element_blank(),
                  axis.text.y = element_text(size = 6)))

    cat("<p><strong>Top DEGs (Aged vs Young):</strong></p>")
    cat(kable(top_genes, format = "html", table.attr = "class='table table-bordered table-condensed'"))
  } else {
    cat("<p><em>No DEGs found between Aged vs Young.</em></p>")
  }
  cat("</details>\n\n")

  # --- Injury Comparisons ---
  for (injury_pair in list(c(3, 0), c(2, 0))) {
    inj1 <- injury_pair[1]
    inj2 <- injury_pair[2]

    if (all(c(inj1, inj2) %in% unique(obj$Injury))) {
      cat(sprintf("<details><summary><strong>%s vs %s (adjusted)</strong></summary>\n\n", inj1, inj2))

      injury_markers <- FindMarkers(
        obj,
        group.by = "Injury",
        ident.1 = inj1,
        ident.2 = inj2,
        assay = "SCT",
        test.use = "wilcox",
        only.pos = FALSE,
        latent.vars = c("Batch", "Age")
      ) %>% mutate(gene = rownames(.)) %>% filter(p_val_adj < 0.2)

      results_list[[tissue_name]][[paste0(inj1, "_vs_", inj2)]] <<- injury_markers

      if (nrow(injury_markers) > 0) {
        top_genes <- injury_markers %>% arrange(p_val_adj, desc(abs(avg_log2FC))) %>% head(20)

        print(EnhancedVolcano(
          injury_markers,
          lab = injury_markers$gene,
          selectLab = top_genes$gene,
          x = 'avg_log2FC',
          y = 'p_val_adj',
          title = paste(tissue_name, inj1, "vs", inj2, "(Adjusted)"),
          pCutoff = 0.2,
          FCcutoff = 0.5,
          pointSize = 2.0,
          labSize = 3.0,
          col = viridis(4)
        ))

        obj <- ScaleData(obj, features = top_genes$gene, verbose = FALSE)

        print(DotPlot(obj, features = top_genes$gene) + RotatedAxis() +
                ggtitle(paste("DotPlot -", inj1, "vs", inj2)) +
                theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 6),
                      axis.text.y = element_text(size = 6)))

        print(DoHeatmap(obj, features = top_genes$gene, size = 3) +
                ggtitle(paste("Heatmap -", inj1, "vs", inj2)) +
                theme(axis.text.x = element_blank(),
                      axis.ticks.x = element_blank(),
                      axis.text.y = element_text(size = 6)))

        cat(sprintf("<p><strong>Top DEGs (%s vs %s):</strong></p>", inj1, inj2))
        cat(kable(top_genes, format = "html", table.attr = "class='table table-bordered table-condensed'"))
      } else {
        cat(sprintf("<p><em>No DEGs found between %s vs %s.</em></p>", inj1, inj2))
      }
      cat("</details>\n\n")
    }
  }

  cat("</details>\n\n")
}

tissues_to_run <- c(
  "CartilageFemur", "CartilageTibia", "SubchondralFemur", "SubchondralTibia",
  "Synovium", "IPFP", "Meniscus", "BoneMarrowFemur", "BoneMarrowTibia",
  "GrowthPlateTibia", "GrowthPlateFemur"
)
tissues_to_run <- intersect(tissues_to_run, names(normalized_list))
lapply(tissues_to_run, analyze_tissue)

cat("</details>\n")

```




```{r DownstreamAnalyses_MalesAdjustedInjuryDivided, echo=TRUE, results='asis', message=FALSE, warning=FALSE}
suppressPackageStartupMessages({
  library(Seurat)
  library(dplyr)
  library(tibble)
  library(ggplot2)
  library(EnhancedVolcano)
  library(viridis)
  library(knitr)
})

# ---- Config ----
injury_levels <- c(0, 2, 3)
tissues_to_run <- c(
  "CartilageFemur","CartilageTibia","SubchondralFemur","SubchondralTibia",
  "Synovium","IPFP","Meniscus","BoneMarrowFemur","BoneMarrowTibia",
  "GrowthPlateTibia","GrowthPlateFemur"
)
tissues_to_run <- intersect(tissues_to_run, names(normalized_list))

# optional: keep DE results in-memory (not on disk)
store_results <- FALSE
results_list_byinjury <- list()

# ---- Render collapsibles only (no saving) ----
cat("<details open><summary><strong>🧬 DE Analyses by Tissue × Injury (Males only; inline)</strong></summary>\n\n")

for (tissue in tissues_to_run) {
  cat(sprintf("<details><summary><strong>%s</strong></summary>\n\n", tissue))

  for (injury in injury_levels) {
    obj <- normalized_list[[tissue]]
    DefaultAssay(obj) <- "SCT"
    obj <- subset(obj, subset = Sex == 0 & Injury == injury)

    if (is.null(obj) || ncol(obj) < 20 || length(unique(obj$Age)) < 2) {
      cat(sprintf("<p><em>⚠️ Not enough cells in %s — Injury %s</em></p>\n", tissue, injury))
      next
    }

    # identities by Age for DotPlot grouping
    Idents(obj) <- factor(obj$Age, levels = c(0,1), labels = c("Young","Aged"))

    cat(sprintf("<details><summary><strong>Injury = %s: Aged vs Young</strong></summary>\n\n", injury))

    # DEG (Wilcoxon on SCT, adjusted by Batch)
    age_markers <- FindMarkers(
      obj, group.by = "Age", ident.1 = 1, ident.2 = 0,
      assay = "SCT", test.use = "wilcox", only.pos = FALSE,
      latent.vars = c("Batch")
    ) %>%
      as.data.frame() %>%
      tibble::rownames_to_column("gene")

    # show a filtered table (padj < 0.2) inline
    age_markers_flt <- age_markers %>% filter(!is.na(p_val_adj), p_val_adj < 0.2)

    if (store_results) {
      results_list_byinjury[[tissue]][[paste0("Injury_", injury)]] <- age_markers
    }

    if (nrow(age_markers_flt) > 0) {
      top_genes <- age_markers_flt %>%
        arrange(p_val_adj, desc(abs(avg_log2FC))) %>%
        slice_head(n = 20) %>%
        pull(gene)

      # make sure features are present and scaled for heatmap
      feats <- intersect(top_genes, rownames(obj))
      if (length(feats) > 0) {
        suppressWarnings(obj <- ScaleData(obj, features = feats, verbose = FALSE))
      }

      # Volcano
      print(
        EnhancedVolcano(
          age_markers,
          lab       = age_markers$gene,
          selectLab = top_genes,
          x         = "avg_log2FC",
          y         = "p_val_adj",
          title     = paste(tissue, "- Injury", injury, "Aged vs Young"),
          pCutoff   = 0.2, FCcutoff = 0.5, col = viridis(4)
        )
      )

      # DotPlot (grouped by Idents = Age)
      if (length(feats) > 0) {
        print(
          DotPlot(obj, features = feats) + RotatedAxis() +
            ggtitle(paste(tissue, "- Injury", injury, "DotPlot (top DEGs)")) +
            theme(axis.text.x = element_text(angle = 45, hjust = 1))
        )

        # Heatmap (scaled)
        print(
          DoHeatmap(obj, features = feats, size = 3) +
            ggtitle(paste(tissue, "- Injury", injury, "Heatmap (top DEGs)")) +
            theme(axis.text.x = element_blank(), axis.ticks.x = element_blank())
        )
      }

      # Inline DEG table (filtered)
      cat(knitr::kable(
        age_markers_flt %>% arrange(p_val_adj) %>% head(200),
        format = "html",
        table.attr = "class='table table-bordered table-condensed'",
        digits = 3
      ))
    } else {
      cat("<p><em>No DEGs found at current thresholds (p_adj < 0.2).</em></p>\n")
    }

    cat("</details>\n\n")
  }

  cat("</details>\n\n")
}

cat("</details>\n\n")

```






## 8.1 Downstream Analyses (Males Only, Adjusted) for Aging Signature with overlapped PCloadings and DEGs using right stat MAST (RNA) that allows for adjustment of covariates


```{r DownstreamAnalyses_MalesAdjustedusingMAST, echo=TRUE, results='asis', message=FALSE, warning=FALSE}

# ---- Packages ----
suppressPackageStartupMessages({
  library(Seurat)
  library(dplyr)
  library(tibble)
  library(future)
  library(future.apply)
  library(ggplot2)
  library(EnhancedVolcano)
  library(MAST)
})




# ========= Speed tweaks =========
workers <- max(1, parallel::detectCores() - 1)
plan(multisession, workers = workers)
options(future.globals.maxSize = 8 * 1024^3)  # 8 GB; raise if needed

min_pct <- get0("min_pct", ifnotfound = 0.01)
lfc_thr <- get0("lfc_thr", ifnotfound = 0.25)   


# ========= Helper: consistent gene key (optional) =========
clean_gene <- function(x) {
  x <- as.character(x)
  x <- trimws(x)
  x <- sub("\\.\\d+$", "", x)
  x <- gsub("[^A-Za-z0-9]", "", x)
  toupper(x)
}

# ========= 1) PREP: subset to males and LogNormalize RNA ONCE =========
# Input: gene_filtered_list
# Output: male_rna_log_list (male-only; RNA@data is log-normalized)
ensure_rna_log <- function(obj) {
  DefaultAssay(obj) <- "RNA"
  if (nrow(GetAssayData(obj, assay = "RNA", slot = "data")) == 0) {
    obj <- NormalizeData(
      obj, assay = "RNA",
      normalization.method = "LogNormalize",
      scale.factor = 1e4, verbose = FALSE
    )
  }
  obj
}

cat(sprintf("🚀 Using %d workers for parallel prep\n", workers))

prep_fun <- function(tissue) {
  obj <- gene_filtered_list[[tissue]]
  # subset males ASAP (Sex: 1 = Female, 0 = Male per your metadata; adjust if reversed)
  obj <- subset(obj, subset = Sex == 0 & Age %in% c(0,1))
  if (is.null(obj) || ncol(obj) == 0) return(NULL)

  # keep only relevant metadata to shrink objects (optional)
  keep_meta <- intersect(c("Age","Sex","Injury","Batch","nFeature_RNA","nCount_RNA","ID"),
                         colnames(obj@meta.data))
  obj@meta.data <- obj@meta.data[, keep_meta, drop = FALSE]

  # ensure RNA data log-normalized for MAST and RNA plots
  obj <- ensure_rna_log(obj)
  obj
}

tissues_available <- names(gene_filtered_list)
male_rna_log_list <- future_lapply(tissues_available, prep_fun)
names(male_rna_log_list) <- tissues_available
male_rna_log_list <- male_rna_log_list[!vapply(male_rna_log_list, is.null, logical(1))]
cat(sprintf("✅ Prepped %d tissues with male-only RNA LogNormalize\n", length(male_rna_log_list)))

# ========= 2) MAST DE (log-normalized RNA; adjusted covariates) =========
results_list <- list()

tissues_to_run <- intersect(
  c("CartilageFemur","CartilageTibia","SubchondralFemur","SubchondralTibia",
    "Synovium","IPFP","Meniscus","BoneMarrowFemur","BoneMarrowTibia",
    "GrowthPlateTibia","GrowthPlateFemur"),
  names(male_rna_log_list)
)

de_one_tissue <- function(tissue_name) {
  obj <- male_rna_log_list[[tissue_name]]
  if (is.null(obj)) return(NULL)

  # need ≥2 Age and ≥2 Injury groups for adjusted model
  if (ncol(obj) < 50 || length(unique(obj$Age)) < 2 || length(unique(obj$Injury)) < 2) {
    return(list(.note = sprintf("Not enough data in %s (need ≥2 Age & ≥2 Injury groups)", tissue_name)))
  }

  DefaultAssay(obj) <- "RNA"

  covars_age    <- intersect(c("Batch","Injury","nFeature_RNA"), colnames(obj@meta.data))
  covars_injury <- intersect(c("Batch","Age","nFeature_RNA"),    colnames(obj@meta.data))

  # ---- Age DE (Aged=1 vs Young=0) ----
  age_markers <- tryCatch(
    {
      FindMarkers(
        obj,
        group.by    = "Age",
        ident.1     = 1,   # Aged
        ident.2     = 0,   # Young
        assay       = "RNA",
        test.use    = "MAST",
        only.pos    = FALSE,
        latent.vars = covars_age,
        min.pct     = min_pct,
        logfc.threshold = lfc_thr
      ) |>
        as.data.frame() |>
        tibble::rownames_to_column("gene") |>
        mutate(gene_clean = clean_gene(gene))
    },
    error = function(e) {
      warning(sprintf("[Age DE] %s: %s", tissue_name, e$message))
      NULL
    }
  )

  # ---- Injury contrasts (optional) ----
  inj_pairs <- list(c(3,0), c(2,0))
  inj_res <- list()
  for (pair in inj_pairs) {
    inj1 <- pair[1]; inj2 <- pair[2]
    if (!all(c(inj1, inj2) %in% unique(obj$Injury))) next

    res <- tryCatch(
      {
        FindMarkers(
          obj,
          group.by    = "Injury",
          ident.1     = inj1,
          ident.2     = inj2,
          assay       = "RNA",
          test.use    = "MAST",
          only.pos    = FALSE,
          latent.vars = covars_injury,
          min.pct     = min_pct,
          logfc.threshold = lfc_thr
        ) |>
          as.data.frame() |>
          tibble::rownames_to_column("gene") |>
          mutate(gene_clean = clean_gene(gene))
      },
      error = function(e) {
        warning(sprintf("[Injury %s_vs_%s] %s: %s", inj1, inj2, tissue_name, e$message))
        NULL
      }
    )
    inj_res[[paste0(inj1, "_vs_", inj2)]] <- res
  }

  out <- list()
  out$Age_DE <- age_markers
  out[names(inj_res)] <- inj_res
  out
}

cat(sprintf("🧪 Running MAST DE for %d tissues in parallel…\n", length(tissues_to_run)))
de_out <- future_lapply(tissues_to_run, de_one_tissue)
names(de_out) <- tissues_to_run

for (t in names(de_out)) if (!is.null(de_out[[t]])) results_list[[t]] <- de_out[[t]]
cat("✅ MAST DE complete. Objects stored in results_list[[tissue]].\n")

# ========= 3) Collapsible plots per tissue (Volcano + DotPlot + Heatmap on RNA; males only) =========
# thresholds (use existing if defined)
padj_max <- get0("padj_max", ifnotfound = 0.20)
l2fc_min <- get0("l2fc_min", ifnotfound = 0.50)

all_tbl_sig <- list()

topN <- 20
pCutoff <- 0.2
FCCutoff <- 0.5

cat("<details open><summary><strong>📊 Plots per Tissue (Aged vs Young, MAST on RNA; males only)</strong></summary>\n\n")

for (t in names(results_list)) {
  de_table <- results_list[[t]]$Age_DE
  cat(sprintf("<details><summary><strong>%s</strong></summary>\n\n", t))

  if (!is.null(de_table) && nrow(de_table) > 0) {
    de_table <- as.data.frame(de_table)
    # ensure columns exist
    if (!"gene" %in% colnames(de_table)) {
      de_table$gene <- rownames(de_table)
      de_table <- de_table[, c("gene", setdiff(colnames(de_table), "gene"))]
    }
    if (!"p_val_adj" %in% colnames(de_table) && "p_val" %in% colnames(de_table)) {
      de_table$p_val_adj <- p.adjust(de_table$p_val, method = "BH")
    }

    # top genes by adj p then |logFC|
    top_genes <- de_table |>
      dplyr::arrange(p_val_adj, dplyr::desc(abs(avg_log2FC))) |>
      dplyr::slice_head(n = topN) |>
      dplyr::pull(gene)

    # Volcano
    print(
      EnhancedVolcano(
        de_table,
        lab       = de_table$gene,
        selectLab = top_genes,
        x         = "avg_log2FC",
        y         = "p_val_adj",
        title     = paste(t, "Aged vs Young (MAST; RNA; males only)"),
        pCutoff   = pCutoff,
        FCcutoff  = FCCutoff,
        pointSize = 2.0,
        labSize   = 3.0
      )
    )

    # ----- RNA-based viz on the SAME male-only cells -----
    if (t %in% names(male_rna_log_list)) {
      obj_viz <- male_rna_log_list[[t]]
      obj_viz <- subset(obj_viz, subset = Sex == 0 & Age %in% c(0,1))
      Idents(obj_viz) <- factor(obj_viz$Age, levels = c(0,1), labels = c("Young","Aged"))

      features_use <- intersect(top_genes, rownames(obj_viz))
      if (length(features_use) > 0) {
        DefaultAssay(obj_viz) <- "RNA"
        suppressWarnings(obj_viz <- ScaleData(obj_viz, features = features_use, verbose = FALSE))

        print(
          DotPlot(obj_viz, features = features_use, group.by = NULL) + RotatedAxis() +
            ggtitle(paste(t, "- DotPlot (RNA; males only; grouped by Age)")) +
            theme(axis.text.x = element_text(angle = 45, hjust = 1))
        )

        print(
          DoHeatmap(obj_viz, features = features_use, size = 3) +
            ggtitle(paste(t, "- Heatmap (scaled RNA; males only; columns by Age)")) +
            theme(axis.text.x = element_blank(), axis.ticks.x = element_blank())
        )
      } else {
        cat("<p><em>No top genes present in this object—skipping DotPlot/Heatmap.</em></p>\n")
      }
    } else {
      cat("<p><em>Tissue not found in male_rna_log_list; skipping RNA DotPlot/Heatmap.</em></p>\n")
    }

    # ---- Per-tissue DEG table (filtered) ----
    tbl_sig <- de_table |>
      dplyr::filter(!is.na(p_val_adj),
                    p_val_adj <= padj_max,
                    abs(avg_log2FC) >= l2fc_min) |>
      dplyr::mutate(
        Tissue    = t,
        Direction = ifelse(avg_log2FC > 0, "Up_in_Aged", "Down_in_Aged")
      ) |>
      dplyr::select(Tissue, gene, avg_log2FC, p_val, p_val_adj,
                    dplyr::any_of(c("pct.1","pct.2")), Direction)

    if (nrow(tbl_sig) > 0) {
      all_tbl_sig[[t]] <- tbl_sig
      cat("<details><summary><strong>View DEG table (filtered)</strong></summary>\n\n")
      cat(knitr::kable(
        head(tbl_sig, 200),
        format = "html",
        table.attr = "class='table table-striped table-bordered'",
        digits = 3
      ))
      cat("\n</details>\n")
    } else {
      cat("<p><em>No DEGs for this tissue at current thresholds.</em></p>\n")
    }

  } else {
    cat("<p><em>No DE results for this tissue.</em></p>\n")
  }

  cat("</details>\n\n")
}

cat("</details>\n")

# ---- One combined table for all tissues (filtered) ----
combined_tbl <- dplyr::bind_rows(all_tbl_sig)
if (nrow(combined_tbl) > 0) {
  cat("<details open><summary><strong>📄 Combined DEG table (all tissues; filtered)</strong></summary>\n\n")
  cat(knitr::kable(
    combined_tbl,
    format = "html",
    table.attr = "class='table table-striped table-bordered'",
    digits = 3
  ))
  cat("\n</details>\n")
} else {
  cat("<p><em>No DEGs across tissues at current thresholds.</em></p>\n")
}


# (Optional) return to sequential plan
plan(sequential)





# ---- Extract & export DEGs per tissue (Aged vs Young; males only) ----
suppressPackageStartupMessages({ library(dplyr); library(tidyr); library(knitr) })

padj_max <- 0.20   # FDR cutoff
l2fc_min <- 0.50   # |log2FC| cutoff
out_dir  <- "degs_age_males"
dir.create(out_dir, showWarnings = FALSE)

clean_deg <- function(df, tissue) {
  if (is.null(df) || !nrow(df)) return(NULL)
  df <- as.data.frame(df)

  # add gene column only if missing
  if (!"gene" %in% colnames(df)) {
    df$gene <- rownames(df)
    df <- df[, c("gene", setdiff(colnames(df), "gene"))]
  }

  # compute adj p if missing
  if (!"p_val_adj" %in% colnames(df) && "p_val" %in% colnames(df)) {
    df$p_val_adj <- p.adjust(df$p_val, method = "BH")
  }

  # build tidy table (be robust if pct.1/.2 absent)
  keep_cols <- c("gene","avg_log2FC","p_val","p_val_adj","pct.1","pct.2")
  keep_cols <- intersect(keep_cols, colnames(df))

  df %>%
    mutate(
      Tissue    = tissue,
      Contrast  = "Aged_vs_Young",
      Direction = ifelse(avg_log2FC > 0, "Up_in_Aged", "Down_in_Aged")
    ) %>%
    select(Tissue, Contrast, all_of(keep_cols), Direction)
}

# collect per tissue
age_deg_by_tissue <- lapply(names(results_list), function(tissue) {
  clean_deg(results_list[[tissue]]$Age_DE, tissue)
})
names(age_deg_by_tissue) <- names(results_list)
age_deg_by_tissue <- age_deg_by_tissue[!vapply(age_deg_by_tissue, is.null, logical(1))]

# apply thresholds
age_deg_by_tissue <- lapply(age_deg_by_tissue, function(df) {
  dplyr::filter(df, !is.na(p_val_adj), p_val_adj <= padj_max, abs(avg_log2FC) >= l2fc_min)
})

combined_df <- dplyr::as_tibble(dplyr::bind_rows(age_deg_by_tissue))

if (nrow(combined_df) > 0) {
  # per-tissue CSVs + combined CSV
  invisible(lapply(split(combined_df, combined_df$Tissue), function(df) {
    write.csv(df, file.path(out_dir, paste0("AGE_DEGs_", unique(df$Tissue), ".csv")), row.names = FALSE)
  }))
  write.csv(combined_df, file.path(out_dir, "AGE_DEGs_ALL_TISSUES.csv"), row.names = FALSE)

  # summary table (namespaced dplyr verbs)
  summary_counts <- combined_df %>%
    dplyr::mutate(
      Tissue = as.character(Tissue),
      Direction = as.character(Direction)
    ) %>%
    dplyr::count(Tissue, Direction, name = "n") %>%
    tidyr::pivot_wider(names_from = Direction, values_from = n, values_fill = 0) %>%
    dplyr::mutate(Total = dplyr::coalesce(Up_in_Aged, 0L) + dplyr::coalesce(Down_in_Aged, 0L)) %>%
    dplyr::arrange(dplyr::desc(Total))

  cat("<details open><summary><strong>🧬 DEG counts per tissue (Aged vs Young; males only)</strong></summary>\n\n")
  cat(knitr::kable(summary_counts, format = "html",
                   table.attr = "class='table table-striped table-bordered'"))
  cat("\n</details>\n")
} else {
  cat("<p><em>No DEGs at chosen thresholds.</em></p>\n")
}


```


```{r UsingNgenesasCovariate, echo=TRUE, results='asis', message=FALSE, warning=FALSE}


## Should we include N of genes per cell as a covariate to adjust for???? -> YES


qc_probe <- function(obj) {
  md <- obj@meta.data
  if (!"nFeature_RNA" %in% names(md)) stop("nFeature_RNA not in meta.data")

  # Keep only covariates present AND with ≥2 levels
  covs <- c("Age","Injury","Batch")
  keep <- covs[covs %in% names(md) & vapply(covs, function(v) {
    x <- md[[v]]; length(unique(x[!is.na(x)])) >= 2
  }, logical(1))]

  # If nothing varies, just return CV and zeros
  if (length(keep) == 0) {
    return(list(
      age_p = NA_real_, inj_p = NA_real_, batch_p = NA_real_,
      r2 = 0, cv = sd(md$nFeature_RNA, na.rm=TRUE) / mean(md$nFeature_RNA, na.rm=TRUE)
    ))
  }

  # Coerce covariates to factors
  for (nm in keep) md[[nm]] <- factor(md[[nm]])

  fml <- as.formula(paste("nFeature_RNA ~", paste(keep, collapse = " + ")))
  fit <- lm(fml, data = md)

  a <- anova(fit)                    # has Pr(>F) for each term
  s <- summary(fit)

  out <- list(
    age_p   = if ("Age"    %in% rownames(a)) a["Age","Pr(>F)"]    else NA_real_,
    inj_p   = if ("Injury" %in% rownames(a)) a["Injury","Pr(>F)"] else NA_real_,
    batch_p = if ("Batch"  %in% rownames(a)) a["Batch","Pr(>F)"]  else NA_real_,
    r2      = s$r.squared,
    cv      = sd(md$nFeature_RNA, na.rm=TRUE) / mean(md$nFeature_RNA, na.rm=TRUE)
  )
  out
}

# or for a quick table across tissues:
qc_tbl <- tibble::tibble(
  Tissue = names(male_rna_log_list),
  res    = lapply(male_rna_log_list, qc_probe)
) %>% tidyr::unnest_wider(res)

knitr::kable(qc_tbl, digits = 3)






## QC: does nFeature_RNA associate with Age/Batch *within each injury*?

suppressPackageStartupMessages({
  library(dplyr); library(tidyr); library(knitr)
})

injury_levels <- c(0, 2, 3)  # change if needed

qc_probe_injury <- function(obj, inj_level) {
  md <- obj@meta.data
  if (!"nFeature_RNA" %in% names(md)) {
    stop("nFeature_RNA not in meta.data")
  }
  # subset to one injury level
  md <- md[!is.na(md$Injury) & md$Injury == inj_level, , drop = FALSE]

  # basic counts
  n_cells <- nrow(md)
  n_age_levels   <- if ("Age"   %in% names(md)) length(unique(na.omit(md$Age)))   else 0
  n_batch_levels <- if ("Batch" %in% names(md)) length(unique(na.omit(md$Batch))) else 0

  # choose covariates present with >=2 levels (Injury is fixed here)
  keep <- c()
  if ("Age" %in% names(md)   && n_age_levels   >= 2) keep <- c(keep, "Age")
  if ("Batch" %in% names(md) && n_batch_levels >= 2) keep <- c(keep, "Batch")

  # if not enough data or no varying covariates, return CV + NA p-values
  if (n_cells < 3 || length(keep) == 0) {
    return(tibble::tibble(
      Injury = inj_level,
      n_cells = n_cells,
      age_levels = n_age_levels,
      batch_levels = n_batch_levels,
      age_p = NA_real_,
      batch_p = NA_real_,
      r2 = NA_real_,
      cv = sd(md$nFeature_RNA, na.rm=TRUE) / mean(md$nFeature_RNA, na.rm=TRUE)
    ))
  }

  # factorize covariates
  for (nm in keep) md[[nm]] <- factor(md[[nm]])

  fml <- as.formula(paste("nFeature_RNA ~", paste(keep, collapse = " + ")))
  fit <- tryCatch(lm(fml, data = md), error = function(e) NULL)

  if (is.null(fit)) {
    return(tibble::tibble(
      Injury = inj_level,
      n_cells = n_cells,
      age_levels = n_age_levels,
      batch_levels = n_batch_levels,
      age_p = NA_real_,
      batch_p = NA_real_,
      r2 = NA_real_,
      cv = sd(md$nFeature_RNA, na.rm=TRUE) / mean(md$nFeature_RNA, na.rm=TRUE)
    ))
  }

  a <- anova(fit)
  s <- summary(fit)

  tibble::tibble(
    Injury = inj_level,
    n_cells = n_cells,
    age_levels = n_age_levels,
    batch_levels = n_batch_levels,
    age_p   = if ("Age"   %in% rownames(a)) a["Age","Pr(>F)"]   else NA_real_,
    batch_p = if ("Batch" %in% rownames(a)) a["Batch","Pr(>F)"] else NA_real_,
    r2 = s$r.squared,
    cv = sd(md$nFeature_RNA, na.rm=TRUE) / mean(md$nFeature_RNA, na.rm=TRUE)
  )
}

# ----- build table across tissues × injury -----
qc_tbl_byinjury <- dplyr::bind_rows(lapply(names(male_rna_log_list), function(tissue) {
  obj <- male_rna_log_list[[tissue]]
  if (is.null(obj)) return(NULL)
  levs <- intersect(injury_levels, sort(unique(obj$Injury)))
  if (length(levs) == 0) return(NULL)

  dplyr::bind_rows(lapply(levs, function(inj) {
    out <- qc_probe_injury(obj, inj)
    dplyr::mutate(out, Tissue = tissue, .before = 1)
  }))
})) %>%
  dplyr::arrange(Tissue, Injury)

# Pretty print
knitr::kable(qc_tbl_byinjury, digits = 3,
             format = "html",
             table.attr = "class='table table-striped table-bordered'")



```



```{r FisherTestForDEGsandPCloads, echo=TRUE, results='asis', message=FALSE, warning=FALSE}
# Assumes:
# - results_list[[tissue]]$Age_DE exists from your MAST (RNA; males) analysis
# - aging_signature_combined[[tissue]] has $Loadings (named vector) and
#   $Up_in_Aged / $Down_in_Aged for the PC most associated with age
# ---- Parameters ----
top_loading_pct <- 0.10
overlap_results <- list()

for (tissue in intersect(names(aging_signature_combined), names(age_deg_by_tissue))) {
  
  # --- DEGs from MAST ---
  deg_tbl <- age_deg_by_tissue[[tissue]]
  if (is.null(deg_tbl) || nrow(deg_tbl) == 0) {
    message("Skipping ", tissue, " — no DEGs.")
    overlap_results[[tissue]] <- list(
      overlap_table = NULL,
      deg_genes = character(0),
      top_load_genes = character(0),
      overlap_genes = character(0),
      fisher_p = NA,
      contingency_table = NULL
    )
    next
  }
  deg_genes <- deg_tbl$gene
  
  # --- PCA top loadings ---
  sig <- aging_signature_combined[[tissue]]
  top_pc <- sig$TopPC
  loadings <- sig$Loadings
  n_keep <- ceiling(length(loadings) * top_loading_pct)
  top_load_genes <- names(sort(abs(loadings), decreasing = TRUE))[1:n_keep]
  
  # --- Overlap ---
  overlap_genes <- intersect(deg_genes, top_load_genes)
  
  # --- Fisher test ---
  all_genes <- names(loadings)  # Universe = all genes in PCA
  in_deg <- all_genes %in% deg_genes
  in_topload <- all_genes %in% top_load_genes
  cont_table <- table(in_deg, in_topload)
  fisher_p <- tryCatch(fisher.test(cont_table)$p.value, error = function(e) NA)
  
  if (length(overlap_genes) == 0) {
    message("No overlap for ", tissue)
    overlap_results[[tissue]] <- list(
      overlap_table = NULL,
      deg_genes = deg_genes,
      top_load_genes = top_load_genes,
      overlap_genes = character(0),
      fisher_p = fisher_p,
      contingency_table = cont_table
    )
    next
  }
  
  # --- Stats for overlapping genes ---
  deg_stats <- deg_tbl %>%
    filter(gene %in% overlap_genes) %>%
    select(gene, avg_log2FC, p_val, p_val_adj)
  
  pc_stats <- data.frame(
    gene = overlap_genes,
    PC_loading = loadings[overlap_genes],
    Top_PC = top_pc,
    P_value_Age = signif(sig$P_values_Age[1], 4),
    stringsAsFactors = FALSE
  )
  
  merged_stats <- left_join(deg_stats, pc_stats, by = "gene") %>%
    arrange(p_val_adj)
  
  # --- Save results ---
  overlap_results[[tissue]] <- list(
    overlap_table = merged_stats,
    deg_genes = deg_genes,
    top_load_genes = top_load_genes,
    overlap_genes = overlap_genes,
    fisher_p = fisher_p,
    contingency_table = cont_table
  )
  
  if (!dir.exists("overlap_results")) dir.create("overlap_results")
  write.csv(merged_stats,
            file = file.path("overlap_results", paste0("Overlap_", tissue, ".csv")),
            row.names = FALSE)
  
  # Save Venn diagram only if overlap exists
  venn_data <- list(DEGs = deg_genes, TopLoadings = top_load_genes)
  p <- ggvenn(venn_data, fill_color = c("#E69F00", "#56B4E9"),
              stroke_size = 0.8, set_name_size = 4) +
    ggtitle(paste("Overlap in", tissue,
                  "\nFisher p =", signif(fisher_p, 3)))
  ggsave(file.path("overlap_results", paste0("Venn_", tissue, ".png")),
         p, width = 4, height = 4)
}

# ---- Combined summary table ----
combined_overlap <- bind_rows(lapply(names(overlap_results), function(t) {
  df <- overlap_results[[t]]$overlap_table
  if (is.null(df) || nrow(df) == 0) return(NULL)
  df$Tissue <- t
  df$Fisher_p <- overlap_results[[t]]$fisher_p
  df
}))

write.csv(combined_overlap, "overlap_results/Overlap_AllTissues.csv", row.names = FALSE)

# ---- Fisher summary ----
fisher_summary <- data.frame(
  Tissue = names(overlap_results),
  Overlap_n = sapply(overlap_results, function(x) length(x$overlap_genes)),
  Fisher_p = sapply(overlap_results, function(x) x$fisher_p)
) %>%
  arrange(Fisher_p)

write.csv(fisher_summary, "overlap_results/FisherSummary_AllTissues.csv", row.names = FALSE)

cat("✅ Overlap + Fisher test analysis complete. Results in 'overlap_results/'\n")
```


```{r GSEAForDEGmadewithMASTInjuriesCombined, echo=TRUE, results='asis', message=FALSE, warning=FALSE}

# ===========================
# GSEA on MAST Age DE (males only) — rank by signed z from p-values
# ===========================
suppressPackageStartupMessages({
  library(fgsea)
  library(msigdbr)
  library(dplyr)
  library(knitr)
})

# ---- Pathways (load once, only if not already present) ----
if (!exists("pathways_mouse")) {
  wanted_categories <- c("H","C2","C5")
  msig_mouse <- msigdbr(species = "Mus musculus")
  if ("gs_cat" %in% colnames(msig_mouse)) {
    msig_mouse <- msig_mouse %>% filter(gs_cat %in% wanted_categories)
  } else if ("gs_collection" %in% colnames(msig_mouse)) {
    msig_mouse <- msig_mouse %>% filter(gs_collection %in% wanted_categories)
  }
  pathways_mouse <- split(msig_mouse$gene_symbol, msig_mouse$gs_name)
  message("Loaded ", length(pathways_mouse), " pathways for mouse.")
}

# ---- GSEA knobs (safe defaults; won’t overwrite if already set) ----
gsea_mode       <- get0("gsea_mode",       ifnotfound = "fast")  # "fast" or "accurate"
gsea_nperm_fast <- get0("gsea_nperm_fast", ifnotfound = 5000)
gsea_q_cutoff   <- get0("gsea_q_cutoff",   ifnotfound = 0.20)
gsea_min_size   <- get0("gsea_min_size",   ifnotfound = 10)
gsea_max_size   <- get0("gsea_max_size",   ifnotfound = 500)

set.seed(123)

gsea_results_age_mast <- list()

for (tissue in names(results_list)) {
  res_full <- results_list[[tissue]]$Age_DE
  if (is.null(res_full) || nrow(res_full) == 0) next

  # Ensure required columns
  if (!"gene" %in% colnames(res_full)) res_full$gene <- rownames(res_full)
  if (!"p_val_adj" %in% colnames(res_full) && "p_val" %in% colnames(res_full)) {
    res_full$p_val_adj <- p.adjust(res_full$p_val, method = "BH")
  }

  res_full <- res_full %>%
    dplyr::filter(!is.na(gene), !is.na(avg_log2FC), !is.na(p_val))

  if (nrow(res_full) < 10) next

  # ---- Signed ranking score (two-sided p -> z) ----
  p2 <- pmax(pmin(res_full$p_val/2, 1 - 1e-16), 1e-300)
  signed_z <- sign(res_full$avg_log2FC) * qnorm(p2, lower.tail = FALSE)
  names(signed_z) <- res_full$gene

  # If duplicated gene names (rare), keep the strongest |z|
  signed_z <- tapply(signed_z, names(signed_z), function(v) v[which.max(abs(v))]) |> unlist()
  signed_z <- sort(signed_z[is.finite(signed_z)], decreasing = TRUE)

  if (length(signed_z) < 10) next

  # ---- Run fgsea ----
  fg <- if (identical(gsea_mode, "fast")) {
    fgsea::fgsea(
      pathways = pathways_mouse,
      stats    = signed_z,
      minSize  = gsea_min_size,
      maxSize  = gsea_max_size,
      nperm    = gsea_nperm_fast
    )
  } else {
    fgsea::fgseaMultilevel(
      pathways = pathways_mouse,
      stats    = signed_z,
      minSize  = gsea_min_size,
      maxSize  = gsea_max_size
    )
  }
  fg <- as.data.frame(fg)

  # ---- Annotate leading-edge overlaps with your filtered DEGs (if available) ----
  de_genes <- if (exists("age_deg_by_tissue") && tissue %in% names(age_deg_by_tissue)) {
    unique(age_deg_by_tissue[[tissue]]$gene)
  } else {
    # fallback: use an FDR-only filter from this table
    unique(res_full$gene[!is.na(res_full$p_val_adj) & res_full$p_val_adj <= 0.20])
  }

  fg$leadingEdge_count    <- vapply(fg$leadingEdge, length, integer(1))
  fg$leadingEdge_DE_count <- vapply(fg$leadingEdge, function(g) sum(g %in% de_genes), integer(1))
  fg$leadingEdge_DE_genes <- vapply(
    fg$leadingEdge, function(g) paste(intersect(g, de_genes), collapse = ", "),
    FUN.VALUE = character(1)
  )
  fg$leadingEdge <- vapply(fg$leadingEdge, paste, collapse = ", ", FUN.VALUE = character(1))

  fg$Tissue <- tissue
  fg$Model  <- "Aged vs Young (MAST; males only)"

  gsea_results_age_mast[[length(gsea_results_age_mast) + 1]] <- fg

  # Optional per-tissue printout of significant pathways
  fg_sig <- subset(fg, !is.na(padj) & padj < gsea_q_cutoff)
  cat(sprintf("<details><summary><strong>%s — GSEA (MAST Age ranking)</strong></summary>\n\n", tissue))
  if (nrow(fg_sig) > 0) {
    cat(knitr::kable(
      fg_sig[, c("pathway","NES","pval","padj","size",
                 "leadingEdge_count","leadingEdge_DE_count","leadingEdge_DE_genes")],
      format = "html",
      table.attr = "class='table table-condensed table-bordered'"
    ))
  } else {
    cat(sprintf("<p><em>No pathways at FDR &lt; %.2f.</em></p>\n", gsea_q_cutoff))
  }
  cat("</details>\n\n")
}

# ---- Combine & summarize across tissues ----
if (length(gsea_results_age_mast) > 0) {
  gsea_summary_age_mast <- do.call(rbind, gsea_results_age_mast)
  gsea_summary_age_mast <- gsea_summary_age_mast[order(gsea_summary_age_mast$padj), , drop = FALSE]

  gsea_sig_age_mast <- subset(gsea_summary_age_mast, !is.na(padj) & padj < gsea_q_cutoff)

  cat("<details open><summary><strong>GSEA Summary — Significant Pathways (Aged vs Young; MAST; males)</strong></summary>\n\n")
  if (nrow(gsea_sig_age_mast) > 0) {
    cat(knitr::kable(
      gsea_sig_age_mast[, c("Model","Tissue","pathway","NES","pval","padj","size",
                            "leadingEdge_count","leadingEdge_DE_count","leadingEdge_DE_genes")],
      format = "html",
      table.attr = "class='table table-striped table-condensed'"
    ))
  } else {
    cat("<p><em>No significant pathways at selected FDR.</em></p>\n")
  }
  cat("</details>\n\n")

  # Save CSV (sanitize commas in gene lists)
  if (nrow(gsea_sig_age_mast) > 0) {
    gsea_sig_age_mast$leadingEdge          <- gsub(",", ";", gsea_sig_age_mast$leadingEdge, fixed = TRUE)
    gsea_sig_age_mast$leadingEdge_DE_genes <- gsub(",", ";", gsea_sig_age_mast$leadingEdge_DE_genes, fixed = TRUE)
    write.csv(gsea_sig_age_mast,
              file = "GSEA_Age_DE_MAST_males_significant.csv",
              row.names = FALSE)
    cat("✅ Saved: ", file.path(getwd(), "GSEA_Age_DE_MAST_males_significant.csv"), "\n\n")
  }
} else {
  cat("<p><em>No GSEA results generated (no valid rankings).</em></p>\n")
}



```


## 8.2 Downstream Analyses (Males Only, Adjusted) for Aging Signature with overlapped PCloadings and DEGs using right stat MAST (RNA) that allows for adjustment of covariates, divided by injury


```{r DownstreamAnalyses_MalesAdjustedusingMASTdividedInjury, echo=TRUE, results='asis', message=FALSE, warning=FALSE}

## 8.x Age DE within Injury strata (Males only; MAST on RNA; Batch + nFeature_RNA adjusted)
## Assumes `male_rna_log_list` exists (Sex == 0; RNA LogNormalize already done)

suppressPackageStartupMessages({
  library(Seurat)
  library(MAST)
  library(dplyr)
  library(tidyr)
  library(future); library(future.apply)
  library(knitr)
})

# ---------- Parallel ----------
workers <- max(1, parallel::detectCores() - 1)
plan(multisession, workers = workers)

# ---------- Settings ----------
injury_levels <- c(0, 2, 3)
padj_max <- get0("padj_max", ifnotfound = 0.20)   # for reporting/exports
l2fc_min <- get0("l2fc_min", ifnotfound = 0.50)
min_pct  <- 0.01
lfc_thr  <- 0.25

# ---------- Helper: ALWAYS include nFeature_RNA (z-scored); include Batch if ≥2 levels ----------
.build_covars <- function(obj) {
  covars <- character(0)

  # Batch: include only if ≥2 levels
  if ("Batch" %in% colnames(obj@meta.data)) {
    lv <- unique(na.omit(obj$Batch))
    if (length(lv) >= 2) covars <- c(covars, "Batch")
  }

  # ALWAYS include nFeature_RNA as z-score (0 vector if constant) when present
  if ("nFeature_RNA" %in% colnames(obj@meta.data)) {
    v  <- obj$nFeature_RNA
    zz <- rep(0, length(v))
    if (is.numeric(v)) {
      sdv <- stats::sd(v, na.rm = TRUE)
      if (!is.na(sdv) && sdv > 0) {
        zz <- as.numeric(scale(v))
      }
    }
    obj$nFeature_RNA_z <- zz
    covars <- c(covars, "nFeature_RNA_z")
  }

  list(obj = obj, covars = covars)
}

# ---------- 1) Run MAST: Age (1 vs 0) within each Injury ----------
de_age_by_injury_one <- function(tissue) {
  obj_all <- male_rna_log_list[[tissue]]
  if (is.null(obj_all)) return(NULL)

  DefaultAssay(obj_all) <- "RNA"
  out <- list()

  for (inj in injury_levels) {
    if (!inj %in% unique(obj_all$Injury)) next

    obj <- subset(obj_all, subset = Injury == inj & Age %in% c(0, 1))
    if (is.null(obj) || ncol(obj) < 25 || length(unique(obj$Age)) < 2) {
      out[[paste0("Injury_", inj)]] <- NULL
      next
    }

    # Build covariates (Batch if ≥2 lvls) AND ALWAYS nFeature_RNA_z when present
    bc <- .build_covars(obj)
    obj    <- bc$obj
    covars <- bc$covars

    # DE (MAST)
    res <- tryCatch(
      FindMarkers(
        obj,
        group.by        = "Age",
        ident.1         = 1,   # Aged
        ident.2         = 0,   # Young
        assay           = "RNA",
        test.use        = "MAST",
        only.pos        = FALSE,
        latent.vars     = covars,
        min.pct         = min_pct,
        logfc.threshold = lfc_thr
      ) |> as.data.frame(),
      error = function(e) NULL
    )

    # Tidy columns
    if (!is.null(res)) {
      if (!"gene" %in% colnames(res)) {
        res$gene <- rownames(res)
        res <- res[, c("gene", setdiff(colnames(res), "gene"))]
      }
      if (!"p_val_adj" %in% colnames(res) && "p_val" %in% colnames(res)) {
        res$p_val_adj <- p.adjust(res$p_val, method = "BH")
      }
    }
    out[[paste0("Injury_", inj)]] <- res
  }
  out
}

# ---------- Tissues to run ----------
tissues_to_run <- intersect(
  c("CartilageFemur","CartilageTibia","SubchondralFemur","SubchondralTibia",
    "Synovium","IPFP","Meniscus","BoneMarrowFemur","BoneMarrowTibia",
    "GrowthPlateTibia","GrowthPlateFemur"),
  names(male_rna_log_list)
)

# ---------- Parallel run ----------
results_age_by_injury <- future_lapply(tissues_to_run, de_age_by_injury_one)
names(results_age_by_injury) <- tissues_to_run

# ---------- 2) Save CSVs: per tissue×injury + one combined ----------
out_dir <- "degs_age_byinjury_males"
dir.create(out_dir, showWarnings = FALSE)

clean_and_tag <- function(df, tissue, inj) {
  if (is.null(df) || !nrow(as.data.frame(df))) return(NULL)
  df <- as.data.frame(df)

  if (!"gene" %in% colnames(df)) {
    df$gene <- rownames(df)
    df <- df[, c("gene", setdiff(colnames(df), "gene"))]
  }
  if (!"p_val_adj" %in% colnames(df) && "p_val" %in% colnames(df)) {
    df$p_val_adj <- p.adjust(df$p_val, method = "BH")
  }

  keep_cols <- c("gene","avg_log2FC","p_val","p_val_adj","pct.1","pct.2")
  keep_cols <- intersect(keep_cols, colnames(df))

  df %>%
    dplyr::mutate(
      Tissue    = tissue,
      Injury    = inj,
      Direction = ifelse(avg_log2FC > 0, "Up_in_Aged", "Down_in_Aged")
    ) %>%
    dplyr::select(Tissue, Injury, dplyr::all_of(keep_cols), Direction) %>%
    dplyr::filter(!is.na(p_val_adj), p_val_adj <= padj_max, abs(avg_log2FC) >= l2fc_min)
}

per_tbls <- list()

for (tissue in names(results_age_by_injury)) {
  tbls <- results_age_by_injury[[tissue]]
  if (is.null(tbls)) next

  for (inj_key in names(tbls)) {
    inj_val <- sub("^Injury_", "", inj_key)
    df <- clean_and_tag(tbls[[inj_key]], tissue = tissue, inj = inj_val)
    if (is.null(df) || nrow(df) == 0) next

    per_tbls[[paste(tissue, inj_val, sep="|")]] <- df
    utils::write.csv(
      df,
      file.path(out_dir, sprintf("AGE_DEGs_byInjury_%s_Injury_%s.csv", tissue, inj_val)),
      row.names = FALSE
    )
  }
}

combined_df <- if (length(per_tbls)) dplyr::bind_rows(per_tbls) else NULL

if (!is.null(combined_df) && nrow(as.data.frame(combined_df)) > 0) {
  combined_df <- tibble::as_tibble(combined_df) %>%
    dplyr::mutate(
      Tissue = as.character(Tissue),
      Injury = suppressWarnings(as.integer(Injury)),  # for ordering
      Direction = as.character(Direction)
    )

  utils::write.csv(
    combined_df,
    file.path(out_dir, "AGE_DEGs_ALL_TISSUES_byInjury.csv"),
    row.names = FALSE
  )

  # Summary table
  summary_counts <- combined_df %>%
    dplyr::count(Tissue, Injury, Direction, name = "n") %>%
    tidyr::pivot_wider(names_from = Direction, values_from = n, values_fill = 0) %>%
    dplyr::arrange(Tissue, Injury)

  cat("<details open><summary><strong>🧬 DEG counts per tissue × injury (Aged vs Young; males)</strong></summary>\n\n")
  cat(knitr::kable(summary_counts, format = "html",
                   table.attr = "class='table table-striped table-bordered'"))
  cat("\n</details>\n")
} else {
  cat("<p><em>No DEGs at chosen thresholds for any tissue × injury.</em></p>\n")
}

# Optional: return to sequential
plan(sequential)


```


```{r FisherTestForDEGsandPCloadsbyInjury, echo=FALSE, results='hide', message=FALSE, warning=FALSE, include=FALSE, eval=FALSE}

suppressPackageStartupMessages({
  library(dplyr)
  library(ggplot2)  # for ggsave
})

top_loading_pct <- 0.20
overlap_byinjury <- list()

# Ensure output dir exists
out_dir <- "overlap_byinjury_results"
if (!dir.exists(out_dir)) dir.create(out_dir)

# Loop over injuries present in both DEG and PCA lists (coerce Injury to character)
injuries_to_loop <- intersect(names(byinjury_signature),
                              as.character(unique(combined_df$Injury)))

for (inj_chr in injuries_to_loop) {

  # Limit tissues to those present in both sources
  tissues_to_loop <- intersect(names(byinjury_signature[[inj_chr]]),
                               unique(combined_df$Tissue))

  for (tissue in tissues_to_loop) {
    # --- Filter DEGs for this tissue × injury
    inj_int <- suppressWarnings(as.integer(inj_chr))
    deg_tbl <- combined_df %>%
      dplyr::filter(Tissue == tissue, Injury == inj_int)
    if (nrow(deg_tbl) == 0) next
    deg_genes <- deg_tbl$gene

    # --- PCA loadings for this tissue × injury
    sig <- byinjury_signature[[inj_chr]][[tissue]]
    if (is.null(sig)) next
    loadings <- sig$Loadings
    n_keep <- ceiling(length(loadings) * top_loading_pct)
    top_load_genes <- names(sort(abs(loadings), decreasing = TRUE))[1:n_keep]

    # --- Overlap
    overlap_genes <- intersect(deg_genes, top_load_genes)

    # --- Fisher's exact test (use all genes in PCA as universe)
    all_genes <- names(loadings)
    in_deg <- all_genes %in% deg_genes
    in_topload <- all_genes %in% top_load_genes
    cont_table <- table(in_deg, in_topload)
    fisher_p <- fisher.test(cont_table)$p.value

    key <- paste(tissue, inj_chr, sep = "|")

    if (length(overlap_genes) == 0) {
      # Save empty CSV with no overlaps
      write.csv(data.frame(),
                file.path(out_dir, paste0("Overlap_", tissue, "_Injury", inj_chr, ".csv")),
                row.names = FALSE)

      # Venn diagram (still useful even if overlap is zero)
      venn_data <- list(DEGs = deg_genes, TopLoadings = top_load_genes)
      p <- ggvenn(venn_data,
                  fill_color = c("#E69F00", "#56B4E9"),
                  stroke_size = 0.8, set_name_size = 4) +
        ggtitle(paste(tissue, "- Injury", inj_chr,
                      "\nFisher p =", signif(fisher_p, 3)))
      ggsave(file.path(out_dir, paste0("Venn_", tissue, "_Injury", inj_chr, ".png")),
             p, width = 4, height = 4)

      # Store summary
      overlap_byinjury[[key]] <- list(
        Tissue = tissue,
        Injury = inj_chr,
        overlap_table = NULL,
        deg_genes = deg_genes,
        top_load_genes = top_load_genes,
        overlap_genes = character(0),
        fisher_p = fisher_p,
        contingency_table = cont_table
      )

      next
    }

    # --- Merge stats (only when there is overlap)
    deg_stats <- deg_tbl %>%
      dplyr::filter(gene %in% overlap_genes) %>%
      dplyr::select(gene, avg_log2FC, p_val, p_val_adj)

    pc_stats <- data.frame(
      gene = overlap_genes,
      PC_loading = loadings[overlap_genes],
      Top_PC = sig$TopPC,
      P_value_Age = signif(sig$P_values_Age[1], 4),
      stringsAsFactors = FALSE
    )

    merged_stats <- dplyr::left_join(deg_stats, pc_stats, by = "gene") %>%
      dplyr::arrange(p_val_adj)

    # --- Save results
    overlap_byinjury[[key]] <- list(
      Tissue = tissue,
      Injury = inj_chr,
      overlap_table = merged_stats,
      deg_genes = deg_genes,
      top_load_genes = top_load_genes,
      overlap_genes = overlap_genes,
      fisher_p = fisher_p,
      contingency_table = cont_table
    )

    # Save overlap table
    write.csv(merged_stats,
              file.path(out_dir, paste0("Overlap_", tissue, "_Injury", inj_chr, ".csv")),
              row.names = FALSE)

    # Save Venn diagram
    venn_data <- list(DEGs = deg_genes, TopLoadings = top_load_genes)
    p <- ggvenn(venn_data,
                fill_color = c("#E69F00", "#56B4E9"),
                stroke_size = 0.8, set_name_size = 4) +
      ggtitle(paste(tissue, "- Injury", inj_chr,
                    "\nFisher p =", signif(fisher_p, 3)))
    ggsave(file.path(out_dir, paste0("Venn_", tissue, "_Injury", inj_chr, ".png")),
           p, width = 4, height = 4)
  }
}

# ---- Combined overlap table across all tissue × injury ----
combined_overlap_byinjury <- bind_rows(lapply(overlap_byinjury, function(x) {
  if (is.null(x$overlap_table) || nrow(x$overlap_table) == 0) return(NULL)
  df <- x$overlap_table
  df$Tissue <- x$Tissue
  df$Injury <- x$Injury
  df$Fisher_p <- x$fisher_p
  df
}))

if (!is.null(combined_overlap_byinjury) && nrow(combined_overlap_byinjury) > 0) {
  write.csv(combined_overlap_byinjury,
            file.path(out_dir, "Overlap_AllTissues_byInjury.csv"),
            row.names = FALSE)
} else {
  # write an empty placeholder so the pipeline downstream doesn't break
  write.csv(data.frame(),
            file.path(out_dir, "Overlap_AllTissues_byInjury.csv"),
            row.names = FALSE)
}

# ---- Fisher summary per tissue × injury ----
fisher_summary_byinjury <- data.frame(
  TissueInjury = names(overlap_byinjury),
  Tissue = sapply(overlap_byinjury, [[, "Tissue"),
  Injury = sapply(overlap_byinjury, [[, "Injury"),
  Overlap_n = sapply(overlap_byinjury, function(x) length(x$overlap_genes)),
  Fisher_p = sapply(overlap_byinjury, function(x) x$fisher_p)
) %>%
  arrange(Fisher_p)

write.csv(fisher_summary_byinjury,
          file.path(out_dir, "FisherSummary_AllTissues_byInjury.csv"),
          row.names = FALSE)

cat("✅ Injury-stratified overlap + Fisher test complete. See '", out_dir, "/'\n", sep = "")


```


# 9 Visualization of Top Genes in QC-filtered tissue-merged samples


# 9.1 Obtaining the Top Genes by tissue specificity 

```{r vennAllTissues, echo=TRUE, results='asis', message=FALSE, warning=FALSE}

#––– Gene‐Level QC & Top Genes per Tissue –––#

gene_qc_summary <- list()
top100_lists     <- list()

for (tissue in names(merged_by_tissue)) {
  obj <- merged_by_tissue[[tissue]]
  DefaultAssay(obj) <- "RawCounts"
  mat <- GetAssayData(obj, slot = "counts")
  
  # Compute per‐gene metrics
  gene_means      <- rowMeans(mat)
  gene_detect_pct <- rowSums(mat > 0) / ncol(mat) * 100
  
  # Decide cutoffs
  mean_cutoff   <- quantile(gene_means, 0.001)
  detect_cutoff <- 0.1
  
  # Record QC summary
  keep <- (gene_means >= mean_cutoff) & (gene_detect_pct >= detect_cutoff)
  gene_qc_summary[[tissue]] <- data.frame(
    Total_Genes   = length(gene_means),
    Mean_Cutoff   = formatC(mean_cutoff, format = "f", digits = 4),
    Detect_Cutoff = formatC(detect_cutoff, format = "f", digits = 4),
    Genes_Kept    = sum(keep),
    Genes_Dropped = sum(!keep),
    stringsAsFactors = FALSE
  )
  
  # Use top 5% of genes based on mean expression (among those passing QC)
  kept_means    <- sort(gene_means[keep], decreasing = TRUE)
  n_top <- ceiling(length(kept_means) * 0.05)
  top100_lists[[tissue]] <- names(kept_means)[seq_len(n_top)]
}

# Render the QC summary table
library(knitr)
gene_qc_df <- do.call(rbind, gene_qc_summary)
cat("**Gene‐Level QC Summary by Tissue**\n\n")
cat(kable(
  gene_qc_df,
  format     = "html",
  table.attr = "class='table table-striped table-bordered'",
  caption    = "Number of genes kept vs dropped per tissue"
), "\n\n")

#––– UpSet Plot of Top 5% Genes Across Tissues –––#

# 1) Convert to UpSetR input
if (!requireNamespace("UpSetR", quietly = TRUE)) install.packages("UpSetR")
library(UpSetR)
sets_for_upset <- UpSetR::fromList(top100_lists)

# 2) Bump margins so nothing clips
old_mar <- par("mar"); old_oma <- par("oma")
par(mar = c(10, old_mar[2], old_mar[3], old_mar[4]))
par(oma = c(5, old_oma[2], old_oma[3], old_oma[4]))

# 3) Render UpSet plot with your chosen ratio
UpSetR::upset(
  sets_for_upset,
  sets        = names(top100_lists),
  nsets       = length(top100_lists),
  nintersects = 20,
  order.by    = "freq",
  
  # main bars 80% height, matrix 20%
  mb.ratio    = c(0.8, 0.2),
  
  main.bar.color = "steelblue",
  sets.bar.color = "skyblue",
  
  # shrink text & points
  text.scale  = c(1, 1, 0.8, 0.8, 1, 0.8),
  point.size  = 1
)

# 4) Restore margins
par(mar = old_mar, oma = old_oma)



#––– Table of Genes in Each Intersection with Mean & Coverage –––#

#––– Intersection Tables with Per‐Tissue Mean & Coverage –––#

# 1) Compute intersection combinations and sizes
library(gtools)
tissues   <- names(top100_lists)
combo_sizes <- lapply(seq_along(tissues), function(k) {
  combos <- combinations(length(tissues), k, tissues)
  apply(combos, 1, function(combo) {
    genes <- Reduce(intersect, top100_lists[combo])
    others <- setdiff(tissues, combo)
    if (length(others)) genes <- setdiff(genes, unlist(top100_lists[others]))
    length(genes)
  })
})
combo_df <- do.call(rbind, lapply(seq_along(combo_sizes), function(k) {
  combos <- combinations(length(tissues), k, tissues)
  sizes  <- combo_sizes[[k]]
  data.frame(
    Combo = apply(combos, 1, paste, collapse = " & "),
    Size  = sizes,
    stringsAsFactors = FALSE
  )
}))
combo_df <- combo_df[combo_df$Size > 0, ]
combo_df <- combo_df[order(-combo_df$Size), ]
combo_df$ID <- seq_len(nrow(combo_df))

# 2) Build detailed table with per‐tissue stats
library(dplyr)
intersect_df <- bind_rows(lapply(seq_len(nrow(combo_df)), function(i) {
  combo_name <- combo_df$Combo[i]
  combo_tiss <- strsplit(combo_name, " & ", fixed=TRUE)[[1]]
  genes <- Reduce(intersect, top100_lists[combo_tiss])
  others <- setdiff(tissues, combo_tiss)
  if (length(others)) genes <- setdiff(genes, unlist(top100_lists[others]))
  
  # Prepare data.frame
  df <- data.frame(
    Intersection_ID = combo_df$ID[i],
    Intersection    = combo_name,
    Gene            = genes,
    stringsAsFactors = FALSE
  )
  
  # Append per‐tissue mean & coverage
  for (t in tissues) {
    obj <- merged_by_tissue[[t]]
    DefaultAssay(obj) <- "RawCounts"
    mat <- GetAssayData(obj, slot="counts")[genes, , drop=FALSE]
    df[[paste0(t, "_Mean")]]     <- round(rowMeans(mat),   3)
    df[[paste0(t, "_Coverage")]] <- round(rowSums(mat > 0)/ncol(mat)*100, 1)
  }
  df
}))

# 3) Render the intersection legend and detailed table
library(knitr)

cat("<details><summary><strong>Intersection Legend (ID, Combination, # Genes)</strong></summary>\n\n")
cat(kable(
  combo_df[, c("ID","Combo","Size")],
  col.names = c("ID","Intersection","# Genes"),
  format    = "html",
  table.attr= "class='table table-striped table-bordered'"
))
cat("\n</details>\n\n")


# 4) Render the detailed table with a collapsible panel
cat("<details><summary><strong>Detailed Genes per Intersection with Per‐Tissue Mean & Coverage</strong></summary>\n\n")
cat(kable(
  intersect_df,
  format     = "html",
  table.attr = "class='table table-striped table-bordered'",
  caption    = "Intersection | Gene | Tissue‐specific Mean & Coverage"
))
cat("\n</details>\n\n")



```






```{r CrossRefTissue, echo=TRUE, results='asis', message=FALSE, warning=FALSE}
library(dplyr)
library(Seurat)

# ------------------------
# 1. Filter gene categories (single-tissue + specific dual-tissue)
# ------------------------

# Define additional combinations to retain
allowed_dual_intersections <- c(
  "CartilageFemur & CartilageTibia",
  "SubchondralFemur & SubchondralTibia",
  "BoneMarrowFemur & BoneMarrowTibia", 
  "GrowthPlateFemur & GrowthPlateTibia"
)

# Keep rows that are either:
# - single-tissue (no "&"), or
# - in allowed dual-tissue combinations
single_tissue_genes_subset <- intersect_df %>%
  filter(!grepl(" & ", Intersection) | Intersection %in% allowed_dual_intersections) %>%
  select(Intersection, Gene)
```


```{r CrossRefTissueListGenes, echo=TRUE, results='asis', message=FALSE, warning=FALSE}

# ------------------------
# 2. Check known tissue marker genes in your intersection table
# ------------------------

# Define your curated tissue-specific marker genes
marker_genes <- c(
  # Bone
  "Sost", "Dmp1", "Mepe", "Bglap", "Alpl",
  # Cartilage
  "Acan", "Col2a1", "Prg4", "Comp", "Sox9",
  # Fat
  "Adipoq", "Pparg", "Fabp4", "Lep", "Cidec",
  # Synovium
  "Cd55", "Cdh11", "Has1", "Prg4", "Lub",
  # Meniscus (fibrocartilage)
  "Fmod", "Lum", "Col1a1", "Scx", "Tnmd"
)

# Filter your intersection table for these genes
marker_gene_hits <- intersect_df %>%
  filter(Gene %in% marker_genes) %>%
  arrange(Intersection, Gene)

# Optional: merge with a lookup of tissue assignment for better readability
marker_gene_hits$Assigned_Tissue <- dplyr::case_when(
  marker_gene_hits$Gene %in% c("Sost", "Dmp1", "Mepe", "Bglap", "Alpl", "Ibsp") ~ "Subchondral Bone",
  marker_gene_hits$Gene %in% c("Acan", "Col2a1", "Prg4", "Comp", "Sox9") ~ "Cartilage",
  marker_gene_hits$Gene %in% c("Adipoq", "Pparg", "Fabp4", "Lep", "Cidec") ~ "Fat",
  marker_gene_hits$Gene %in% c("Cd55", "Cdh11", "Has1", "Prg4", "Lub") ~ "Synovium",
  marker_gene_hits$Gene %in% c("Fmod", "Lum", "Col1a1", "Scx", "Tnmd") ~ "Meniscus",
  TRUE ~ NA_character_
)

# Output results in collapsible format
cat("<details><summary><strong>Known Marker Genes Found in Tissue-Specific Top 5% Sets</strong></summary>\n\n")
cat(kable(
  marker_gene_hits,
  format = "html",
  table.attr = "class='table table-striped table-bordered'",
  caption = "Each marker gene’s assigned tissue and detected intersection"
))
cat("\n</details>\n\n")

```


```{r CrossRefTissueListGenes10, echo=TRUE, results='asis', message=FALSE, warning=FALSE}
# ------------------------
# 2. Check known tissue marker genes in your intersection table
# ------------------------

# Define your curated tissue-specific marker genes
marker_genes <- c(
  # Bone
  "Sost", "Dmp1", "Mepe", "Bglap", "Alpl",
  # Cartilage
  "Acan", "Col2a1", "Prg4", "Comp", "Sox9",
  # Fat
  "Adipoq", "Pparg", "Fabp4", "Lep", "Cidec",
  # Synovium
  "Cd55", "Cdh11", "Has1", "Prg4", "Lub",
  # Meniscus (fibrocartilage)
  "Fmod", "Lum", "Col1a1", "Scx", "Tnmd"
)

# Recalculate top 10% gene lists per tissue
top10_lists <- list()

for (tissue in names(merged_by_tissue)) {
  obj <- merged_by_tissue[[tissue]]
  DefaultAssay(obj) <- "RawCounts"
  mat <- GetAssayData(obj, slot = "counts")
  
  gene_means      <- rowMeans(mat)
  gene_detect_pct <- rowSums(mat > 0) / ncol(mat) * 100
  
  mean_cutoff   <- quantile(gene_means, 0.001)
  detect_cutoff <- 0.1
  
  keep <- (gene_means >= mean_cutoff) & (gene_detect_pct >= detect_cutoff)
  kept_means    <- sort(gene_means[keep], decreasing = TRUE)
  n_top <- ceiling(length(kept_means) * 0.10)  # ← changed from 0.05 to 0.10
  top10_lists[[tissue]] <- names(kept_means)[seq_len(n_top)]
}

# Rebuild intersection_df for top 10%
library(gtools)
tissues   <- names(top10_lists)
combo_df_10 <- do.call(rbind, lapply(seq_along(tissues), function(k) {
  if (k > length(tissues)) return(NULL)
  combos <- combinations(length(tissues), k, tissues)
  apply(combos, 1, function(combo) {
    genes <- Reduce(intersect, top10_lists[combo])
    others <- setdiff(tissues, combo)
    if (length(others)) genes <- setdiff(genes, unlist(top10_lists[others]))
    length(genes)
  })
}))
combo_df_10 <- do.call(rbind, lapply(seq_along(combo_df_10), function(k) {
  if (k > length(tissues)) return(NULL)
  combos <- combinations(length(tissues), k, tissues)
  sizes  <- combo_df_10[[k]]
  data.frame(
    Combo = apply(combos, 1, paste, collapse = " & "),
    Size  = sizes,
    stringsAsFactors = FALSE
  )
}))
combo_df_10 <- combo_df_10[combo_df_10$Size > 0, ]
combo_df_10 <- combo_df_10[order(-combo_df_10$Size), ]
combo_df_10$ID <- seq_len(nrow(combo_df_10))



# Recreate intersect_df_10
intersect_df_10 <- bind_rows(lapply(seq_len(nrow(combo_df_10)), function(i) {
  combo_name <- combo_df_10$Combo[i]
  combo_tiss <- strsplit(combo_name, " & ", fixed=TRUE)[[1]]
  genes <- Reduce(intersect, top10_lists[combo_tiss])
  others <- setdiff(tissues, combo_tiss)
  if (length(others)) genes <- setdiff(genes, unlist(top10_lists[others]))
  
  # ⛔ Skip if no genes in intersection
  if (length(genes) == 0) return(NULL)

  df <- data.frame(
    Intersection_ID = combo_df_10$ID[i],
    Intersection    = combo_name,
    Gene            = genes,
    stringsAsFactors = FALSE
  )
  
  for (t in tissues) {
    obj <- merged_by_tissue[[t]]
    DefaultAssay(obj) <- "RawCounts"
    mat <- GetAssayData(obj, slot="counts")[genes, , drop=FALSE]
    df[[paste0(t, "_Mean")]]     <- round(rowMeans(mat),   3)
    df[[paste0(t, "_Coverage")]] <- round(rowSums(mat > 0)/ncol(mat)*100, 1)
  }
  df
}))

# Now check marker genes within top 10%
marker_gene_hits_10 <- intersect_df_10 %>%
  filter(Gene %in% marker_genes) %>%
  arrange(Intersection, Gene)

marker_gene_hits_10$Assigned_Tissue <- dplyr::case_when(
  marker_gene_hits_10$Gene %in% c("Sost", "Dmp1", "Mepe", "Bglap", "Alpl") ~ "Subchondral Bone",
  marker_gene_hits_10$Gene %in% c("Acan", "Col2a1", "Prg4", "Comp", "Sox9") ~ "Cartilage",
  marker_gene_hits_10$Gene %in% c("Adipoq", "Pparg", "Fabp4", "Lep", "Cidec") ~ "Fat",
  marker_gene_hits_10$Gene %in% c("Cd55", "Cdh11", "Has1", "Prg4", "Lub") ~ "Synovium",
  marker_gene_hits_10$Gene %in% c("Fmod", "Lum", "Col1a1", "Scx", "Tnmd") ~ "Meniscus",
  TRUE ~ NA_character_
)

# Output
cat("<details><summary><strong>Known Marker Genes Found in Tissue-Specific Top 10% Sets</strong></summary>\n\n")
cat(kable(
  marker_gene_hits_10,
  format = "html",
  table.attr = "class='table table-striped table-bordered'",
  caption = "Each marker gene’s assigned tissue and detected intersection (Top 10%)"
))
cat("\n</details>\n\n")
```


```{r CrossRefTissueListGenesAll, echo=TRUE, results='asis', message=FALSE, warning=FALSE}

# Marker genes
marker_genes <- c(
  # Bone
  "Sost", "Dmp1", "Mepe", "Bglap", "Alpl",
  # Cartilage
  "Acan", "Col2a1", "Prg4", "Comp", "Sox9",
  # Fat
  "Adipoq", "Pparg", "Fabp4", "Lep", "Cidec",
  # Synovium
  "Cd55", "Cdh11", "Has1", "Lub",
  # Meniscus
  "Fmod", "Lum", "Col1a1", "Scx", "Tnmd"
)

# 1. Rebuild combination table like before
library(gtools)
library(dplyr)
library(tidyr)

top10_lists <- list()

# Step 1: get top10 lists
for (tissue in names(merged_by_tissue)) {
  obj <- merged_by_tissue[[tissue]]
  DefaultAssay(obj) <- "RawCounts"
  mat <- GetAssayData(obj, slot = "counts")
  
  gene_means <- rowMeans(mat)
  gene_detect_pct <- rowSums(mat > 0) / ncol(mat) * 100
  keep <- gene_means >= quantile(gene_means, 0.001) & gene_detect_pct >= 0.1
  kept_means <- sort(gene_means[keep], decreasing = TRUE)
  n_top <- ceiling(length(kept_means) * 0.10)
  top10_lists[[tissue]] <- names(kept_means)[seq_len(n_top)]
}

# Step 2: Create intersection combinations
tissues <- names(top10_lists)
combo_df <- do.call(rbind, lapply(seq_along(tissues), function(k) {
  combos <- combinations(length(tissues), k, tissues)
  apply(combos, 1, function(combo) {
    genes <- Reduce(intersect, top10_lists[combo])
    others <- setdiff(tissues, combo)
    if (length(others)) genes <- setdiff(genes, unlist(top10_lists[others]))
    length(genes)
  })
}))
combo_df <- do.call(rbind, lapply(seq_along(tissues), function(k) {
  combos <- combinations(length(tissues), k, tissues)
  sizes  <- combo_df[[k]]
  data.frame(
    Combo = apply(combos, 1, paste, collapse = " & "),
    Size  = sizes,
    stringsAsFactors = FALSE
  )
}))

combo_df <- combo_df[combo_df$Size > 0, ]
combo_df$ID <- seq_len(nrow(combo_df))

# Keep only single tissue or specified double combinations
valid_combos <- c(
  "CartilageFemur",
  "CartilageTibia",
  "SubchondralFemur",
  "SubchondralTibia",
  "Synovium", 
  "IPFP", 
  "Meniscus",
  "BoneMarrowFemur", 
  "BoneMarrowTibia", 
  "GrowthPlateFemur",
  "GrowthPlateTibia",
  "CartilageFemur & CartilageTibia",
  "SubchondralFemur & SubchondralTibia",
  "BoneMarrowFemur & BoneMarrowTibia", 
  "GrowthPlateFemur & GrowthPlateTibia"
)
combo_df <- combo_df[combo_df$Combo %in% valid_combos, ]


# Step 3: Rank marker genes in each intersection
marker_rank_intersections <- bind_rows(lapply(seq_len(nrow(combo_df)), function(i) {
  combo_name <- combo_df$Combo[i]
  combo_tiss <- strsplit(combo_name, " & ", fixed=TRUE)[[1]]
  obj_list <- merged_by_tissue[combo_tiss]
  
  # Combine raw counts
  combined_mat <- do.call(cbind, lapply(obj_list, function(obj) {
    DefaultAssay(obj) <- "RawCounts"
    GetAssayData(obj, slot = "counts")
  }))
  
  # Gene ranking
  gene_means <- rowMeans(combined_mat)
  gene_means <- sort(gene_means, decreasing = TRUE)
  rank_pct <- rank(-gene_means, ties.method = "min") / length(gene_means) * 100
  
  # Keep only marker genes present
  gene_subset <- intersect(marker_genes, names(rank_pct))
  df <- data.frame(
    Intersection = combo_name,
    Gene = gene_subset,
    RankPercent = round(rank_pct[gene_subset], 2),
    stringsAsFactors = FALSE
  )
  df
}))


marker_rank_intersections$Assigned_Tissue <- dplyr::case_when(
  marker_rank_intersections$Gene %in% c("Sost", "Dmp1", "Mepe", "Bglap", "Alpl") ~ "Subchondral Bone",
  marker_rank_intersections$Gene %in% c("Acan", "Col2a1", "Prg4", "Comp", "Sox9") ~ "Cartilage",
  marker_rank_intersections$Gene %in% c("Adipoq", "Pparg", "Fabp4", "Lep", "Cidec") ~ "Fat",
  marker_rank_intersections$Gene %in% c("Cd55", "Cdh11", "Has1", "Prg4", "Lub") ~ "Synovium",
  marker_rank_intersections$Gene %in% c("Fmod", "Lum", "Col1a1", "Scx", "Tnmd") ~ "Meniscus",
  TRUE ~ NA_character_
)

marker_rank_intersections <- marker_rank_intersections %>%
  select(Gene, Assigned_Tissue, everything())


# Step 4: Reshape to wide
marker_rank_wide <- marker_rank_intersections %>%
  pivot_wider(names_from = Intersection, values_from = RankPercent)

# Show in RStudio and in HTML (if knitting)
cat("<details><summary><strong>Percentile Rank of Marker Genes Across Tissue Intersections</strong></summary>\n\n")
cat(knitr::kable(
  marker_rank_wide,
  format = "html",
  digits = 2,
  table.attr = "class='table table-striped table-bordered'",
  caption = "Lower rank % means higher expression"
))
cat("\n</details>\n")



```




## 9.2 Crossreferencing Tissue Specific Genes with Tabula Muris single cell sequencing data 



✅ Enrichment Criteria Applied (Tabula Muris and MCA):
For each tissue, a gene is marked as enriched (TRUE) if both of the following conditions are met:

Coverage threshold:

The gene is expressed in more than 5% of the cells in that tissue
→ pct_val > 5

Fold-change in expression:

The mean expression of that gene in the tissue is at least 1.5-fold higher than the median expression of that gene across all other tissues → mean_val > 1.5 * median_other

If either condition is not met, the gene is marked as not enriched (FALSE).


Enrichment logic:


min_pct = 5% of barcodes
min_fold = 1.5
Top5pct - within 5% top genes 

Technology and data type: single-cell RNA sequencing (scRNA-seq). Technical Approaches -> Microfluidic droplet-based 3'-end counting and FACS-based full-length transcript analysis. Sex-Balanced.


```{r CrossRefTissueTB, echo=TRUE, results='asis', message=FALSE, warning=FALSE}

# ------------------------
# 2. Prepare Gene List and Input Data
# ------------------------

my_genes <- single_tissue_genes_subset$Gene
gene_expr_summary <- single_tissue_genes_subset
gene_expr_mean_summary <- single_tissue_genes_subset

# Path to folder containing the Robj files
data_dir <- "C:/Users/dvazquez1/Desktop/spatial_transcriptomics/To_Analyze/data/CrossRef/Tabula_Muris"

# List of .Robj filenames to load
robj_files <- c(
  "Fat_mouse_TB_facs_Fat_seurat_tiss.Robj",
  "Lung_mouse_TB_facs_Lung_seurat_tiss.Robj",
  "Marrow_mouse_TB_facs_Marrow_seurat_tiss.Robj",
  "Skin_mouse_TB_facs_Skin_seurat_tiss.Robj",
  "Trachea_mouse_TB_facs_Trachea_seurat_tiss.Robj"
)

# Function to load and extract Seurat object from an Robj file
load_seurat_object <- function(file_path) {
  obj_name <- load(file_path)
  get(obj_name)
}

# ------------------------
# 3. Compute % Coverage
# ------------------------

for (robj_file in robj_files) {
  full_path <- file.path(data_dir, robj_file)
  seurat_obj <- load_seurat_object(full_path)
  seurat_obj <- UpdateSeuratObject(seurat_obj)

  short_label <- paste(strsplit(robj_file, "_")[[1]][1:3], collapse = "_")
  genes_in_obj <- intersect(my_genes, rownames(seurat_obj))

  if (length(genes_in_obj) == 0) {
    gene_expr_summary[[short_label]] <- NA
    next
  }

  count_mat <- GetAssayData(seurat_obj, slot = "counts")
  pct_expressed <- colMeans(t(count_mat[genes_in_obj, , drop = FALSE]) > 0) * 100

  pct_df <- data.frame(Gene = names(pct_expressed), Percent = pct_expressed, stringsAsFactors = FALSE)
  gene_expr_summary <- left_join(gene_expr_summary, pct_df, by = "Gene")
  colnames(gene_expr_summary)[ncol(gene_expr_summary)] <- short_label
}

# ------------------------
# 4. Compute Mean Expression
# ------------------------

for (robj_file in robj_files) {
  full_path <- file.path(data_dir, robj_file)
  seurat_obj <- load_seurat_object(full_path)
  seurat_obj <- UpdateSeuratObject(seurat_obj)

  short_label <- paste(strsplit(robj_file, "_")[[1]][1:3], collapse = "_")
  genes_in_obj <- intersect(my_genes, rownames(seurat_obj))

  if (length(genes_in_obj) == 0) {
    gene_expr_mean_summary[[paste0(short_label, "_level")]] <- NA
    next
  }

  count_mat <- GetAssayData(seurat_obj, slot = "counts")
  mean_expr <- Matrix::rowMeans(count_mat[genes_in_obj, , drop = FALSE])

  mean_expr <- round(mean_expr, 3)
  mean_expr <- format(mean_expr, scientific = FALSE)

  mean_df <- data.frame(Gene = names(mean_expr), Mean = mean_expr, stringsAsFactors = FALSE)
  gene_expr_mean_summary <- left_join(gene_expr_mean_summary, mean_df, by = "Gene")
  colnames(gene_expr_mean_summary)[ncol(gene_expr_mean_summary)] <- paste0(short_label, "_level")
}

# ------------------------
# 5. Merge and Enrichment Criteria
# ------------------------

combined_gene_expr <- left_join(gene_expr_summary, gene_expr_mean_summary, by = c("Intersection", "Gene"))

cols <- colnames(combined_gene_expr)
percent_cols <- grep("_level$", cols, value = TRUE, invert = TRUE)
level_cols <- grep("_level$", cols, value = TRUE)

ordered_cols <- c("Intersection", "Gene")
for (col in setdiff(percent_cols, c("Intersection", "Gene"))) {
  ordered_cols <- c(ordered_cols, col)
  level_col <- paste0(col, "_level")
  if (level_col %in% level_cols) {
    ordered_cols <- c(ordered_cols, level_col)
  }
}

combined_gene_expr <- combined_gene_expr %>%
  mutate(across(where(is.numeric), ~ round(.x, 4)))

# ------------------------
# 6. Top 5% Marker Flags
# ------------------------

top_fractions <- c(0.05)
tissue_prefixes <- unique(gsub("_level", "", level_cols))

for (tissue in tissue_prefixes) {
  mean_col <- paste0(tissue, "_level")
  if (!(mean_col %in% colnames(combined_gene_expr))) next

  gene_means <- as.numeric(combined_gene_expr[[mean_col]])
  names(gene_means) <- combined_gene_expr$Gene

  for (frac in top_fractions) {
    n_top <- ceiling(length(gene_means) * frac)
    top_genes <- names(sort(gene_means, decreasing = TRUE))[1:n_top]

    flag_col <- paste0(tissue, "_Top", frac * 100, "pct")
    combined_gene_expr[[flag_col]] <- combined_gene_expr$Gene %in% top_genes
  }
}


# ------------------------
# 6b. Rank Percentile Columns
# ------------------------

for (tissue in tissue_prefixes) {
  mean_col <- paste0(tissue, "_level")
  if (!(mean_col %in% colnames(combined_gene_expr))) next

  gene_means <- as.numeric(combined_gene_expr[[mean_col]])
  names(gene_means) <- combined_gene_expr$Gene

  # Rank genes in descending order (highest expression = rank 1)
  rank_vector <- rank(-gene_means, ties.method = "average")

  # Convert to percentile: (rank / total_genes) * 100
  rank_percent <- round((rank_vector / length(gene_means)) * 100, 4)

  # Store in new column
  rank_col <- paste0(tissue, "_RankPercent")
  combined_gene_expr[[rank_col]] <- rank_percent
}



# ------------------------
# 7. Enrichment with RankPercent <= 5
# ------------------------

min_pct <- 5
min_fold <- 1.5

for (tissue in tissue_prefixes) {
  pct_col     <- tissue
  mean_col    <- paste0(tissue, "_level")
  rank_col    <- paste0(tissue, "_RankPercent")
  enrich_col  <- paste0(tissue, "_enriched")

  combined_gene_expr[[enrich_col]] <- apply(combined_gene_expr, 1, function(row) {
    pct_val      <- as.numeric(row[[pct_col]])
    mean_val     <- as.numeric(row[[mean_col]])
    rank_percent <- as.numeric(row[[rank_col]])
    other_means  <- as.numeric(row[paste0(setdiff(tissue_prefixes, tissue), "_level")])
    median_other <- median(other_means, na.rm = TRUE)

    !is.na(pct_val) && !is.na(mean_val) && !is.na(rank_percent) &&
      pct_val > min_pct &&
      mean_val > (min_fold * median_other) &&
      rank_percent <= 5
  })
}

# ------------------------
# 8. Final Formatting
# ------------------------

enriched_cols <- grep("_enriched$", colnames(combined_gene_expr), value = TRUE)

combined_gene_expr <- combined_gene_expr %>%
  select(Intersection, Gene, all_of(enriched_cols), everything())

# ------------------------
# 9. HTML Output
# ------------------------

cat("<details><summary><strong>Click to expand Tabula Muris enrichment table</strong></summary><br>\n")
knitr::kable(combined_gene_expr, format = "html", digits = 4) %>% print()
cat("</details>\n")


```




## 9.3 Crossreferencing Tissue Specific Genes with Mouse Cell Atlas single cell sequencing data 

Enrichment logic:

min_pct = 5% of barcodes
min_fold = 1.5
Top5pct - within 5% top genes for the whole tissue
Technology and data type: single-cell RNA sequencing (scRNA-seq). Technical Profiles varies across different experiments, including cell sorting, lysis, barcoding, and library preparation.

```{r CrossRefTissueMCA, echo=TRUE, results='asis', message=FALSE, warning=FALSE}

# ------------------------------
# MCA Expression Enrichment Analysis with Top 5% Inclusion
# ------------------------------
library(dplyr)
library(readr)

# ------------------------------
# Load and process each MCA dataset
# ------------------------------
process_mca_dge <- function(dge_file, gene_file, barcode_file) {
  cat("\U0001F4DC Reading MCA dataset...\n")

  gene_df <- read.csv(gene_file, header = FALSE, stringsAsFactors = FALSE)
  genes <- as.character(gene_df$V2)

  dge <- read.csv(dge_file, header = FALSE)
  if (length(genes) != nrow(dge)) {
    stop("❌ Gene list and DGE matrix row counts do not match.")
  }
  rownames(dge) <- make.unique(genes)

  barcodes <- read.csv(barcode_file, stringsAsFactors = FALSE)
  colnames(dge) <- barcodes[[1]]

  rownames(barcodes) <- barcodes[[1]]
  barcodes <- barcodes[, -1, drop = FALSE]
  barcodes <- barcodes[colnames(dge), , drop = FALSE]

  dge_annotated <- as.data.frame(t(dge), stringsAsFactors = FALSE, check.names = FALSE)
  dge_annotated[] <- lapply(dge_annotated, as.numeric)

  celltype_column <- grep("Idents|celltype|annotation|cluster", colnames(barcodes), value = TRUE)[1]
  if (is.na(celltype_column)) stop("❌ No identifiable celltype column found in barcodes file.")
  cat("\U0001F9EC Using celltype column:", celltype_column, "\n")
  dge_annotated$celltype <- barcodes[[celltype_column]]

  cat("✅", nrow(dge_annotated), "cells,", ncol(dge_annotated) - 1, "genes\n")
  return(dge_annotated)
}

# ------------------------------
# Define datasets and input
# ------------------------------
base_dir <- "C:/Users/dvazquez1/Desktop/spatial_transcriptomics/To_Analyze/data/CrossRef/MCA"

mca_datasets <- list(
  MCA_BoneMarrow = process_mca_dge(
    file.path(base_dir, "Bone-Marrow-Mesenchyme/Marrow_mouse_MCA_Mesenchyme_dge.csv"),
    file.path(base_dir, "Bone-Marrow-Mesenchyme/Marrow_mouse_MCA_Mesenchyme_gene.csv"),
    file.path(base_dir, "Bone-Marrow-Mesenchyme/Marrow_mouse_MCA_Mesenchyme_barcodes_anno.csv")
  ),
  MCA_Calvaria = process_mca_dge(
    file.path(base_dir, "Neonatal-Calvaria/Calvaria_mouse_MCA_dge.csv"),
    file.path(base_dir, "Neonatal-Calvaria/Calvaria_mouse_MCA_gene.csv"),
    file.path(base_dir, "Neonatal-Calvaria/Calvaria_mouse_MCA_barcodes_anno.csv")
  ),
  MCA_Rib = process_mca_dge(
    file.path(base_dir, "Neonatal-Rib/Rib_mouse_MCA_dge.csv"),
    file.path(base_dir, "Neonatal-Rib/Rib_mouse_MCA_gene.csv"),
    file.path(base_dir, "Neonatal-Rib/Rib_mouse_MCA_barcodes_anno.csv")
  )
)

# ------------------------------
# Gene list to analyze
# ------------------------------
my_genes <- single_tissue_genes_subset$Gene

# ------------------------------
# Compute % Expression and Mean Expression
# ------------------------------
gene_expr_MCA_pct <- single_tissue_genes_subset

mean_expr_ranks <- list()

for (label in names(mca_datasets)) {
  dge_df <- mca_datasets[[label]]
  available_genes <- intersect(my_genes, colnames(dge_df))

  if (length(available_genes) == 0) {
    gene_expr_MCA_pct[[label]] <- NA
    next
  }

  pct <- colMeans(dge_df[, available_genes, drop = FALSE] > 0) * 100
  pct_df <- data.frame(Gene = names(pct), Percent = round(pct, 4))
  gene_expr_MCA_pct <- left_join(gene_expr_MCA_pct, pct_df, by = "Gene")
  colnames(gene_expr_MCA_pct)[ncol(gene_expr_MCA_pct)] <- label

  mean_vals <- colMeans(dge_df[, available_genes, drop = FALSE])
  mean_df <- data.frame(Gene = names(mean_vals), Mean = round(mean_vals, 4))
  colnames(mean_df)[2] <- paste0(label, "_level")

  # Rank percent
  all_means <- colMeans(dge_df[, colnames(dge_df) != "celltype"], na.rm = TRUE)
  rank_percent <- rank(-all_means, ties.method = "average") / length(all_means) * 100
  rank_df <- data.frame(Gene = names(rank_percent), RankPercent = rank_percent)
  colnames(rank_df)[2] <- paste0(label, "_RankPercent")

  mean_expr_ranks[[label]] <- list(mean = mean_df, rank = rank_df)
}

# Merge all mean expression and rank data
gene_expr_MCA_mean <- single_tissue_genes_subset
for (label in names(mean_expr_ranks)) {
  gene_expr_MCA_mean <- left_join(gene_expr_MCA_mean, mean_expr_ranks[[label]]$mean, by = "Gene")
  gene_expr_MCA_mean <- left_join(gene_expr_MCA_mean, mean_expr_ranks[[label]]$rank, by = "Gene")
}

# ------------------------------
# Define Top5% and Enrichment
# ------------------------------
top_fractions <- c(0.05)
tissues <- unique(gsub("_level", "", grep("_level$", colnames(gene_expr_MCA_mean), value = TRUE)))

for (tissue in tissues) {
  mean_col <- paste0(tissue, "_level")
  rank_col <- paste0(tissue, "_RankPercent")
  flag_col <- paste0(tissue, "_Top5pct")

  gene_expr_MCA_mean[[flag_col]] <- gene_expr_MCA_mean[[rank_col]] <= 5
}

# ------------------------------
# Merge, Enrichment Criteria
# ------------------------------
combined_gene_expr_MCA <- left_join(gene_expr_MCA_pct, gene_expr_MCA_mean, by = c("Intersection", "Gene"))

min_pct <- 5
min_fold <- 1.5
for (tissue in tissues) {
  pct_col <- tissue
  mean_col <- paste0(tissue, "_level")
  rank_col <- paste0(tissue, "_Top5pct")

  combined_gene_expr_MCA[[paste0(tissue, "_enriched")]] <- apply(combined_gene_expr_MCA, 1, function(row) {
    pct_val <- as.numeric(row[[pct_col]])
    mean_val <- as.numeric(row[[mean_col]])
    is_top5 <- as.logical(row[[rank_col]])
    other_means <- as.numeric(row[paste0(setdiff(tissues, tissue), "_level")])
    median_other <- median(other_means, na.rm = TRUE)

    !is.na(pct_val) && !is.na(mean_val) && !is.na(is_top5) &&
      pct_val > min_pct && mean_val > (min_fold * median_other) && is_top5
  })
}

# ------------------------------
# Output
# ------------------------------
enriched_cols <- grep("_enriched$", colnames(combined_gene_expr_MCA), value = TRUE)
combined_gene_expr_MCA <- combined_gene_expr_MCA %>%
  select(Intersection, Gene, all_of(enriched_cols), everything()) %>%
  mutate(across(where(is.numeric), ~ round(.x, 4)))

cat("<details><summary><strong>Click to expand MCA enrichment table</strong></summary><br>\n")
knitr::kable(combined_gene_expr_MCA, format = "html", digits = 4) %>% print()
cat("</details>\n")



```




## 9.4 Crossreferencing Tissue Specific Genes with Synovium GEO sequencing data (Guilak - GSE279621)


Enrichment logic:

min_pct = 5% of barcodes
Top5pct - within 5% top genes when combining all samples (using the whole tissue as for MCA and Tabula Muris as they all are single cell seq), which ends up being also for half or more than half of samples (with few exceptions). 

Technology and data type: single-cell RNA sequencing (scRNA-seq) of synovium immune cells from DMM left knees and non-DMM (contrlateral) right knees of control mice (normal diet).Illumina NovaSeq X and 10x Genomics

```{r CrossRefTissueGEO, echo=TRUE, results='asis', message=FALSE, warning=FALSE}

library(Seurat)
library(Matrix)
library(dplyr)
library(readr)

# Define genes of interest
my_genes <- single_tissue_genes_subset$Gene

# Path and sample list
base_dir <- "C:/Users/dvazquez1/Desktop/spatial_transcriptomics/To_Analyze/data/CrossRef/GEO/Synovium_mouse_Guilak_GSE279621_RAW"
samples <- c(
  "GSM8577119_MGI2461_10x_GLAA_DMMControlLeft4",
  "GSM8577120_MGI2461_GLAA-DMM-DMMControl4Right",
  "GSM8577121_MGI2461_GLAA-DMM-DMMControl5Left",
  "GSM8577122_MGI2461_GLAA-DMM-DMMControl5Right",
  "GSM8577123_MGI2461_GLAA-DMM-DMMControl6Left",
  "GSM8577124_MGI2461_GLAA-DMM-DMMControl6Right"
)

# Load and create list of Seurat objects
seurat_list <- list()
for (s in samples) {
  mtx_file <- file.path(base_dir, paste0(s, "_matrix.mtx.gz"))
  barcodes_file <- file.path(base_dir, paste0(s, "_barcodes.tsv.gz"))
  features_file <- file.path(base_dir, paste0(s, "_features.tsv.gz"))

  counts <- readMM(mtx_file)
  genes <- read_tsv(features_file, col_names = FALSE)[[2]]
  barcodes <- read_tsv(barcodes_file, col_names = FALSE)[[1]]

  rownames(counts) <- make.unique(genes)
  colnames(counts) <- barcodes

  seu <- CreateSeuratObject(counts = counts, assay = "RNA", project = s)
  seurat_list[[s]] <- seu
}

# Merge all samples
merged_seurat <- merge(seurat_list[[1]], y = seurat_list[-1], add.cell.ids = samples)
DefaultAssay(merged_seurat) <- "RNA"

# Combine raw count layers
layers <- Layers(merged_seurat[["RNA"]])
raw_counts_all <- Reduce(
  f = function(a, b) cbind(a, LayerData(merged_seurat[["RNA"]], layer = b)),
  x = layers[-1],
  init = LayerData(merged_seurat[["RNA"]], layer = layers[1])
)

# Gene-level summary across all merged samples
gene_means <- rowMeans(raw_counts_all)
gene_detect_pct <- rowSums(raw_counts_all > 0) / ncol(raw_counts_all) * 100
rank_vector <- rank(-gene_means, ties.method = "average")
rank_percent <- rank_vector / length(rank_vector) * 100
n_top5 <- ceiling(length(gene_means) * 0.05)
top5_genes_overall <- names(sort(gene_means, decreasing = TRUE)[1:n_top5])

gene_stats_all <- data.frame(
  Gene = names(gene_means),
  Mean_Count = round(gene_means, 4),
  Coverage_Pct = round(gene_detect_pct, 2),
  Rank_Percent = round(rank_percent, 4),
  In_Top5 = names(gene_means) %in% top5_genes_overall,
  stringsAsFactors = FALSE
)

# Compute pseudobulk and per-sample top5% status
sample_ids <- sapply(strsplit(colnames(raw_counts_all), "_"), `[`, 1)

unique_samples <- unique(sample_ids)
pseudobulk_counts <- matrix(0, nrow = nrow(raw_counts_all), ncol = length(unique_samples))
rownames(pseudobulk_counts) <- rownames(raw_counts_all)
colnames(pseudobulk_counts) <- unique_samples

for (i in seq_along(unique_samples)) {
  sample <- unique_samples[i]
  col_idx <- which(sample_ids == sample)
  pseudobulk_counts[, i] <- Matrix::rowSums(raw_counts_all[, col_idx])
}

# Per-sample RankPercent matrix
rank_percent_per_sample <- apply(pseudobulk_counts, 2, function(x) {
  rp <- rank(-x, ties.method = "average") / length(x) * 100
  return(round(rp, 4))
})

# Build top5 count table explicitly
top5_df <- data.frame(
  Gene = rownames(rank_percent_per_sample),
  Top5_Count = rowSums(rank_percent_per_sample <= 5)
)

# Build output table
top5_df <- data.frame(
  Gene = rownames(pseudobulk_counts),
  Top5_Count = rowSums(rank_percent_per_sample <= 5)
)

synovium_geo_df <- gene_stats_all %>%
  filter(Gene %in% my_genes) %>%
  left_join(top5_df, by = "Gene") %>%
  mutate(
    Top5_Sample_Count = paste0(Top5_Count, "/", length(samples)),
    Enriched_Synovium = In_Top5,
    Enriched_Synovium_HalfOrMore = Top5_Count >= (length(samples) / 2)
  ) %>%
  select(-Top5_Count)  # ← still remove this column unless needed



# Add per-sample RankPercent and expression
for (i in seq_along(samples)) {
  sample_name <- samples[i]
  rank_col <- paste0(sample_name, "_RankPercent")
  expr_col <- paste0(sample_name, "_Expr")

  synovium_geo_df[[rank_col]] <- round(rank_percent_per_sample[match(synovium_geo_df$Gene, rownames(rank_percent_per_sample)), i], 4)
  synovium_geo_df[[expr_col]] <- round(pseudobulk_counts[match(synovium_geo_df$Gene, rownames(pseudobulk_counts)), i], 4)
}

# Rename long sample column names to shorter ones
colnames(synovium_geo_df) <- gsub(
  pattern = "GSM\\d+_MGI2461_(10x_)?GLAA(-DMM)?-?", 
  replacement = "", 
  x = colnames(synovium_geo_df)
)

# Merge with annotation
crossref_geo <- single_tissue_genes_subset %>%
  left_join(synovium_geo_df, by = "Gene")

# Display as collapsible HTML table
cat("<details><summary><strong>Click to expand Synovium GEO crossref with per-sample RankPercent</strong></summary><br>\n")
knitr::kable(crossref_geo, format = "html", digits = 4) %>% print()
cat("</details>\n")




```


## 9.5 Crossreferencing Tissue Specific Genes with Ganglia GEO sequencing data (Collins - GSE287251)


Treatment: EVFN1, EVFN2 -> Endogenous visceral fat, no surgery

Enrichment criteria:

Top5pct - within 5% top genes in more than half of samples (so all, since we only got 2)


Technology and data type: Bulk RNA sequencing of control ganglia tissue (EVFN treatment). Illumina NovaSeq 6000


```{r CrossRefTissueGEOcollins, echo=TRUE, results='asis', message=FALSE, warning=FALSE}

library(readr)
library(dplyr)

# -------------------------
# 1. Load GEO CPM data
# -------------------------
geo_file <- "C:/Users/dvazquez1/Desktop/spatial_transcriptomics/To_Analyze/data/CrossRef/GEO/Ganglia_mouse_Collins_GSE287251_CPM.csv.gz"
geo_data <- read_csv(geo_file)

# Rename first column
colnames(geo_data)[1] <- "Gene"
geo_data$Gene <- as.character(geo_data$Gene)

# -------------------------
# 2. Prepare gene list
# -------------------------
single_tissue_genes_subset$Gene <- as.character(single_tissue_genes_subset$Gene)
my_genes <- single_tissue_genes_subset$Gene

# Merge all genes with annotation table (don't filter yet)
geo_expression_table <- single_tissue_genes_subset %>%
  left_join(geo_data, by = "Gene")

# -------------------------
# 3. Define EVFN samples
# -------------------------
evfn_samples <- c("EVFN1", "EVFN2")
names(evfn_samples) <- c("Ganglia_Mouse_1", "Ganglia_Mouse_2")

# -------------------------
# 4. Analyze each sample using all genes to rank
# -------------------------
evfn_results <- list()

for (sample_name in names(evfn_samples)) {
  sample_col <- evfn_samples[[sample_name]]

  # Compute rank from original full geo_data
  gene_ranks <- geo_data %>%
    select(Gene, !!sym(sample_col)) %>%
    mutate(
      RankPercent = rank(-.data[[sample_col]], ties.method = "average") / n() * 100,
      Top5 = RankPercent <= 5
    )

  # Merge back into gene subset + annotation
  temp_table <- single_tissue_genes_subset %>%
    left_join(gene_ranks, by = "Gene") %>%
    mutate(
      !!paste0(sample_name, "_CPM") := .data[[sample_col]],
      !!paste0(sample_name, "_RankPercent") := round(.data$RankPercent, 4),
      !!paste0(sample_name, "_Top5pct") := .data$Top5,
      !!paste0(sample_name, "_Enriched") := .data$Top5
    ) %>%
    select(Intersection, Gene,
           ends_with("_CPM"),
           ends_with("_RankPercent"),
           ends_with("_Top5pct"),
           ends_with("_Enriched"))

  evfn_results[[sample_name]] <- temp_table
}



# -------------------------
# 5. Combine all results
# -------------------------
final_evfn <- Reduce(function(x, y) left_join(x, y, by = c("Intersection", "Gene")), evfn_results)

# -------------------------
# 6. Add Top5_Sample_Count and Ganglia_Enriched
# -------------------------
top5_cols <- grep("_Top5pct$", names(final_evfn), value = TRUE)

final_evfn <- final_evfn %>%
  mutate(
    Top5_Sample_Count = rowSums(across(all_of(top5_cols), ~ .x == TRUE)),
    Ganglia_Enriched  = Top5_Sample_Count > (length(evfn_samples) / 2)
  )

# -------------------------
# 7. Output as collapsible HTML table
# -------------------------
cat("<details><summary><strong>Click to expand Ganglia EVFN enrichment summary</strong></summary><br>\n")
knitr::kable(final_evfn, format = "html", digits = 4) %>% print()
cat("</details>\n")



```


## 9.6 Crossreferencing Tissue Specific Genes with GEO sequencing data (MLYO4 cells - GSE254053)

Enrichment criteria:

Top5pct - within 5% top genes in half or more than half of samples

Technology and data type: Bulk RNA sequencing of control MLYO4 cells. BGISEQ-500

```{r CrossRefTissueGEOMLOY4, echo=TRUE, results='asis', message=FALSE, warning=FALSE}

library(readxl)
library(dplyr)

# -------------------------
# 1. Load GSE254053 data
# -------------------------
mloyo_file <- "C:/Users/dvazquez1/Desktop/spatial_transcriptomics/To_Analyze/data/CrossRef/GEO/MLOY4cells_Wang_GSE254053_gene_expression/GSE254053_gene_expression.xlsx"
mloyo_data <- read_excel(mloyo_file)

# Rename gene column
colnames(mloyo_data)[colnames(mloyo_data) == "gene_symbol"] <- "Gene"
mloyo_data$Gene <- as.character(mloyo_data$Gene)

# -------------------------
# 2. Prepare gene list
# -------------------------
single_tissue_genes_subset$Gene <- as.character(single_tissue_genes_subset$Gene)
my_genes <- single_tissue_genes_subset$Gene
mloyo_subset <- mloyo_data %>% filter(Gene %in% my_genes)

# -------------------------
# 3. Select NC sample columns
# -------------------------
read_cols <- c("read_count_NC1", "read_count_NC2", "read_count_NC3", "read_count_NC4")
mloyo_subset <- mloyo_subset %>% select(Gene, all_of(read_cols))

# -------------------------
# 4. Merge with annotation table
# -------------------------
mloyo_expression_table <- single_tissue_genes_subset %>%
  left_join(mloyo_subset, by = "Gene")

# Round numeric values
mloyo_expression_table[, read_cols] <- mloyo_expression_table[, read_cols] %>%
  mutate(across(everything(), ~ round(.x, 4)))

# -------------------------
# 5. Compute RankPercent, Top5pct, and per-sample enrichment
# -------------------------
for (sample in read_cols) {
  # Rank across ALL genes in the full dataset
  all_ranks <- rank(-mloyo_data[[sample]], ties.method = "average")
  all_rank_pct <- all_ranks / length(all_ranks) * 100
  names(all_rank_pct) <- mloyo_data$Gene

  # Map the rank percent to your selected genes
  rank_pct <- all_rank_pct[mloyo_expression_table$Gene]
  top5_flag <- rank_pct <= 5

  mloyo_expression_table[[paste0(sample, "_RankPercent")]] <- round(rank_pct, 4)
  mloyo_expression_table[[paste0(sample, "_Top5pct")]] <- top5_flag
  mloyo_expression_table[[paste0(sample, "_Enriched")]] <- top5_flag
}

# Rename derived columns: remove 'read_count_' prefix from RankPercent, Top5pct, Enriched
colnames(mloyo_expression_table) <- gsub(
  pattern = "^read_count_(NC\\d+)_(RankPercent|Top5pct|Enriched)$",
  replacement = "\\1_\\2",
  x = colnames(mloyo_expression_table)
)

# -------------------------
# 6. Combined enrichment: enriched in ≥ half of the samples 
# -------------------------
top5_cols <- grep("_Top5pct$", colnames(mloyo_expression_table), value = TRUE)
n_samples <- length(top5_cols)

mloyo_expression_table <- mloyo_expression_table %>%
  rowwise() %>%
  mutate(
    Top5_Count = sum(c_across(all_of(top5_cols))),
    Top5_Sample_Count = paste0(Top5_Count, "/", n_samples),
    MLO_Enriched = Top5_Count >= (n_samples / 2)
  ) %>%
  ungroup() %>%
  select(-Top5_Count)


# -------------------------
# 7. Subset for display
# -------------------------
mloyo_display <- mloyo_expression_table %>%
  select(Intersection, Gene, MLO_Enriched, Top5_Sample_Count, everything())

# -------------------------
# 8. Collapsible HTML output
# -------------------------
cat("<details><summary><strong>Click to expand MLO-Y4 Top5% enrichment table</strong></summary><br>\n")
knitr::kable(mloyo_display, format = "html", digits = 4) %>% print()
cat("</details>\n")

```


## 9.7 Crossreferencing Tissue Specific Genes with GEO sequencing data (Mouse Cartilage - GSE288320)

Enrichment criteria:

Top5pct - within 5% top genes 

Technology and data type: Bulk RNA sequencing of DMM WT knee cartilage samples. Illumina NextSeq 500

```{r CrossRefTissueGEOCartilageMouse, echo=TRUE, results='asis', message=FALSE, warning=FALSE}

library(readr)
library(dplyr)

# -------------------------
# 1. Load GSE288320 gene count data
# -------------------------
gse_file <- "C:/Users/dvazquez1/Desktop/spatial_transcriptomics/To_Analyze/data/CrossRef/GEO/Cartilage_mouse_Sambale_GSE288320_gene_count_matrix_trpc1dmm_Mouse/GSE288320_gene_count_matrix_trpc1dmm_Mouse.tsv"
gse_data <- read_tsv(gse_file)

# Rename gene symbol column
colnames(gse_data)[colnames(gse_data) == "GeneName"] <- "Gene"
gse_data$Gene <- as.character(gse_data$Gene)

# -------------------------
# 2. Prepare gene list
# -------------------------
single_tissue_genes_subset$Gene <- as.character(single_tissue_genes_subset$Gene)
my_genes <- single_tissue_genes_subset$Gene

# -------------------------
# 3. Filter to genes of interest
# -------------------------
gse_subset <- gse_data %>%
  filter(Gene %in% my_genes)

# -------------------------
# 4. Keep only WT columns for crossref
# -------------------------
wt_cols <- c("DMMWTM1370", "DMMWTM1372", "DMMWTM1725", "DMMWTM1726")
gse_subset <- gse_subset %>% select(Gene, all_of(wt_cols))

# -------------------------
# 5. Merge into annotation table
# -------------------------
gse_expression_table <- single_tissue_genes_subset %>%
  left_join(gse_subset, by = "Gene")

# Round numeric values
gse_expression_table[, wt_cols] <- gse_expression_table[, wt_cols] %>%
  mutate(across(everything(), ~ round(.x, 4)))

# -------------------------
# 6. Compute RankPercent, Top5pct, and per-sample enrichment
# -------------------------
for (sample in wt_cols) {
  all_ranks <- rank(-gse_data[[sample]], ties.method = "average")
  all_rank_pct <- all_ranks / length(all_ranks) * 100
  names(all_rank_pct) <- gse_data$Gene
  
  rank_pct <- all_rank_pct[gse_expression_table$Gene]
  top5_flag <- rank_pct <= 5

  gse_expression_table[[paste0(sample, "_RankPercent")]] <- round(rank_pct, 4)
  gse_expression_table[[paste0(sample, "_Top5pct")]] <- top5_flag
  gse_expression_table[[paste0(sample, "_Enriched")]] <- top5_flag
}

# -------------------------
# 7. Combined enrichment: enriched in ≥ half of the samples
# -------------------------
top5_cols <- grep("_Top5pct$", colnames(gse_expression_table), value = TRUE)
n_samples <- length(top5_cols)

gse_expression_table <- gse_expression_table %>%
  rowwise() %>%
  mutate(
    Top5_Count = sum(c_across(all_of(top5_cols))),
    Top5_Sample_Count = paste0(Top5_Count, "/", n_samples),
    Cartilage_Enriched = Top5_Count >= (n_samples / 2)
  ) %>%
  ungroup() %>%
  select(-Top5_Count)

# -------------------------
# 8. Subset and order columns for output
# -------------------------
gse_display <- gse_expression_table %>%
  select(Intersection, Gene, Cartilage_Enriched, Top5_Sample_Count, everything())

# -------------------------
# 9. Collapsible HTML output
# -------------------------
cat("<details><summary><strong>Click to expand Cartilage enrichment table (GSE288320)</strong></summary><br>\n")
knitr::kable(gse_display, format = "html", digits = 4) %>% print()
cat("</details>\n")
```





## 9.8 Crossreferencing Tissue Specific Genes with GEO sequencing data (Mouse Condyle - GSE267616)

Enrichment logic:

min_pct = 5% of barcodes
Top5pct - within 5% top genes when combining all samples (using the whole tissue as for MCA and Tabula Muris as they all are single cell seq), which ends up being also for half or more than half of samples. 

Technology and data type: single-cell RNA sequencing (scRNA-seq) of femoral condyles from mice (normal and bipedal) with and without bilateral ovariectomy (OA). 5 mice in each group at 22 weeks of age. Created single-cell atlas of the osteochondral composite tissue, including chondrocytes, endothelia cells, osteoblasts, progenitor cells, and so on. Illumina NovaSeq 6000

```{r CrossRefTissueGEOCondyleMouse, echo=TRUE, results='asis', message=FALSE, warning=FALSE}


library(Seurat)
library(Matrix)
library(dplyr)
library(readr)

# Define genes of interest
my_genes <- single_tissue_genes_subset$Gene

# Path and full sample list (including bipedal and ovariectomy groups)
base_dir <- "C:/Users/dvazquez1/Desktop/spatial_transcriptomics/To_Analyze/data/CrossRef/GEO/Condyle_mouse_Liu_GSE267616_RAW"
samples <- c(
  "GSM8270219_MN",
  "GSM8270220_MB",
  "GSM8270221_FN",
  "GSM8270222_FB",
  "GSM8270223_FO",
  "GSM8270224_FBO"
)

# Load and combine raw count matrices directly (no Seurat)
raw_counts_list <- list()

for (s in samples) {
  mtx_file <- file.path(base_dir, paste0(s, "_matrix.mtx.gz"))
  features_file <- file.path(base_dir, paste0(s, "_features.tsv.gz"))
  barcodes_file <- file.path(base_dir, paste0(s, "_barcodes.tsv.gz"))

  counts <- readMM(gzfile(mtx_file))
  genes <- read_tsv(gzfile(features_file), col_names = FALSE)[[2]]
  barcodes <- read_tsv(gzfile(barcodes_file), col_names = FALSE)[[1]]

  rownames(counts) <- make.unique(genes)
  colnames(counts) <- paste0(s, "_", barcodes)

  raw_counts_list[[s]] <- counts
  gc()
}

# Combine into a single sparse matrix (safely and efficiently)
chunked_cbind <- function(mat_list, chunk_size = 2) {
  out <- mat_list[[1]]
  for (i in seq(2, length(mat_list), by = chunk_size)) {
    chunk_end <- min(i + chunk_size - 1, length(mat_list))
    for (j in i:chunk_end) {
      gc()
      out <- cbind(out, mat_list[[j]])
    }
  }
  return(out)
}

raw_counts_all <- chunked_cbind(raw_counts_list, chunk_size = 2)


# Gene-level summary
all_gene_means <- rowMeans(raw_counts_all)
gene_detect_pct <- rowSums(raw_counts_all > 0) / ncol(raw_counts_all) * 100
rank_vector <- rank(-all_gene_means, ties.method = "average")
rank_percent <- rank_vector / length(rank_vector) * 100
n_top5 <- ceiling(length(all_gene_means) * 0.05)
top5_genes_overall <- names(sort(all_gene_means, decreasing = TRUE)[1:n_top5])

gene_stats_all <- data.frame(
  Gene = names(all_gene_means),
  Mean_Count = round(all_gene_means, 4),
  Coverage_Pct = round(gene_detect_pct, 2),
  Rank_Percent = round(rank_percent, 4),
  In_Top5 = names(all_gene_means) %in% top5_genes_overall,
  stringsAsFactors = FALSE
)

# Pseudobulk per-sample
sample_ids <- sapply(strsplit(colnames(raw_counts_all), "_"), `[`, 1)
library(Matrix)

# Initialize pseudobulk matrix with same number of genes, and one column per sample
unique_samples <- unique(sample_ids)
pseudobulk_counts <- matrix(0, nrow = nrow(raw_counts_all), ncol = length(unique_samples))
rownames(pseudobulk_counts) <- rownames(raw_counts_all)
colnames(pseudobulk_counts) <- unique_samples

# Aggregate without transposing or densifying
for (i in seq_along(unique_samples)) {
  idx <- which(sample_ids == unique_samples[i])
  pseudobulk_counts[, i] <- Matrix::rowSums(raw_counts_all[, idx, drop = FALSE])
}


# RankPercent per sample
rank_percent_per_sample <- apply(pseudobulk_counts, 2, function(x) {
  rp <- rank(-x, ties.method = "average") / length(x) * 100
  return(round(rp, 4))
})

# Build top5 table explicitly
top5_df <- data.frame(
  Gene = rownames(rank_percent_per_sample),
  Top5_Count = rowSums(rank_percent_per_sample <= 5)
)

# Build output table
condyle_geo_df <- gene_stats_all %>%
  filter(Gene %in% my_genes) %>%
  left_join(top5_df, by = "Gene") %>%
  mutate(
    Top5_Sample_Count = paste0(Top5_Count, "/", length(samples)),
    Enriched_Condyle = In_Top5,
    Enriched_Condyle_HalfOrMore = Top5_Count >= (length(samples) / 2)
  ) %>%
  select(-Top5_Count)


# Per-sample RankPercent and expression
for (i in seq_along(samples)) {
  sample_name <- samples[i]
  rank_col <- paste0(sample_name, "_RankPercent")
  expr_col <- paste0(sample_name, "_Expr")

  matched_genes <- match(condyle_geo_df$Gene, rownames(rank_percent_per_sample))

  # Safely handle unmatched genes
  condyle_geo_df[[rank_col]] <- ifelse(
    is.na(matched_genes),
    NA,
    round(rank_percent_per_sample[matched_genes, i], 4)
  )

  condyle_geo_df[[expr_col]] <- ifelse(
    is.na(matched_genes),
    NA,
    round(pseudobulk_counts[matched_genes, i], 4)
  )
}


# Rename samples to short labels
colnames(condyle_geo_df) <- gsub(
  pattern = "GSM\\d+_", replacement = "", colnames(condyle_geo_df)
)

# Merge with annotation
crossref_condyle <- single_tissue_genes_subset %>%
  left_join(condyle_geo_df, by = "Gene")

# Display as collapsible HTML table
cat("<details><summary><strong>Click to expand Condyle GEO crossref with per-sample RankPercent</strong></summary><br>\n")
knitr::kable(crossref_condyle, format = "html", digits = 4) %>% print()
cat("</details>\n")



```





## 9.9 Crossreferencing Tissue Specific Genes with GEO sequencing data (Mouse Synovium - GSE220167)

Enrichment logic:

min_pct = 5% of barcodes
Top5pct - within 5% top genes when combining all samples (using the whole tissue as for MCA and Tabula Muris as they all are single cell seq), which ends up being also for half or more than half of samples. 

Technology and data type: single-cell RNA sequencing (scRNA-seq) of immune (Cd45+) cells from right injured and left un-injured tibial knees of 10-week-old MRL/MpJ mice. Illumina NextSeq 500 


```{r CrossRefTissueGEOSynovium2, echo=TRUE, results='asis', message=FALSE, warning=FALSE}

# =============================
# GENERALIZED MCCOOL CROSSREF
# =============================

library(Matrix)
library(dplyr)
library(readr)
library(Seurat)

# ---- USER INPUT ----

# Path to McCool GEO data
base_dir <- "C:/Users/dvazquez1/Desktop/spatial_transcriptomics/To_Analyze/data/CrossRef/GEO/Synovium_mouse_McCool_GSE220167_RAW"

# Samples you want to include
samples <- c("D0", "D1")  

# Your gene list
my_genes <- single_tissue_genes_subset$Gene

# ---- PREALLOCATE STORAGE ----
raw_counts_list <- list()
pseudobulk_counts <- list()
rank_percent_per_sample <- list()

# ---- READ EACH SAMPLE ----
for (s in samples) {
  mtx_file <- gzfile(file.path(base_dir, paste0(s, "_matrix.mtx.gz")))
  features_file <- gzfile(file.path(base_dir, paste0(s, "_features.tsv.gz")))
  barcodes_file <- gzfile(file.path(base_dir, paste0(s, "_barcodes.tsv.gz")))

  counts <- readMM(mtx_file)
  genes <- read_tsv(features_file, col_names = FALSE)[[2]]
  barcodes <- read_tsv(barcodes_file, col_names = FALSE)[[1]]

  rownames(counts) <- make.unique(genes)
  colnames(counts) <- paste0(s, "_", barcodes)

  raw_counts_list[[s]] <- counts

  pseudobulk_counts[[s]] <- matrix(Matrix::rowSums(counts), ncol = 1)
  rownames(pseudobulk_counts[[s]]) <- rownames(counts)
  colnames(pseudobulk_counts[[s]]) <- s

  rps <- rank(-pseudobulk_counts[[s]][, 1], ties.method = "average") / nrow(pseudobulk_counts[[s]]) * 100
  rank_percent_per_sample[[s]] <- rps
}

# ---- COMBINE EVERYTHING ----
combined_counts <- do.call(cbind, pseudobulk_counts)
combined_rank <- do.call(cbind, rank_percent_per_sample)
combined_cells <- do.call(cbind, raw_counts_list)

# ---- GENE STATS ----
gene_means <- rowMeans(combined_counts)
gene_detect_pct <- rowSums(combined_cells > 0) / ncol(combined_cells) * 100
rank_vector <- rank(-gene_means, ties.method = "average")
rank_percent <- rank_vector / length(rank_vector) * 100
n_top5 <- ceiling(length(gene_means) * 0.05)
top5_genes_overall <- names(sort(gene_means, decreasing = TRUE)[1:n_top5])

gene_stats_all <- data.frame(
  Gene = names(gene_means),
  Mean_Count = round(gene_means, 4),
  Coverage_Pct = round(gene_detect_pct, 2),
  Rank_Percent = round(rank_percent, 4),
  In_Top5 = names(gene_means) %in% top5_genes_overall,
  stringsAsFactors = FALSE
)

top5_df <- data.frame(
  Gene = rownames(combined_rank),
  Top5_Count = rowSums(combined_rank <= 5)
)

# ---- FINAL OUTPUT ----
synovium_mccool_df <- gene_stats_all %>%
  filter(Gene %in% my_genes) %>%
  left_join(top5_df, by = "Gene") %>%
  mutate(
    Top5_Sample_Count = paste0(Top5_Count, "/", length(samples)),
    Enriched_Synovium = In_Top5,
    Enriched_Synovium_HalfOrMore = Top5_Count >= (length(samples) / 2)
  ) %>%
  select(-Top5_Count)

for (s in samples) {
  synovium_mccool_df[[paste0(s, "_RankPercent")]] <-
    round(combined_rank[match(synovium_mccool_df$Gene, rownames(combined_rank)), s], 4)
  synovium_mccool_df[[paste0(s, "_Expr")]] <-
    round(combined_counts[match(synovium_mccool_df$Gene, rownames(combined_counts)), s], 4)
}

# ---- MERGE WITH ANNOTATION ----
crossref_mccool <- single_tissue_genes_subset %>%
  left_join(synovium_mccool_df, by = "Gene")

# ---- DISPLAY COLLAPSIBLE TABLE ----
cat("<details><summary><strong>Click to expand Synovium McCool GEO crossref (all days)</strong></summary><br>\n")
knitr::kable(crossref_mccool, format = "html", digits = 4) %>% print()
cat("</details>\n")




```


## 9.10 Summary Crosreference Table

```{r CrossRefSummary, echo=TRUE, results='asis', message=FALSE, warning=FALSE}

# ============================================
# ✅ Check Consistency Across All Gene Tables
# ============================================

# Define all final tables (must be in memory)
all_tables <- list(
  combined_gene_expr,        # Tabula Muris
  combined_gene_expr_MCA,    # MCA
  crossref_geo,              # Synovium (Guilak)
  final_evfn,                # Ganglia
  mloyo_display,             # MLOY4
  gse_display,               # Cartilage
  crossref_condyle,          # Condyle
  crossref_mccool            # Synovium (McCool)
)

# Extract and check Intersection-Gene keys
all_gene_keys <- lapply(all_tables, function(df) {
  df %>% select(Gene) %>% distinct()
})
gene_key_consistent <- Reduce(function(x, y) full_join(x, y, by = "Gene"), all_gene_keys)

# Preview inconsistent rows (optional)
cat("✅ Number of unique genes across all tables:", nrow(gene_key_consistent), "\n")

# ============================================
# ✅ Extract Enrichment Columns from Each Table
# ============================================

# Helper to extract enrichment columns from each table
extract_enrichment_col <- function(df, tissue_label, enrich_col) {
  df %>%
    select(Intersection, Gene, {{enrich_col}}) %>%
    rename_with(~ paste0("Enriched_", tissue_label), {{ enrich_col }})

}


# ============================================
# ✅ Extract individual enrichment columns for Tabula and MCA
# ============================================

# Tabula Muris: extract individual *_enriched columns
tabula_enrich <- combined_gene_expr %>%
  select(Intersection, Gene,
         Fat_mouse_TB_enriched,
         Lung_mouse_TB_enriched,
         Marrow_mouse_TB_enriched,
         Skin_mouse_TB_enriched,
         Trachea_mouse_TB_enriched)
colnames(tabula_enrich)[-(1:2)] <- paste0("Enriched_", gsub("_enriched", "", colnames(tabula_enrich)[-(1:2)]))

# MCA: extract individual *_enriched columns
mca_enrich <- combined_gene_expr_MCA %>%
  select(Intersection, Gene,
         MCA_BoneMarrow_enriched,
         MCA_Calvaria_enriched,
         MCA_Rib_enriched)
colnames(mca_enrich)[-(1:2)] <- paste0("Enriched_", gsub("_enriched", "", colnames(mca_enrich)[-(1:2)]))

guilak_enrich    <- extract_enrichment_col(crossref_geo,             "SynoviumGuilak", Enriched_Synovium_HalfOrMore)
evfn_enrich      <- extract_enrichment_col(final_evfn,               "Ganglia",  Ganglia_Enriched)
mloyo_enrich     <- extract_enrichment_col(mloyo_display,            "MLOY4",    MLO_Enriched)
cartilage_enrich <- extract_enrichment_col(gse_display,              "Cartilage",Cartilage_Enriched)
condyle_enrich   <- extract_enrichment_col(crossref_condyle,         "Condyle",  Enriched_Condyle_HalfOrMore)
mccool_enrich    <- extract_enrichment_col(crossref_mccool,          "SynoviumMcCool", Enriched_Synovium_HalfOrMore)

# ============================================
# ✅ Merge All Enrichment Tables by Gene
# ============================================

enrich_tables <- list(
  tabula_enrich, mca_enrich, guilak_enrich, evfn_enrich,
  mloyo_enrich, cartilage_enrich, condyle_enrich, mccool_enrich
)

enrichment_summary <- Reduce(function(x, y) full_join(x, y, by = c("Intersection", "Gene")), enrich_tables)

# ============================================
# ✅ View as HTML Table
# ============================================

cat("<details><summary><strong>Click to expand combined enrichment summary across all datasets</strong></summary><br>\n")
knitr::kable(enrichment_summary, format = "html", digits = 4) %>% print()
cat("</details>\n")






# ============================================
# ✅ Filter genes enriched in at least one dataset
# ============================================

# Filter to keep rows with at least one TRUE
filtered_enrichment <- enrichment_summary %>%
  rowwise() %>%
  filter(any(c_across(starts_with("Enriched_")) == TRUE, na.rm = TRUE)) %>%
  ungroup() %>%
  mutate(across(starts_with("Enriched_"), ~ ifelse(.x, TRUE, NA)))  # Replace FALSE with NA (will appear empty)

# ============================================
# ✅ Display filtered enrichment summary
# ============================================

cat("<details><summary><strong>Click to expand filtered enrichment summary (TRUEs only)</strong></summary><br>\n")
knitr::kable(filtered_enrichment, format = "html", digits = 4, na = "") %>%
  print()
cat("</details>\n")



write.csv(filtered_enrichment, "filtered_enrichment.csv", row.names = FALSE)



# ============================================
# ✅ Compute % of Enriched Genes by Intersection and Tissue
# ============================================

library(dplyr)
library(tidyr)



# Function to generate combined logical row for a group of intersections
combine_intersection_group <- function(data, group_name, intersections) {
  data %>%
    filter(Intersection %in% intersections) %>%
    group_by(Gene) %>%
    summarise(across(starts_with("Enriched_"), ~ any(.x, na.rm = TRUE)), .groups = "drop") %>%
    mutate(Intersection = group_name) %>%
    select(Intersection, Gene, everything())
}

# Combine Subchondral intersections
subchondral_combined <- combine_intersection_group(
  enrichment_summary,
  "SubchondralCombined",
  c("SubchondralFemur", "SubchondralTibia", "SubchondralFemur & SubchondralTibia")
)

# Combine Cartilage intersections
cartilage_combined <- combine_intersection_group(
  enrichment_summary,
  "CartilageCombined",
  c("CartilageFemur", "CartilageTibia", "CartilageFemur & CartilageTibia")
)

# Combine Bone Marrow intersections
bonemarrow_combined <- combine_intersection_group(
  enrichment_summary,
  "BoneMarrowCombined",
  c("BoneMarrowFemur", "BoneMarrowTibia", "BoneMarrowFemur & BoneMarrowTibia")
)

# Combine Cartilage intersections
growthplate_combined <- combine_intersection_group(
  enrichment_summary,
  "GrowthPlateCombined",
  c("GrowthPlateFemur", "GrowthPlateTibia", "GrowthPlateFemur & GrowthPlateTibia")
)
 

# Append to enrichment_summary
enrichment_summary <- bind_rows(enrichment_summary, subchondral_combined, cartilage_combined, bonemarrow_combined, growthplate_combined)






# ✅ Reshape and summarize properly
enrichment_long <- enrichment_summary %>%
  pivot_longer(
    cols = starts_with("Enriched_"),
    names_to = "Tissue",
    values_to = "Enriched"
  )

# ✅ Now group, summarize, and pivot to wide format with one row per Intersection
enrichment_percent <- enrichment_long %>%
  group_by(Intersection, Tissue) %>%
  summarise(
    percent_enriched = round(100 * sum(Enriched, na.rm = TRUE) / n(), 2),
    .groups = "drop"
  ) %>%
  pivot_wider(
    names_from = Tissue,
    values_from = percent_enriched
  )


# ============================================
# ✅ Display the final summary table
# ============================================

cat("<details><summary><strong>Click to expand % Enriched Genes per Tissue by Intersection</strong></summary><br>\n")

cat(knitr::kable(
  enrichment_percent,
  format = "html",
  digits = 2,
  table.attr = "class='table table-striped table-bordered'",
  caption = "% Enriched Genes per Tissue by Intersection"
))

cat("\n</details>\n")



```






```{r CrossRef_HierarchicalClustering, echo=FALSE, results='asis', message=FALSE, warning=FALSE, fig.align='center', out.width='100%'}


# ---- Packages ----
library(dplyr)
library(tidyr)
library(tibble)
library(knitr)
library(pheatmap)

# ---- Define grouped public dataset sets ----
dataset_groups <- list(
  TabulaMuris = list(combined_gene_expr),
  MCA         = list(combined_gene_expr_MCA),
  Synovium    = list(crossref_geo, crossref_mccool),
  Ganglia     = list(final_evfn),
  JointCartilageCondyle = list(gse_display, mloyo_display, crossref_condyle)
)

# ---- Folders ----
dir.create("crossrefheatmap", showWarnings = FALSE)
dir.create("crosrefresult",  showWarnings = FALSE)

for (group_name in names(dataset_groups)) {
  cat("\n\n============================\n")
  cat("📊 Dataset Group:", group_name, "\n")
  cat("============================\n")

  group_tables <- dataset_groups[[group_name]]

  # Containers per group
  heatmap_genes_by_tissue <- list()
  heatmap_genes_paragraph_by_tissue <- list()
  similarity_scores_by_tissue <- list()
  rank_matrices_by_tissue <- list()

  for (tissue in names(gene_filtered_list)) {
    message("🔍 Processing: ", tissue)

    obj <- gene_filtered_list[[tissue]]
    DefaultAssay(obj) <- "RNA"
    # Get genes from RNA assay (features)
    tissue_genes <- rownames(obj[["RNA"]])
    n_total_genes <- length(tissue_genes)

    # Extract *_RankPercent columns from each table in this group
    rank_percent_tables <- lapply(group_tables, function(df) {
      df %>%
        dplyr::filter(Gene %in% tissue_genes) %>%
        dplyr::select(Gene, dplyr::matches("_RankPercent$")) %>%
        dplyr::distinct()
    })

    # Merge
    rank_matrix <- Reduce(function(x, y) dplyr::full_join(x, y, by = "Gene"), rank_percent_tables) %>%
      dplyr::distinct(Gene, .keep_all = TRUE) %>%
      tibble::column_to_rownames("Gene") %>%
      dplyr::select(where(is.numeric))

    # Keep genes with data in at least one public dataset
    rank_matrix <- rank_matrix[rowSums(is.na(rank_matrix)) < ncol(rank_matrix), , drop = FALSE]

    if (nrow(rank_matrix) == 0) {
      message("⚠️ Skipped ", tissue, ": no usable genes for this group.\n")
      next
    }

    # Impute missing values per column (median)
    for (j in seq_len(ncol(rank_matrix))) {
      col_j <- rank_matrix[[j]]
      col_j[is.na(col_j)] <- median(col_j, na.rm = TRUE)
      rank_matrix[[j]] <- col_j
    }

    # Save gene names and matrices
    genes_used <- rownames(rank_matrix)
    heatmap_genes_by_tissue[[tissue]] <- genes_used
    heatmap_genes_paragraph_by_tissue[[tissue]] <- paste(genes_used, collapse = ", ")
    rank_matrices_by_tissue[[tissue]] <- rank_matrix

    # Compute similarity
    similarity_matrix <- 100 - rank_matrix

    # Per-dataset scores and gene overlap info
    similarity_scores <- colMeans(similarity_matrix, na.rm = TRUE)
    overlap_counts <- colSums(!is.na(similarity_matrix))
    percent_overlap <- round(100 * overlap_counts / n_total_genes, 2)
    weighted_similarity <- round(similarity_scores * percent_overlap / 100, 2)

    # Combine
    similarity_scores_by_tissue[[tissue]] <- data.frame(
      Tissue = tissue,
      Dataset = names(similarity_scores),
      Similarity = similarity_scores,
      OverlapGenes = overlap_counts,
      TotalGenes = n_total_genes,
      PercentOverlap = percent_overlap,
      WeightedSimilarity = weighted_similarity,
      row.names = NULL
    )
  }

  # ================================
  # ✅ Summary Table & Save
  # ================================
  if (length(similarity_scores_by_tissue)) {
    similarity_df <- dplyr::bind_rows(similarity_scores_by_tissue)

    # Save CSV
    write.csv(similarity_df,
              file = file.path("crosrefresult", paste0("similarity_table_", group_name, ".csv")),
              row.names = FALSE)

    # Global heatmap as JPEG
    similarity_wide <- similarity_df %>%
      dplyr::select(Tissue, Dataset, WeightedSimilarity) %>%
      tidyr::pivot_wider(names_from = Dataset, values_from = WeightedSimilarity) %>%
      tibble::column_to_rownames("Tissue")

    jpeg(file.path("crosrefresult", paste0("heatmap_", group_name, ".jpeg")),
         width = 9, height = 7, units = "in", res = 300)
    pheatmap(similarity_wide,
             cluster_cols = TRUE,
             cluster_rows = TRUE,
             fontsize_row = 9,
             fontsize_col = 9,
             main = paste("Weighted Similarity —", group_name))
    dev.off()
  }

  # ================================
  # ✅ Print Collapsibles by Tissue
  # ================================
  for (tissue in names(heatmap_genes_paragraph_by_tissue)) {
    cat(sprintf("<details><summary><strong>%s (%s)</strong></summary>\n\n", tissue, group_name))

    genes_used <- heatmap_genes_by_tissue[[tissue]]
    n_used <- length(genes_used)
    # Using features of RNA assay for total gene count
    n_total <- length(rownames(gene_filtered_list[[tissue]][["RNA"]]))

    cat("✅ Genes used in heatmap:", n_used, "<br/>\n")
    cat("📊 Total genes in tissue:", n_total, "<br/>\n")

    cat("<p><strong>🧬 Gene list:</strong></p>\n")
    cat("<div style='max-height:150px; overflow:auto;'>\n")
    cat(paste(genes_used, collapse = ", "))
    cat("</div>\n")

    # Table
    cat("<p><strong>📈 Similarity Table:</strong></p>\n")
    print(knitr::kable(similarity_scores_by_tissue[[tissue]], format = "html",
                       table.attr = "class='table table-bordered table-condensed'"))

    # ---- Save per-tissue heatmap ----
    similarity_matrix <- 100 - rank_matrices_by_tissue[[tissue]]
    heatmap_file <- normalizePath(
      file.path("crossrefheatmap", paste0("heatmap_", group_name, "_", tissue, ".png")),
      winslash = "/", mustWork = FALSE
    )
    png(heatmap_file, width = 1200, height = 1000, res = 150)
    pheatmap(similarity_matrix,
             cluster_cols = TRUE,
             cluster_rows = TRUE,
             show_rownames = FALSE,
             fontsize_col = 9,
             main = paste("Similarity —", tissue, "(", group_name, ")"))
    dev.off()

    # ---- Embed the heatmap so it actually shows in the knitted HTML ----
    cat("<p><strong>🔥 Heatmap:</strong></p>\n")
    print(knitr::include_graphics(normalizePath(heatmap_file, winslash = "/", mustWork = FALSE)))
    # (Alternative if you ever need base64: 
    # uri <- knitr::image_uri(heatmap_file); 
    # cat(sprintf("<img src='%s' style='max-width:100%%; height:auto;'>\n", uri))
    # )

    cat("</details>\n\n")
  }
}

```










